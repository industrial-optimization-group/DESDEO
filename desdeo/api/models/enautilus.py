"""Models specific to the E-NAUTILUS point method."""

from typing import Literal

from pydantic import ConfigDict
from sqlmodel import JSON, Column, Field, SQLModel

from desdeo.tools import SolverResults


class ENautilusStepRequest(SQLModel):
    """Model of the request to the E-NAUTILUS method."""

    problem_id: int
    session_id: int | None = Field(default=None)
    parent_state_id: int | None = Field(default=None)
    # non_dominated points fetched from problem metadata in endpoints
    representative_solutions_id: int = Field(description="The id of the representative solutions to be used.")

    current_iteration: int = Field(description="The number of the current iteration.")
    iterations_left: int = Field(description="The number of iterations left.")
    selected_point: dict[str, float] | None = Field(
        sa_column=Column(JSON),
        description=(
            "The selected intermediate point. If first iteration, set this to be the (approximated) nadir point. "
            "If not set, then the point is assumed to be the nadir point of the current approximating set."
        ),
    )
    reachable_point_indices: list[int] = Field(
        description=(
            "The indices indicating the point on the non-dominated set that are "
            "reachable from the currently selected point."
        )
    )
    number_of_intermediate_points: int = Field(description="The number of intermediate points to be generated.")


class ENautilusStepResponse(SQLModel):
    """The response from E-NAUTILUS step endpoint."""

    state_id: int | None = Field(description="The id of the state created by the request that generated this response")

    current_iteration: int = Field(description="Number of the current iteration.")
    iterations_left: int = Field(description="Number of iterations left.")
    intermediate_points: list[dict[str, float]] = Field(sa_column=Column(JSON), description="New intermediate points")
    reachable_best_bounds: list[dict[str, float]] = Field(
        sa_column=Column(JSON),
        description="Best bounds of the objective function values reachable from each intermediate point.",
    )
    reachable_worst_bounds: list[dict[str, float]] = Field(
        sa_column=Column(JSON),
        description="Worst bounds of the objective function values reachable from each intermediate point.",
    )
    closeness_measures: list[float] = Field(description="Closeness measures of each intermediate point.")
    reachable_point_indices: list[list[int]] = Field(
        description="Indices of the reachable points from each intermediate point."
    )


class ENautilusStateResponse(SQLModel):
    """The response model when requesting a state in E-NAUTILUS."""

    request: ENautilusStepRequest = Field(description="The original request for generating the state.")
    response: ENautilusStepResponse = Field(description="The state generated by the request.")


class ENautilusRepresentativeSolutionsResponse(SQLModel):
    """Model of the response when requesting representative solutions from E-NAUTILUS."""

    solutions: list[SolverResults] = Field(
        description="The solutions on the non-dominated front closest to the intermediate points."
    )


class ENautilusFinalizeRequest(SQLModel):
    """Request to finalize E-NAUTILUS and select the final solution."""

    problem_id: int
    session_id: int | None = Field(default=None)
    parent_state_id: int = Field(description="The E-NAUTILUS step state (must have iterations_left == 0).")
    selected_point_index: int = Field(description="Index of the selected intermediate point (0-based).")


class ENautilusFinalizeResponse(SQLModel):
    """Response from E-NAUTILUS finalization."""

    response_type: Literal["e-nautilus.finalize"] = "e-nautilus.finalize"

    state_id: int = Field(description="The ID of the created final state.")
    selected_intermediate_point: dict[str, float] = Field(
        sa_column=Column(JSON),
        description="The intermediate point that was selected by the DM.",
    )
    final_solution: SolverResults = Field(
        description=(
            "The final solution projected to the representative Pareto front. "
            "Note: This is the nearest point on the representative set; a true Pareto "
            "optimal solution dominating this point may exist."
        ),
    )


class ENautilusTreeNodeResponse(SQLModel):
    """A node in the E-NAUTILUS session tree."""

    model_config = ConfigDict(from_attributes=True)

    node_id: int = Field(description="The StateDB id of this node.")
    parent_node_id: int | None = Field(default=None, description="The StateDB id of the parent node.")
    depth: int = Field(description="Depth of this node in the tree (root = 0).")
    node_type: Literal["step", "final"] = Field(description="Whether this is a step or final node.")

    # Step node fields
    current_iteration: int | None = Field(default=None, description="The iteration number at this step.")
    iterations_left: int | None = Field(default=None, description="Iterations remaining at this step.")
    selected_point: dict[str, float] | None = Field(
        default=None, sa_column=Column(JSON), description="The DM's position when this step was taken."
    )
    intermediate_points: list[dict[str, float]] | None = Field(
        default=None, sa_column=Column(JSON), description="Intermediate points shown at this step."
    )
    closeness_measures: list[float] | None = Field(default=None, description="Closeness measures at this step.")

    # Final node fields
    selected_point_index: int | None = Field(default=None, description="Index of the selected intermediate point.")
    selected_intermediate_point: dict[str, float] | None = Field(
        default=None, sa_column=Column(JSON), description="The intermediate point selected in finalization."
    )
    final_solution_objectives: dict[str, float] | None = Field(
        default=None, sa_column=Column(JSON), description="Objective values of the final projected solution."
    )


class ENautilusDecisionEventResponse(SQLModel):
    """A decision event capturing a transition from parent to child node."""

    model_config = ConfigDict(from_attributes=True)

    parent_node_id: int = Field(description="The parent node id.")
    child_node_id: int = Field(description="The child node id.")
    parent_iteration: int = Field(description="Iteration number at the parent.")
    child_iteration: int = Field(description="Iteration number at the child.")
    iterations_left_after: int = Field(description="Iterations left after this decision.")
    starting_point: dict[str, float] | None = Field(
        default=None, sa_column=Column(JSON), description="The DM's position when viewing options."
    )
    chosen_point: dict[str, float] | None = Field(
        default=None, sa_column=Column(JSON), description="The point the DM chose."
    )
    chosen_option_idx: int | None = Field(default=None, description="Index of chosen option among those shown.")


class ENautilusSessionTreeResponse(SQLModel):
    """The complete E-NAUTILUS session tree."""

    model_config = ConfigDict(from_attributes=True)

    session_id: int = Field(description="The interactive session id.")
    nodes: list[ENautilusTreeNodeResponse] = Field(description="All nodes in the tree (step and final).")
    edges: list[list[int]] = Field(description="Edges as [parent_id, child_id] pairs.")
    root_ids: list[int] = Field(description="IDs of root nodes (no parent).")
    decision_events: list[ENautilusDecisionEventResponse] = Field(
        description="Pre-computed decision events for each parent-child transition."
    )
