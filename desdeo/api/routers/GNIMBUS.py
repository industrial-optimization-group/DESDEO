
"""Router for GNIMBUS."""

from typing import Annotated, TypeVar
from collections import Counter

from fastapi import APIRouter, Depends, HTTPException
import numpy as np
from numpy import allclose
from pydantic import BaseModel, Field, ValidationError
from sqlalchemy.orm import Session

from desdeo.api.db import get_db
from desdeo.api.db_models import Preference, GSolutionArchive, MethodState, Method
from desdeo.api.db_models import Problem as ProblemInDB
from desdeo.api.routers.UserAuth import get_current_user
from desdeo.api.schema import User, Methods
from desdeo.mcdm.gnimbus import generate_starting_point, solve_intermediate_solutions, solve_sub_problems
from desdeo.problem.schema import Problem

from desdeo.api.utils.database import (
    database_dependency,
    select,
    update,
    DatabaseDependency,
    DB,
)

from .NIMBUS import (
    FakeNIMBUSResponse,
    InitRequest,
    #NIMBUSIterateRequest as NIMBUSIterateRequest,
    SaveRequest as NIMBUSSaveRequest,
)

router = APIRouter(prefix="/gnimbus")

T = TypeVar("T")


# INIT REQU, NIMBUSRESPONSE

# TODO: Why to use this instead of the normal nimbus response? OK so the below individual responses are needed if using this?
class NIMBUSBasicResponse(BaseModel):
    """The basic response from GNIMBUS."""

    current_solutions: dict[int, list[float]] = Field(description="The current solutions.")


# TODO: Corresponds to NIMBUSResponse for GNIMBUS
class NIMBUSFullResponse(NIMBUSBasicResponse):
    """The full response from initialize GNIMBUS endpoint."""

    objective_symbols: list[str] = Field(description="The symbols of the objectives.")
    objective_long_names: list[str] = Field(description="The names of the objectives.")
    units: list[str | None] | None = Field(description="The units of the objectives.")
    is_maximized: list[bool] = Field(description="Whether the objectives are to be maximized or minimized.")
    lower_bounds: list[float] = Field(description="The lower bounds of the objectives.")
    upper_bounds: list[float] = Field(description="The upper bounds of the objectives.")
    previous_preference: list[float] = Field(description="The previous preference used.")
    saved_solutions: dict[int, list[float]] = Field(description="The best candidate solutions saved by the decision maker.")
    all_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")
    chosen_solutions: dict[int, list[float]] = Field(description="Chosen solutions selected by the decision maker.")
    to_vote: bool = Field(description="Whether current solutions need to be voted as final.")

# FAKENIMBUSRESPONSE

# TODO: GNIMBUSITERATEREQUEST TODO RENAME if in the end its different
class NIMBUSIterateRequest(BaseModel):
    """The request to iterate the NIMBUS algorithm."""

    problem_id: int = Field(description="The ID of the problem to be solved.")
    method_id: int = Field(description="The ID of the method being used.")
    # TODO: this is group preference(s), adjust
    preference: list[float] = Field(
        description=(
            "The preference as a reference point. Note, NIMBUS uses classification preference,"
            " we can construct it using this reference point and the reference solution."
        )
    )
    reference_solution: list[float] = Field(
        description="The reference solution to be used in the classification preference."
    )
    # TODO: this needs to be changed
    num_solutions: int | None = Field(
        description="The number of solutions to be generated in the iteration.", default=3
    )

# TODO: WHY THIS SHOULD BE DIFFERENT FROM NIMBUS? e.g. add prob, method id and give basemodel instead of initrequest?
class NIMBUSIntermediateSolutionRequest(InitRequest):
    """The request to generate an intermediate solution in NIMBUS."""

    reference_solution_1_id: int = Field(
        description="The first reference solution id to be used in the classification preference."
    )
    reference_solution_2_id: int = Field(
        description="The reference solution id to be used in the classification preference."
    )
    num_solutions: int | None = Field(
        description="The number of solutions to be generated in the iteration.", default=1
    )

# TODO: WHY THIS SHOULD BE DIFFERENT FROM NIMBUS? e.g. add prob, method id and give basemodel instead of initrequest?
class NIMBUSIntermediateSolutionRequest(InitRequest):
    """The request to generate an intermediate solution in NIMBUS."""

    reference_solution_1_id: int = Field(
        description="The first reference solution id to be used in the classification preference."
    )
    reference_solution_2_id: int = Field(
        description="The reference solution id to be used in the classification preference."
    )
    num_solutions: int | None = Field(
        description="The number of solutions to be generated in the iteration.", default=1
    )

# AGAIN same that above??
class SaveRequest(NIMBUSSaveRequest):
    """The request to save the solutions."""

    # TODO: NOTE THIS SAVES SOLUTION IDS NOT SOLUTIONS
    solution_ids: list[int] = Field(description="The solution ids to be saved.")

# AGAIN same that above??
class ChooseRequest(InitRequest):
    """The request to choose the final solution."""

    # TODO: is this reference solution id or problem id?
    reference_solution_id: int = Field(description="The ID of the problem to be solved.")
    reference_solution: list[float] = Field(description="The chosen solution.")

# THE REST ARE GNIMBUS VARIANTS


class GroupRequest(BaseModel):
    """The request to navigate the GNIMBUS."""
    # Saved requests as DMs saved requests, eg. to vote or preference?
    request_ids: list[int] = Field(description="List of id of saved requests.")
    cached: bool = Field(description="Determine whether to get saved results.", default=False)


class VoteRequest(InitRequest):
    """The vote request in GNIMBUS."""

    # do we need reference solution (voted solution?) id?
    reference_solution_id: int = Field(description="The reference solution id as in the DB.")
    reference_solution: list[float] = Field(
        description="The reference solution value."
    )



# I GUESS THIS MAKES SENSE
class NIMBUSVoteResponse(BaseModel):
    """The response from iterate endpoint."""

    current_solutions: dict[int, list[float]] = Field(description="The current solutions.")
    to_vote: bool = Field(description="Whether current solutions need to be voted as final.", default=False)

# IS THIS NEEDED?
class NIMBUSIterateResponse(NIMBUSBasicResponse):
    """The response from iterate endpoint."""

    previous_preference: list[float] = Field(description="The previous preference used.")
    all_solutions: dict[int, list[float]] = Field(description="All solutions generated.")

# IS THIS NEEDED?
class NIMBUSIntermediateResponse(NIMBUSBasicResponse):
    """The response from intermediate endpoint."""

    all_solutions: dict[int, list[float]] = Field(description="All solutions generated.")

# IS THIS NEEDED?
class NIMBUSSaveResponse(BaseModel):
    """The response from save endpoint."""

    saved_solutions: dict[int, list[float]] = Field(description="The best candidate solutions saved by the decision maker.")

# IS THIS NEEDED?
class NIMBUSChosenResponse(NIMBUSBasicResponse):
    """The response from chosen NIMBUS."""

    chosen_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")

# is this needed?
class FinalVoteRequest(VoteRequest):
    """The chosen-vote request in GNIMBUS."""

    chosen: bool

# this is needed if above  too? 
class NIMBUSFinalVoteResponse(NIMBUSBasicResponse):
    """The response from chosen-vote endpoint."""

    chosen_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")
    to_vote: bool = Field(description="Whether current solutions need to be voted as final.", default=False)

# I dont get what this is doing? This is just overwriting the earlierly defined nimbusiteraterequest??
class NIMBUSIterateRequest(NIMBUSIterateRequest):
    """The request to iterate the GNIMBUS algorithm."""

    reference_solution_id: int = Field(description="The reference solution id as in the DB.")



# TODO: change name to init_gnimbus
@router.post("/initialize")
def init_nimbus(
    init_request: InitRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> NIMBUSFullResponse | FakeNIMBUSResponse:
    """Initialize the GNIMBUS algorithm.

    Args:
        init_request (InitRequest): The request to initialize the GNIMBUS.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db (Annotated[Session, Depends(get_db)]): The database session.

    Returns:
        NIMBUSFullResponse | FakeNIMBUSResponse: The response from the GNIMBUS algorithm.
    """
    # Do database stuff here.
    problem_id = init_request.problem_id
    # The request is supposed to contain method id, but I don't want to deal with frontend code
    init_request.method_id = get_gnimbus_method_id(db)
    method_id = init_request.method_id

    problem = db.query(ProblemInDB).filter(ProblemInDB.id == problem_id).first()

    # this way can get the solver also.
    #problem, solver = read_problem_from_db(db=db, problem_id=problem_id, user_id=user.index)

    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    # See if there are previous solutions in the database for this problem
    solutions = (
        db.query(GSolutionArchive)
        .filter(GSolutionArchive.problem == problem_id)
        # .filter(GSolutionArchive.user == user.index)
        .all()
    )

    ideal = problem.get_ideal_point()
    nadir = problem.get_nadir_point()

    if None in ideal or None in nadir:
        raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

    # If there are no solutions, generate a starting point for NIMBUS
    if not solutions:
        start_result = generate_starting_point(problem=problem)
        current_solution = GSolutionArchive(
            user=user.index,
            problem=problem_id,
            method=method_id,
            decision_variables=list(start_result.optimal_variables.values()),
            objectives=list(start_result.optimal_objectives.values()),
            saved=False,
            current=True,
            chosen=False,
        )

        # Save the generated starting point to the db
        db.add(current_solution)
        db.commit()

        solutions = [current_solution]
    else:
        # If there is a solution marked as current, use that. Otherwise just use the first solution in the db
        current_solution = next((sol for sol in solutions if sol.current), solutions[0])

    lower_bounds = [0.0 for x in range(len(problem.objectives))]
    upper_bounds = [0.0 for x in range(len(problem.objectives))]

    for i in range(len(problem.objectives)):
        if problem.objectives[i].maximize:
            lower_bounds[i] = nadir[problem.objectives[i].symbol]
            upper_bounds[i] = ideal[problem.objectives[i].symbol]
        else:
            lower_bounds[i] = ideal[problem.objectives[i].symbol]
            upper_bounds[i] = nadir[problem.objectives[i].symbol]

    # return FakeNIMBUSResponse(message="NIMBUS initialized.")
    resp = NIMBUSFullResponse(
        objective_symbols=[obj.symbol for obj in problem.objectives],
        objective_long_names=[obj.name for obj in problem.objectives],
        units=[obj.unit for obj in problem.objectives],
        is_maximized=[obj.maximize for obj in problem.objectives],
        lower_bounds=lower_bounds,
        upper_bounds=upper_bounds,
        previous_preference=current_solution.objectives,
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        to_vote=len([sol.id for sol in solutions if sol.to_vote and sol.current]) > 0,
        saved_solutions={sol.id: sol.objectives for sol in solutions if sol.saved},
        all_solutions={sol.id: sol.objectives for sol in solutions},
        chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen}
    )
    print(resp)

    return NIMBUSFullResponse(
        objective_symbols=[obj.symbol for obj in problem.objectives],
        objective_long_names=[obj.name for obj in problem.objectives],
        units=[obj.unit for obj in problem.objectives],
        is_maximized=[obj.maximize for obj in problem.objectives],
        lower_bounds=lower_bounds,
        upper_bounds=upper_bounds,
        previous_preference=current_solution.objectives,
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        to_vote=len([sol.id for sol in solutions if sol.to_vote and sol.current]) > 0,
        saved_solutions={sol.id: sol.objectives for sol in solutions if sol.saved},
        all_solutions={sol.id: sol.objectives for sol in solutions},
        chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen}
    )

async def processGroupRequest(
    grequest: GroupRequest,
    db: Annotated[DB, Depends(database_dependency)]
) -> list[T]:
    """Process group request.

    Args:
        grequest (GroupRequest): The request to process.
        db (Annotated[DB, Depends(database_dependency)]): The database session.

    Returns:
        list[T]: The rows of requests submitted by DMs.
    """

    requestRows = await db.all(select(MethodState).filter(MethodState.id.in_(grequest.request_ids)))

    return requestRows


def getMostSelected(
    values: list[int] | list[bool],
) -> list[int]:
    """Get most selected id.

    Args:
        values (list[int] | list[bool]): List of values.

    Returns:
        list[int]: The most selected value(s).
    """

    listCounter = Counter(values)
    most_count = listCounter.most_common(1)[0][1]

    return [n[0] for n in listCounter.most_common() if n[1] == most_count]


async def getMostSelectedSolutions(
    db: Annotated[DB, Depends(database_dependency)],
    requests: list[VoteRequest | NIMBUSIterateRequest | ChooseRequest]
) -> dict[int, list[float]]:
    """Get most selected solutions.

    Args:
        db (Annotated[DB, Depends(database_dependency)]): The database session.
        requests: list[VoteRequest | NIMBUSIterateRequest | ChooseRequest]: List of requests.

    Returns:
        dict[int, list[float]]: List of most selected solutions.
    """

    reference_solutions = {request.reference_solution_id: request.reference_solution for request in requests}
    reference_solutions_ids = [request.reference_solution_id for request in requests]
    selected_ref_solution_ids = getMostSelected(reference_solutions_ids)

    await db.update(
        update(GSolutionArchive)
        .where(GSolutionArchive.id.notin_(selected_ref_solution_ids))
        .values(current=False)
    )
    await db.commit()

    return {id: reference_solutions[id] for id in selected_ref_solution_ids}


@router.post("/final-solution-vote")
async def finalSolutionVote(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSFinalVoteResponse | FakeNIMBUSResponse:
    """Vote for a final / current solution.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSFinalVoteResponse | FakeNIMBUSResponse: The response from the GNIMBUS chosen-vote endpoint.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [FinalVoteRequest.model_validate(requestRow.value) for requestRow in requestRows]

    if not grequest.cached:
        votes = set(request.chosen for request in requests)
        # Most voted wins
        '''
        mostVoted = getMostSelected(votes)

        if len(mostVoted) > 1 or mostVoted[0] == False:
            solutions = await db.update(
                update(GSolutionArchive)
                .where(GSolutionArchive.id==requests[0].reference_solution_id)
                .values(current=True)
                .returning(GSolutionArchive)
            )
        '''

        if len(votes) == 1 and list(votes)[0] == True:
            solutions = await db.update(
                update(GSolutionArchive)
                .where(GSolutionArchive.id==requests[0].reference_solution_id)
                .values(current=True, chosen=True, to_vote=False)
                .returning(GSolutionArchive)
            )
        else:
            solutions = await db.update(
                update(GSolutionArchive)
                .where(GSolutionArchive.id==requests[0].reference_solution_id)
                .values(current=True, to_vote=False)
                .returning(GSolutionArchive)
            )
        await db.commit()

        return NIMBUSFinalVoteResponse(
            chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen},
            current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        )
    else:
        solutions = (
            await db.all(select(GSolutionArchive)
            .filter_by(problem=requests[0].problem_id)
            .filter((GSolutionArchive.current==True) | (GSolutionArchive.chosen==True))
            .order_by(GSolutionArchive.id.asc()))
        )

        return NIMBUSFinalVoteResponse(
            chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen},
            current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        )

@router.post("/solution-vote")
async def solutionVote(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSBasicResponse | NIMBUSVoteResponse | NIMBUSIntermediateResponse | FakeNIMBUSResponse:
    """Vote for a current solution.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSBasicResponse | NIMBUSVoteResponse | NIMBUSIntermediateResponse | FakeNIMBUSResponse:
            The response from the GNIMBUS vote endpoint.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [VoteRequest.model_validate(requestRow.value) for requestRow in requestRows]

    if not grequest.cached:
        reference_solutions = await getMostSelectedSolutions(db, requests)

        if len(reference_solutions) > 1:
            if len(reference_solutions) == 2:
                return await intermediate(
                    NIMBUSIntermediateSolutionRequest(
                        problem_id=requests[0].problem_id,
                        method_id=requests[0].method_id,
                        reference_solution_1_id=list(reference_solutions.keys())[0],
                        reference_solution_2_id=list(reference_solutions.keys())[1],
                    ),
                    user,
                    db
                )
            return NIMBUSBasicResponse(
                current_solutions=reference_solutions
            )
        selected_ref_solution_id = list(reference_solutions.keys())[0]
        selected_reference_solution = list(reference_solutions.values())[0]

        # Check if DMs all go for 1 single solution
        reference_solution_ids = set(request.reference_solution_id for request in requests)
        if len(reference_solution_ids) == 1:
            await db.update(
                update(GSolutionArchive)
                .where(GSolutionArchive.id==selected_ref_solution_id)
                .values(to_vote=True)
            )
            await db.commit()

            return NIMBUSVoteResponse(
                current_solutions={selected_ref_solution_id: selected_reference_solution},
                to_vote=True
            )
        # In case voting is possible for chosen solutions
        '''
        vote_solution = await db.first(select(GSolutionArchive).filter_by(id=selected_ref_solution_id))

        if vote_solution.chosen:
            await db.update(
                update(GSolutionArchive)
                .where(GSolutionArchive.id!=selected_ref_solution_id)
                .values(chosen=False)
            )
        '''

        return NIMBUSBasicResponse(
            current_solutions={selected_ref_solution_id: selected_reference_solution},
        )
    else:
        solutions = (
            await db.all(select(GSolutionArchive)
            .filter_by(problem=requests[0].problem_id)
            .filter(GSolutionArchive.current==True)
            .order_by(GSolutionArchive.id.asc()))
        )

        return NIMBUSVoteResponse(
            current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
            to_vote=len([sol.id for sol in solutions if sol.to_vote and sol.current]) > 0,
        )


@router.post("/iterate")
async def iterate(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSIterateResponse | FakeNIMBUSResponse:
    """Iterate the GNIMBUS algorithm.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSIterateResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [NIMBUSIterateRequest.model_validate(requestRow.value) for requestRow in requestRows]

    problem_id = requests[0].problem_id
    method_id = requests[0].method_id

    print("at iterate method_id", method_id)

    problem = await db.first(select(ProblemInDB).filter_by(id=problem_id))
    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    if not grequest.cached:
        reference_solution = requests[0].reference_solution

        # Save the given preferences
        for r in requests:
            pref = Preference(
                user=user.index, problem=problem_id, method=method_id, kind="GNIMBUS", value=r.model_dump(mode="json")
            )
            await db.add(pref)

        previous_solutions = (
            await db.all(select(GSolutionArchive)
            .filter_by(problem=problem_id)
            .order_by(GSolutionArchive.id.asc()))
        )

        if not previous_solutions:
            raise HTTPException(status_code=404, detail="Problem not found in the database.")

        ideal = problem.get_ideal_point()
        nadir = problem.get_nadir_point()
        if None in ideal or None in nadir:
            raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

        # Do NIMBUS stuff here.
        results = solve_sub_problems(
            problem=problem,
            current_objectives=dict(zip([obj.symbol for obj in problem.objectives], reference_solution, strict=True)),
            reference_points=[dict(zip([obj.symbol for obj in problem.objectives], request.preference, strict=True)) for request in requests],
            num_desired=len(requests) - 1 if len(requests) > 2 else 2,
        )

        # Move on only with successful results
        results = [r for r in results if r.success and len(r.optimal_objectives.values()) > 0]

        # See if the results include duplicates and remove them
        duplicate_indices = set()
        for i in range(len(results) - 1):
            for j in range(i + 1, len(results)):
                if allclose(list(results[i].optimal_objectives.values()), list(results[j].optimal_objectives.values())):
                    duplicate_indices.add(j)

        for index in sorted(list(duplicate_indices), reverse=True):
            results.pop(index)

        # Mark all the old solutions as not current, not new
        await db.update(
            update(GSolutionArchive)
            .where(GSolutionArchive.problem==problem_id, GSolutionArchive.current==True)
            .values(current=False)
        )

        for res in results:
            await db.add(
                GSolutionArchive(
                    user=user.index,
                    problem=problem_id,
                    method=method_id,
                    decision_variables=list(res.optimal_variables.values()),
                    objectives=list(res.optimal_objectives.values()),
                    saved=False,
                    current=True,
                    chosen=False,
                )
            )

        await db.commit()

    solutions = (
        await db.all(select(GSolutionArchive)
            .filter_by(problem=problem_id)
            .order_by(GSolutionArchive.id.asc()))
    )

    all_solutions = {sol.id: sol.objectives for sol in solutions}
    current_solutions = {sol.id: sol.objectives for sol in solutions if sol.current}

    # Case: If the number of all sols is 1, keep it as current
    '''if not grequest.cached:
        if len(all_solutions) > 1:
            # Mark all the old solutions as not current
            old_current_solutions = await db.update(
                update(GSolutionArchive)
                .where(GSolutionArchive.problem==problem_id, GSolutionArchive.current==True)
                .values(current=False)
                .returning(GSolutionArchive)
            )

            current_solutions = {sol.id: sol.objectives for sol in old_current_solutions if sol.current}'''

    res = NIMBUSIterateResponse(
        previous_preference=requests[0].preference,
        current_solutions=current_solutions,
        all_solutions=all_solutions,
    )

    print(res)
    return NIMBUSIterateResponse(
        previous_preference=requests[0].preference,
        current_solutions=current_solutions,
        all_solutions=all_solutions,
    )

@router.post("/intermediate")
async def intermediate(
    request: NIMBUSIntermediateSolutionRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSIntermediateResponse | FakeNIMBUSResponse:
    """Get solutions between two solutions using NIMBUS.

    Args:
        request (NIMBUSIntermediateSolutionRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSIntermediateResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """
    # Do database stuff here.
    problem_id = request.problem_id
    method_id = request.method_id

    problem = await db.first(select(ProblemInDB).filter_by(id=problem_id))
    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    previous_solutions = (
        await db.all(select(GSolutionArchive)
        .filter_by(problem=problem_id)
        .order_by(GSolutionArchive.id.asc()))
    )

    if not previous_solutions:
        raise HTTPException(status_code=404, detail="Problem not found in the database.")

    ideal = problem.get_ideal_point()
    nadir = problem.get_nadir_point()
    if None in ideal or None in nadir:
        raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

    solutions = await db.all(select(GSolutionArchive).filter(GSolutionArchive.id.in_([request.reference_solution_1_id, request.reference_solution_2_id])))

    # Do NIMBUS stuff here.
    results = solve_intermediate_solutions(
        problem=problem,
        solution_1=dict(zip([var.symbol for var in problem.variables], solutions[0].decision_variables[0:len(problem.variables)], strict=True)),
        solution_2=dict(zip([var.symbol for var in problem.variables], solutions[1].decision_variables[0:len(problem.variables)], strict=True)),
        num_desired=request.num_solutions,
    )

    # See if the results include duplicates and remove them
    duplicate_indices = set()
    for i in range(len(results) - 1):
        for j in range(i + 1, len(results)):
            if allclose(list(results[i].optimal_objectives.values()), list(results[j].optimal_objectives.values())):
                duplicate_indices.add(j)

    for index in sorted(list(duplicate_indices), reverse=True):
        results.pop(index)

    # Do database stuff again.
    # Save the given preferences
    pref = Preference(
        user=user.index,
        problem=problem_id,
        method=method_id,
        kind="NIMBUS_intermediate",
        value=request.model_dump(mode="json"),
    )
    await db.add(pref)

    # Mark all the old solutions as not current
    await db.update(
        update(GSolutionArchive)
        .where(GSolutionArchive.problem==problem_id, GSolutionArchive.current==True)
        .values(current=False)
    )

    for res in results:
        await db.add(
            GSolutionArchive(
                user=user.index,
                problem=problem_id,
                method=method_id,
                decision_variables=list(res.optimal_variables.values()),
                objectives=list(res.optimal_objectives.values()),
                saved=False,
                current=True,
                chosen=False,
            )
        )

    await db.commit()

    solutions = (
        await db.all(select(GSolutionArchive)
            .filter_by(problem=problem_id)
            .order_by(GSolutionArchive.id.asc()))
    )

    return NIMBUSIntermediateResponse(
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        all_solutions={sol.id: sol.objectives for sol in solutions},
    )

@router.post("/save")
async def save(
    request: SaveRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSSaveResponse | FakeNIMBUSResponse:
    """Save the solutions to the database.

    Args:
        grequest (GroupRequest): The request to choose.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        The response from the NIMBUS algorithm.
    """

    await db.update(
        update(GSolutionArchive)
        .where(GSolutionArchive.id.in_(request.solution_ids))
        .values(saved=True)
    )
    await db.commit()

    saved_solutions = (
        await db.all(select(GSolutionArchive)
            .filter_by(problem=problem_id, saved=True)
            .order_by(GSolutionArchive.id.asc()))
    )

    return NIMBUSSaveResponse(
        saved_solutions={sol.id: sol.objectives for sol in saved_solutions},
    )

@router.post("/choose")
async def choose(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSChosenResponse | FakeNIMBUSResponse:
    """Choose a solution as the final solution for NIMBUS.

    Args:
        grequest (GroupRequest): The request to choose.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSChooseResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [ChooseRequest.model_validate(requestRow.value) for requestRow in requestRows]

    problem_id = requests[0].problem_id

    if not grequest.cached:
        reference_solutions = await getMostSelectedSolutions(db, requests)
        selected_solution_ids = list(reference_solutions.keys())

        solutions = await db.update(
            update(GSolutionArchive)
            .where(GSolutionArchive.id.in_(selected_solution_ids))
            .values(chosen=True)
            .returning(GSolutionArchive)
        )
        await db.commit()
    else:
        solutions = (
            await db.all(select(GSolutionArchive)
                .filter_by(problem=problem_id, chosen=True)
                .order_by(GSolutionArchive.id.asc()))
        )

    return NIMBUSChosenResponse(
        chosen_solutions={sol.id: sol.objectives for sol in solutions},
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
    )


## UTILITY FUNCTIONS

def get_gnimbus_method_id(db: Session) -> int:
    """Queries the database to find the id for GNIMBUS method.

    Args:
        db: Database session

    Returns:
        The method id
    """
    gnimbus_method = db.query(Method).filter(Method.kind == Methods.GNIMBUS).first()
    return gnimbus_method.id

# TODO: see if can just import from NIMBUS API. Currently does not work with gnimbus becuase problem.owner!
def read_problem_from_db(db: Session, problem_id: int, user_id: int) -> tuple[Problem, str]:
    """Reads the problem from database.

    Args:
        db (Session): Database session to be used
        problem_id (int): Id of the problem
        method_id (int): Id of the method
        user_id (int): Index of the user

    Raises:
        HTTPException: _description_
        HTTPException: _description_
        HTTPException: _description_

    Returns:
        tuple[Problem, str]: Returns the problem as a desdeo problem class and the name of the solver
    """
    problem = db.query(ProblemInDB).filter(ProblemInDB.id == problem_id).first()

    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    if problem.owner != user_id and problem.owner is not None:
        raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        solver = problem.solver.value
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError
    return problem, solver