"""Router for GNIMBUS."""

from typing import Annotated, TypeVar
from collections import Counter

from fastapi import APIRouter, Depends, HTTPException
import numpy as np
from numpy import allclose
from pydantic import BaseModel, Field, ValidationError
from sqlalchemy.orm import Session

from desdeo.api.db import get_db
from desdeo.api.db_models import Preference, SolutionArchive, MethodState
from desdeo.api.db_models import Problem as ProblemInDB
from desdeo.api.routers.UserAuth import get_current_user
from desdeo.api.schema import User
from desdeo.mcdm.gnimbus import generate_starting_point, solve_intermediate_solutions, solve_sub_problems
from desdeo.problem.schema import Problem

from desdeo.api.utils.database import (
    database_dependency,
    select,
    update,
    DatabaseDependency,
    DB,
)

from .NIMBUS import (
    FakeNIMBUSResponse,
    InitRequest,
    NIMBUSIterateRequest as NIMBUSIterateRequest,
    SaveRequest as NIMBUSSaveRequest,
)

router = APIRouter(prefix="/gnimbus")

T = TypeVar("T")

class GroupRequest(BaseModel):
    """The request to navigate the GNIMBUS."""

    request_ids: list[int] = Field(description="List of id of saved requests.")
    cached: bool = Field(description="Determine whether to get saved results.", default=False)


class VoteRequest(InitRequest):
    """The vote request in GNIMBUS."""

    reference_solution_id: int = Field(description="The reference solution id as in the DB.")
    reference_solution: list[float] = Field(
        description="The reference solution value."
    )


class FinalVoteRequest(VoteRequest):
    """The chosen-vote request in GNIMBUS."""

    chosen: bool


class NIMBUSBasicResponse(BaseModel):
    """The basic response from GNIMBUS."""

    current_solutions: dict[int, list[float]] = Field(description="The current solutions.")


class NIMBUSFullResponse(NIMBUSBasicResponse):
    """The full response from initialize GNIMBUS endpoint."""

    objective_symbols: list[str] = Field(description="The symbols of the objectives.")
    objective_long_names: list[str] = Field(description="The names of the objectives.")
    units: list[str | None] | None = Field(description="The units of the objectives.")
    is_maximized: list[bool] = Field(description="Whether the objectives are to be maximized or minimized.")
    lower_bounds: list[float] = Field(description="The lower bounds of the objectives.")
    upper_bounds: list[float] = Field(description="The upper bounds of the objectives.")
    previous_preference: list[float] = Field(description="The previous preference used.")
    saved_solutions: dict[int, list[float]] = Field(description="The best candidate solutions saved by the decision maker.")
    new_solutions: dict[int, list[float]] = Field(description="The newly generated solutions from the current interation of nimbus.")
    all_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")
    chosen_solutions: dict[int, list[float]] = Field(description="Chosen solutions selected by the decision maker.")


class NIMBUSVoteResponse(BaseModel):
    """The response from iterate endpoint."""

    current_solutions: dict[int, list[float]] = Field(description="The current solutions.")
    new_solutions: dict[int, list[float]] = Field(description="The newly generated solutions from the current interation of nimbus.")


class NIMBUSIterateResponse(NIMBUSBasicResponse):
    """The response from iterate endpoint."""

    previous_preference: list[float] = Field(description="The previous preference used.")
    new_solutions: dict[int, list[float]] = Field(description="The newly generated solutions from the current interation of nimbus.")
    all_solutions: dict[int, list[float]] = Field(description="All solutions generated.")


class NIMBUSIntermediateResponse(NIMBUSBasicResponse):
    """The response from intermediate endpoint."""

    all_solutions: dict[int, list[float]] = Field(description="All solutions generated.")


class NIMBUSSaveResponse(BaseModel):
    """The response from save endpoint."""

    saved_solutions: dict[int, list[float]] = Field(description="The best candidate solutions saved by the decision maker.")


class NIMBUSChosenResponse(NIMBUSBasicResponse):
    """The response from chosen NIMBUS."""

    chosen_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")


class NIMBUSFinalVoteResponse(NIMBUSBasicResponse):
    """The response from chosen-vote endpoint."""

    chosen_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")


class NIMBUSIntermediateSolutionRequest(InitRequest):
    """The request to generate an intermediate solution in NIMBUS."""

    reference_solution_1_id: int = Field(
        description="The first reference solution id to be used in the classification preference."
    )
    reference_solution_2_id: int = Field(
        description="The reference solution id to be used in the classification preference."
    )
    num_solutions: int | None = Field(
        description="The number of solutions to be generated in the iteration.", default=1
    )


class NIMBUSIterateRequest(NIMBUSIterateRequest):
    """The request to iterate the GNIMBUS algorithm."""

    reference_solution_id: int = Field(description="The reference solution id as in the DB.")


class SaveRequest(NIMBUSSaveRequest):
    """The request to save the solutions."""

    solution_ids: list[int] = Field(description="The solution ids to be saved.")


class ChooseRequest(InitRequest):
    """The request to choose the final solution."""

    reference_solution_id: int = Field(description="The ID of the problem to be solved.")
    reference_solution: list[float] = Field(description="The chosen solution.")


@router.post("/initialize")
def init_nimbus(
    init_request: InitRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> NIMBUSFullResponse | FakeNIMBUSResponse:
    """Initialize the GNIMBUS algorithm.

    Args:
        init_request (InitRequest): The request to initialize the GNIMBUS.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db (Annotated[Session, Depends(get_db)]): The database session.

    Returns:
        NIMBUSFullResponse | FakeNIMBUSResponse: The response from the GNIMBUS algorithm.
    """

    problem_id = init_request.problem_id
    method_id = init_request.method_id
    problem = db.query(ProblemInDB).filter(ProblemInDB.id == problem_id).first()

    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    # See if there are previous solutions in the database for this problem
    solutions = (
        db.query(SolutionArchive)
        .filter(SolutionArchive.problem == problem_id)
        # .filter(SolutionArchive.user == user.index)
        .all()
    )

    ideal = problem.get_ideal_point()
    nadir = problem.get_nadir_point()

    if None in ideal or None in nadir:
        raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

    # If there are no solutions, generate a starting point for NIMBUS
    if not solutions:
        start_result = generate_starting_point(problem=problem)
        current_solution = SolutionArchive(
            user=user.index,
            problem=problem_id,
            method=method_id,
            decision_variables=list(start_result.optimal_variables.values()),
            objectives=list(start_result.optimal_objectives.values()),
            saved=False,
            new=True,
            current=True,
            chosen=False,
        )

        # Save the generated starting point to the db
        db.add(current_solution)
        db.commit()

        solutions = [current_solution]
    else:
        # If there is a solution marked as current, use that. Otherwise just use the first solution in the db
        current_solution = next((sol for sol in solutions if sol.current), solutions[0])

    lower_bounds = [0.0 for x in range(len(problem.objectives))]
    upper_bounds = [0.0 for x in range(len(problem.objectives))]

    for i in range(len(problem.objectives)):
        if problem.objectives[i].maximize:
            lower_bounds[i] = nadir[problem.objectives[i].symbol]
            upper_bounds[i] = ideal[problem.objectives[i].symbol]
        else:
            lower_bounds[i] = ideal[problem.objectives[i].symbol]
            upper_bounds[i] = nadir[problem.objectives[i].symbol]

    # return FakeNIMBUSResponse(message="NIMBUS initialized.")
    return NIMBUSFullResponse(
        objective_symbols=[obj.symbol for obj in problem.objectives],
        objective_long_names=[obj.name for obj in problem.objectives],
        units=[obj.unit for obj in problem.objectives],
        is_maximized=[obj.maximize for obj in problem.objectives],
        lower_bounds=lower_bounds,
        upper_bounds=upper_bounds,
        previous_preference=current_solution.objectives,
        new_solutions={sol.id: sol.objectives for sol in solutions if sol.new},
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        saved_solutions={sol.id: sol.objectives for sol in solutions if sol.saved},
        all_solutions={sol.id: sol.objectives for sol in solutions},
        chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen}
    )

async def processGroupRequest(
    grequest: GroupRequest,
    db: Annotated[DB, Depends(database_dependency)]
) -> list[T]:
    """Process group request.

    Args:
        grequest (GroupRequest): The request to process.
        db (Annotated[DB, Depends(database_dependency)]): The database session.

    Returns:
        list[T]: The rows of requests submitted by DMs.
    """

    requestRows = await db.all(select(MethodState).filter(MethodState.id.in_(grequest.request_ids)))

    return requestRows


def getMostSelected(
    values: list[int] | list[bool],
) -> list[int]:
    """Get most selected id.

    Args:
        values (list[int] | list[bool]): List of values.

    Returns:
        list[int]: The most selected value(s).
    """

    listCounter = Counter(values)
    most_count = listCounter.most_common(1)[0][1]

    return [n[0] for n in listCounter.most_common() if n[1] == most_count]


async def getMostSelectedSolutions(
    db: Annotated[DB, Depends(database_dependency)],
    requests: list[VoteRequest | NIMBUSIterateRequest | ChooseRequest]
) -> dict[int, list[float]]:
    """Get most selected solutions.

    Args:
        db (Annotated[DB, Depends(database_dependency)]): The database session.
        requests: list[VoteRequest | NIMBUSIterateRequest | ChooseRequest]: List of requests.

    Returns:
        dict[int, list[float]]: List of most selected solutions.
    """

    reference_solutions = {request.reference_solution_id: request.reference_solution for request in requests}
    reference_solutions_ids = [request.reference_solution_id for request in requests]
    selected_ref_solution_ids = getMostSelected(reference_solutions_ids)

    await db.update(
        update(SolutionArchive)
        .where(SolutionArchive.id.in_(selected_ref_solution_ids))
        .values(current=True)
    )

    return {id: reference_solutions[id] for id in selected_ref_solution_ids}


@router.post("/final-solution-vote")
async def finalSolutionVote(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSFinalVoteResponse | FakeNIMBUSResponse:
    """Vote for a final / current solution.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSFinalVoteResponse | FakeNIMBUSResponse: The response from the GNIMBUS chosen-vote endpoint.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [FinalVoteRequest.model_validate(requestRow.value) for requestRow in requestRows]

    if not grequest.cached:
        votes = set(request.chosen for request in requests)
        # Most voted wins
        '''
        mostVoted = getMostSelected(votes)

        if len(mostVoted) > 1 or mostVoted[0] == False:
            solutions = await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.id==requests[0].reference_solution_id)
                .values(current=True)
                .returning(SolutionArchive)
            )
        '''

        if len(votes) == 1 and list(votes)[0] == True:
            solutions = await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.id==requests[0].reference_solution_id)
                .values(current=True, chosen=True)
                .returning(SolutionArchive)
            )
        else:
            solutions = await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.id==requests[0].reference_solution_id)
                .values(current=True)
                .returning(SolutionArchive)
            )

        return NIMBUSFinalVoteResponse(
            chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen},
            current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        )
    else:
        solutions = (
            await db.all(select(SolutionArchive)
            .filter_by(problem=requests[0].problem_id)
            .filter((SolutionArchive.current==True) | (SolutionArchive.chosen==True))
            .order_by(SolutionArchive.id.asc()))
        )

        return NIMBUSFinalVoteResponse(
            chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen},
            current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        )

@router.post("/solution-vote")
async def solutionVote(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSBasicResponse | NIMBUSVoteResponse | NIMBUSIntermediateResponse | FakeNIMBUSResponse:
    """Vote for a current solution.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSBasicResponse | NIMBUSVoteResponse | NIMBUSIntermediateResponse | FakeNIMBUSResponse:
            The response from the GNIMBUS vote endpoint.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [VoteRequest.model_validate(requestRow.value) for requestRow in requestRows]

    if not grequest.cached:
        reference_solution_ids = set(request.reference_solution_id for request in requests)

        if len(reference_solution_ids) == 1:
            reference_solutions = {request.reference_solution_id: request.reference_solution for request in requests}
            selected_ref_solution_id = list(reference_solution_ids)[0]
            selected_reference_solution = reference_solutions[selected_ref_solution_id]

            vote_solution = await db.first(select(SolutionArchive).filter_by(id=selected_ref_solution_id))

            if not vote_solution.current:
                await db.update(
                    update(SolutionArchive)
                    .where(SolutionArchive.id!=selected_ref_solution_id)
                    .values(new=False)
                )

                return NIMBUSVoteResponse(
                    current_solutions={vote_solution.id: vote_solution.objectives for sol in [vote_solution] if sol.current},
                    new_solutions={vote_solution.id: vote_solution.objectives for sol in [vote_solution] if sol.new},
                )

            await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.id!=selected_ref_solution_id)
                .values(current=False)
            )

            return NIMBUSBasicResponse(
                current_solutions={selected_ref_solution_id: selected_reference_solution},
            )

        await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.problem==requests[0].problem_id, SolutionArchive.current==True)
            .values(current=False)
        )

        reference_solutions = await getMostSelectedSolutions(db, requests)
        if len(reference_solutions) > 1:
            if len(reference_solutions) == 2:
                return await intermediate(
                    NIMBUSIntermediateSolutionRequest(
                        problem_id=requests[0].problem_id,
                        method_id=requests[0].method_id,
                        reference_solution_1_id=list(reference_solutions.keys())[0],
                        reference_solution_2_id=list(reference_solutions.keys())[1],
                    ),
                    user,
                    db
                )
            return NIMBUSBasicResponse(
                current_solutions=reference_solutions
            )

        selected_ref_solution_id = list(reference_solutions.keys())[0]
        selected_reference_solution = list(reference_solutions.values())[0]

        # In case voting is possible for chosen solutions
        '''
        vote_solution = await db.first(select(SolutionArchive).filter_by(id=selected_ref_solution_id))

        if vote_solution.chosen:
            await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.id!=selected_ref_solution_id)
                .values(chosen=False)
            )
        '''

        return NIMBUSBasicResponse(
            current_solutions={selected_ref_solution_id: selected_reference_solution},
        )
    else:
        solutions = (
            await db.all(select(SolutionArchive)
            .filter_by(problem=requests[0].problem_id)
            .filter((SolutionArchive.current==True) | (SolutionArchive.new==True))
            .order_by(SolutionArchive.id.asc()))
        )

        return NIMBUSVoteResponse(
            current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
            new_solutions={sol.id: sol.objectives for sol in solutions if sol.new},
        )


@router.post("/iterate")
async def iterate(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSIterateResponse | FakeNIMBUSResponse:
    """Iterate the GNIMBUS algorithm.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSIterateResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [NIMBUSIterateRequest.model_validate(requestRow.value) for requestRow in requestRows]

    problem_id = requests[0].problem_id
    method_id = requests[0].method_id

    problem = await db.first(select(ProblemInDB).filter_by(id=problem_id))
    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    if not grequest.cached:
        reference_solution = requests[0].reference_solution

        # Save the given preferences
        for r in requests:
            pref = Preference(
                user=user.index, problem=problem_id, method=method_id, kind="NIMBUS", value=r.model_dump(mode="json")
            )
            await db.add(pref)

        previous_solutions = (
            await db.all(select(SolutionArchive)
            .filter_by(problem=problem_id)
            .order_by(SolutionArchive.id.asc()))
        )

        if not previous_solutions:
            raise HTTPException(status_code=404, detail="Problem not found in the database.")

        ideal = problem.get_ideal_point()
        nadir = problem.get_nadir_point()
        if None in ideal or None in nadir:
            raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

        # Do NIMBUS stuff here.
        results = solve_sub_problems(
            problem=problem,
            current_objectives=dict(zip([obj.symbol for obj in problem.objectives], reference_solution, strict=True)),
            reference_points=[dict(zip([obj.symbol for obj in problem.objectives], request.preference, strict=True)) for request in requests],
            num_desired=len(requests) - 1 if len(requests) > 2 else 2,
        )

        # Move on only with successful results
        results = [r for r in results if r.success and len(r.optimal_objectives.values()) > 0]

        # See if the results include duplicates and remove them
        duplicate_indices = set()
        for i in range(len(results) - 1):
            for j in range(i + 1, len(results)):
                if allclose(list(results[i].optimal_objectives.values()), list(results[j].optimal_objectives.values())):
                    duplicate_indices.add(j)

        for index in sorted(list(duplicate_indices), reverse=True):
            results.pop(index)

        # Mark all the old solutions as not current
        await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.problem==problem_id, SolutionArchive.new==True)
            .values(new=False)
            .returning(SolutionArchive)
        )

        solutions = {i: sol for i, sol in enumerate(previous_solutions)}
        solutionsToUpdate = set()
        for res in results:
            # Check if the results already exist in the database
            solutionIndex = -1
            for i, prev in solutions.items():
                if allclose(list(res.optimal_objectives.values()), list(prev.objectives)):
                    previous_solutions[i].new = True
                    solutions.pop(i)
                    solutionsToUpdate.add(previous_solutions[i].id)
                    solutionIndex = i
                    break

            # If the solution was not found in the database, add it
            if solutionIndex < 0 or not previous_solutions[solutionIndex].new:
                await db.add(
                    SolutionArchive(
                        user=user.index,
                        problem=problem_id,
                        method=method_id,
                        decision_variables=list(res.optimal_variables.values()),
                        objectives=list(res.optimal_objectives.values()),
                        saved=False,
                        current=False,
                        new=True,
                        chosen=False,
                    )
                )

        await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.id.in_(solutionsToUpdate))
            .values(new=True)
        )

        await db.commit()

    solutions = (
        await db.all(select(SolutionArchive)
                    .filter_by(problem=problem_id)
                    .order_by(SolutionArchive.id.asc()))
    )

    all_solutions = {sol.id: sol.objectives for sol in solutions}
    current_solutions = {sol.id: sol.objectives for sol in solutions if sol.current}

    if not grequest.cached:
        if len(all_solutions) > 1:
            # Mark all the old solutions as not current
            old_current_solutions = await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.problem==problem_id, SolutionArchive.current==True)
                .values(current=False)
                .returning(SolutionArchive)
            )

            current_solutions = {sol.id: sol.objectives for sol in old_current_solutions if sol.current}

    return NIMBUSIterateResponse(
        previous_preference=requests[0].preference,
        new_solutions={sol.id: sol.objectives for sol in solutions if sol.new},
        current_solutions=current_solutions,
        all_solutions=all_solutions,
    )

@router.post("/intermediate")
async def intermediate(
    request: NIMBUSIntermediateSolutionRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSIntermediateResponse | FakeNIMBUSResponse:
    """Get solutions between two solutions using NIMBUS.

    Args:
        request (NIMBUSIntermediateSolutionRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSIntermediateResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """
    # Do database stuff here.
    problem_id = request.problem_id
    method_id = request.method_id

    problem = await db.first(select(ProblemInDB).filter_by(id=problem_id))
    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    previous_solutions = (
        await db.all(select(SolutionArchive)
        .filter_by(problem=problem_id)
        .order_by(SolutionArchive.id.asc()))
    )

    if not previous_solutions:
        raise HTTPException(status_code=404, detail="Problem not found in the database.")

    ideal = problem.get_ideal_point()
    nadir = problem.get_nadir_point()
    if None in ideal or None in nadir:
        raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

    solutions = await db.all(select(SolutionArchive).filter(SolutionArchive.id.in_([request.reference_solution_1_id, request.reference_solution_2_id])))

    # Do NIMBUS stuff here.
    results = solve_intermediate_solutions(
        problem=problem,
        solution_1=dict(zip([var.symbol for var in problem.variables], solutions[0].decision_variables[0:len(problem.variables)], strict=True)),
        solution_2=dict(zip([var.symbol for var in problem.variables], solutions[1].decision_variables[0:len(problem.variables)], strict=True)),
        num_desired=request.num_solutions,
    )

    # See if the results include duplicates and remove them
    duplicate_indices = set()
    for i in range(len(results) - 1):
        for j in range(i + 1, len(results)):
            if allclose(list(results[i].optimal_objectives.values()), list(results[j].optimal_objectives.values())):
                duplicate_indices.add(j)

    for index in sorted(list(duplicate_indices), reverse=True):
        results.pop(index)

    # Do database stuff again.
    # Save the given preferences
    pref = Preference(
        user=user.index,
        problem=problem_id,
        method=method_id,
        kind="NIMBUS_intermediate",
        value=request.model_dump(mode="json"),
    )
    await db.add(pref)

    # Mark all the old solutions as not current
    await db.update(
        update(SolutionArchive)
        .where(SolutionArchive.problem==problem_id, SolutionArchive.current==True)
        .values(current=False)
    )

    solutions = {i: sol for i, sol in enumerate(previous_solutions)}
    solutionsToUpdate = set()
    for res in results:
        # Check if the results already exist in the database
        solutionIndex = -1
        for i, prev in solutions.items():
            if allclose(list(res.optimal_objectives.values()), list(prev.objectives)):
                previous_solutions[i].current = True
                solutions.pop(i)
                solutionsToUpdate.add(previous_solutions[i].id)
                solutionIndex = i
                break

        # If the solution was not found in the database, add it
        if solutionIndex < 0 or not previous_solutions[solutionIndex].current:
            await db.add(
                SolutionArchive(
                    user=user.index,
                    problem=problem_id,
                    method=method_id,
                    decision_variables=list(res.optimal_variables.values()),
                    objectives=list(res.optimal_objectives.values()),
                    saved=False,
                    current=True,
                    chosen=False,
                )
            )

    await db.update(
        update(SolutionArchive)
        .where(SolutionArchive.id.in_(solutionsToUpdate))
        .values(current=True)
    )

    await db.commit()

    solutions = (
        await db.all(select(SolutionArchive)
            .filter_by(problem=problem_id)
            .order_by(SolutionArchive.id.asc()))
    )

    return NIMBUSIntermediateResponse(
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        all_solutions={sol.id: sol.objectives for sol in solutions},
    )

@router.post("/save")
async def save(
    request: SaveRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSSaveResponse | FakeNIMBUSResponse:
    """Save the solutions to the database.

    Args:
        grequest (GroupRequest): The request to choose.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        The response from the NIMBUS algorithm.
    """

    await db.update(
        update(SolutionArchive)
        .where(SolutionArchive.id.in_(request.solution_ids))
        .values(saved=True)
    )

    saved_solutions = (
        await db.all(select(SolutionArchive)
            .filter_by(problem=problem_id, saved=True)
            .order_by(SolutionArchive.id.asc()))
    )

    return NIMBUSSaveResponse(
        saved_solutions={sol.id: sol.objectives for sol in saved_solutions},
    )

@router.post("/choose")
async def choose(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSChosenResponse | FakeNIMBUSResponse:
    """Choose a solution as the final solution for NIMBUS.

    Args:
        grequest (GroupRequest): The request to choose.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSChooseResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [ChooseRequest.model_validate(requestRow.value) for requestRow in requestRows]

    problem_id = requests[0].problem_id

    if not grequest.cached:
        reference_solutions = await getMostSelectedSolutions(db, requests)
        selected_solution_ids = list(reference_solutions.keys())

        solutions = await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.id.in_(selected_solution_ids))
            .values(chosen=True)
            .returning(SolutionArchive)
        )
    else:
        solutions = (
            await db.all(select(SolutionArchive)
                .filter_by(problem=problem_id, chosen=True)
                .order_by(SolutionArchive.id.asc()))
        )

    return NIMBUSChosenResponse(
        chosen_solutions={sol.id: sol.objectives for sol in solutions},
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
    )