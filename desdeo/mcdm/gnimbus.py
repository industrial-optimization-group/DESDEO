"""Functions related to the GNIMBUS method.

References:
"""  # noqa: RUF002

import numpy as np

from desdeo.problem import (
    PolarsEvaluator,
    Problem,
    VariableType,
    Variable,
    objective_dict_to_numpy_array,
    unflatten_variable_array,
)

from desdeo.tools import (
    BaseSolver,
    SolverOptions,
    SolverResults,
    add_group_asf_diff,
    add_group_asf,
    add_group_asf_agg,
    add_group_asf_agg_diff,
    add_group_guess_diff,
    add_group_guess,
    add_group_guess_agg,
    add_group_guess_agg_diff,
    add_group_nimbus,
    add_group_nimbus_diff,
    add_group_stom,
    add_group_stom_agg,
    add_group_stom_agg_diff,
    add_group_stom_diff,
    guess_best_solver,
    add_asf_diff,
    add_asf_nondiff,
    add_nimbus_sf_diff,
    add_nimbus_sf_nondiff,
)
from desdeo.mcdm.nimbus import (
    # generate_starting_point,
    solve_intermediate_solutions,
    infer_classifications,
)
from desdeo.gdm.voting_rules import majority_rule, plurality_rule
from desdeo.gdm.gdmtools import dict_of_rps_to_list_of_rps, list_of_rps_to_dict_of_rps
import polars as pl

class GNIMBUSError(Exception):
    """Raised when an error with a NIMBUS method is encountered."""


def voting_procedure(problem: Problem, solutions, votes_idxs: dict[str, int]) -> SolverResults:
    """
    More general procedure for GNIMBUS for any number of DMs.
    TODO: docs and cleaning up.
    """
    winner_idx = None

    # call majority
    winner_idx = majority_rule(votes_idxs)
    if winner_idx is not None:
        print("Majority winner", winner_idx)
        return solutions[winner_idx]

    # call plurality
    winners = plurality_rule(votes_idxs)
    print("winners")
    """ general procedure does not apply plurality rule
    if len(winners) == 1:
        print("Plurality winner", winners[0])
        return solutions[winners[0]]  # need to unlist the winners list
    """
    if len(winners) == 2:
        # if two same solutions with same number of votes, call intermediate
        # TODO: not perfect check as I suppose it is possible to have a problem that we can calculate more solutions AND discrete representation also.
        if problem.discrete_representation is None:
            wsol1, wsol2 = solutions[winners[0]].optimal_variables, solutions[winners[1]].optimal_variables
        else:
            wsol1, wsol2 = solutions[winners[0]].optimal_objectives, solutions[winners[1]].optimal_objectives
        print("Finding intermediate solution between", wsol1, wsol2)
        # return solve_intermediate_solutions_only_objs(problem, wsol1, wsol2, num_desired=3)
        return solve_intermediate_solutions(problem, wsol1, wsol2, num_desired=1)[0]
    else:
        print("TIE-breaking, select a solution randomly (as random as computers ever are..)")
        n_of_sols = len(solutions)
        rng = np.random.default_rng()
        random_idx = rng.choice(range(n_of_sols))
        return solutions[random_idx]


# TODO: below is just doing the intermediate solutions with the objective vectors, was needed for GNIMBUS Malaga experiment
def solve_intermediate_solutions_only_objs(  # noqa: PLR0913
    problem: Problem,
    solution_1: dict[str, VariableType],
    solution_2: dict[str, VariableType],
    num_desired: int,
    scalarization_options: dict | None = None,
    solver: BaseSolver | None = None,
    solver_options: SolverOptions | None = None,
) -> list[SolverResults]:
    """Generates a desired number of intermediate solutions between two given solutions.

    Generates a desires number of intermediate solutions given two Pareto optimal solutions.
    The solutions are generated by taking n number of steps between the two solutions in the
    objective space. The objective vectors corresponding to these solutions are then
    utilized as reference points in the achievement scalarizing function. Solving the functions
    for each reference point will project the reference point on the Pareto optimal
    front of the problem. These projected solutions are then returned. Note that the
    intermediate solutions are generated _between_ the two given solutions, this means the
    returned solutions will not include the original points.

    Args:
        problem (Problem): the problem being solved.
        solution_1 (dict[str, VariableType]): the first of the solutions between which the intermediate
            solutions are to be generated.
        solution_2 (dict[str, VariableType]): the second of the solutions between which the intermediate
            solutions are to be generated.
        num_desired (int): the number of desired intermediate solutions to be generated. Must be at least `1`.
        scalarization_options (dict | None, optional): optional kwargs passed to the scalarization function.
            Defaults to None.
        solver (BaseSolver | None, optional): solver used to solve the problem.
            If not given, an appropriate solver will be automatically determined based on the features of `problem`.
            Defaults to None.
        solver_options (SolverOptions | None, optional): optional options passed
            to the `solver`. Ignored if `solver` is `None`.
            Defaults to None.

    Returns:
        list[SolverResults]: a list with the projected intermediate solutions as
            `SolverResults` objects.
    """

    if int(num_desired) < 1:
        msg = f"The given number of desired intermediate ({num_desired=}) solutions must be at least 1."
        raise GNIMBUSError(msg)

    init_solver = guess_best_solver(problem) if solver is None else solver
    _solver_options = None if solver_options is None or solver is None else solver_options

    # compute the element-wise difference between each solution (in the decision space)
    solution_1_arr = objective_dict_to_numpy_array(problem, solution_1)
    solution_2_arr = objective_dict_to_numpy_array(problem, solution_2)
    delta = solution_1_arr - solution_2_arr

    # the '2' is in the denominator because we want to calculate the steps
    # between the two given points; we are not interested in the given points themselves.
    step_size = delta / (2 + num_desired)

    intermediate_points = np.array([solution_2_arr + i * step_size for i in range(1, num_desired + 1)])

    intermediate_var_values = pl.DataFrame(
        [unflatten_variable_array(problem, x) for x in intermediate_points],
        schema=[
            (var.symbol, pl.Float64 if isinstance(var, Variable) else pl.Array(pl.Float64, tuple(var.shape)))
            for var in problem.variables
        ],
    )

    # evaluate the intermediate points to get reference points
    # TODO(gialmisi): an evaluator might have to be selected depending on the problem
    evaluator = PolarsEvaluator(problem)
    reference_points = (
        evaluator.evaluate(intermediate_var_values).select([obj.symbol for obj in problem.objectives]).to_dicts()
    )
    # for each reference point, add and solve the ASF scalarization problem
    # projecting the reference point onto the Pareto optimal front of the problem.
    # TODO(gialmisi): this can be done in parallel.
    intermediate_solutions = []
    for rp in reference_points:
        # add scalarization
        add_asf = add_asf_diff if problem.is_twice_differentiable else add_asf_nondiff
        asf_problem, target = add_asf(problem, "target", rp, **(scalarization_options or {}))

        solver = init_solver(asf_problem, _solver_options)

        # solve and store results
        result: SolverResults = solver.solve(target)

        intermediate_solutions.append(result)

    return intermediate_solutions


# TODO: move to tools, document
def agg_aspbounds(po_list: list[dict[str, float]], problem: Problem):
    agg_aspirations = {}
    agg_bounds = {}

    for obj in problem.objectives:
        if obj.maximize:
            agg_aspirations.update({obj.symbol: max(s[obj.symbol] for s in po_list)})
            agg_bounds.update({obj.symbol: min(s[obj.symbol] for s in po_list)})
        else:
            agg_aspirations.update({obj.symbol: min(s[obj.symbol] for s in po_list)})
            agg_bounds.update({obj.symbol: max(s[obj.symbol] for s in po_list)})

    return agg_aspirations, agg_bounds


# TODO: comments and move somewhere else
# TODO: convert to work both with min and maximization problems. Now seems to work with max objectives
def scale_delta(problem, d):
    delta = {}
    ideal = problem.get_ideal_point()
    nadir = problem.get_nadir_point()

    for obj in problem.objectives:
        if obj.maximize:
            delta.update({obj.symbol: d*(ideal[obj.symbol] - nadir[obj.symbol])})
        else:
            delta.update({obj.symbol: d*(nadir[obj.symbol] - ideal[obj.symbol])})
    return delta


def solve_group_sub_problems(  # noqa: PLR0913
    problem: Problem,
    current_objectives: dict[str, float],
    reference_points: dict[str, dict[str, float]],
    phase: str,
    scalarization_options: dict | None = None,
    create_solver: BaseSolver | None = None,
    solver_options: SolverOptions | None = None,
) -> list[SolverResults]:
    r"""Solves a number of sub-problems as defined in the GNIMBUS methods.

    TODO: update docs

    Solves 4 scalarized problems utilizing different scalarization
    functions. The scalarizations are based on the classification of a
    solutions provided by a decision maker. The classifications
    are represented by a reference point. Returns a number of new solutions
    corresponding to the number of scalarization functions solved.

    Solves the following scalarized problems corresponding
    the the following scalarization functions:

    1.  the NIMBUS scalarization function,
    2.  the STOM scalarization function,
    3.  the achievement scalarizing function, and
    4.  the GUESS scalarization function.

    Raises:
        GNIMBUSError: the given problem has an undefined ideal or nadir point, or both.
        GNIMBUSError: either the reference point of current objective functions value are
            missing entries for one or more of the objective functions defined in the problem.

    Args:
        problem (Problem): the problem being solved.
        current_objectives (dict[str, float]): an objective dictionary with the objective functions values
            the classifications have been given with respect to.
        reference_point (dict[str, float]): an objective dictionary with a reference point.
            The classifications utilized in the sub problems are derived from
            the reference point.
        scalarization_options (dict | None, optional): optional kwargs passed to the scalarization function.
            Defaults to None.
        create_solver (CreateSolverType | None, optional): a function that given a problem, will return a solver.
            If not given, an appropriate solver will be automatically determined based on the features of `problem`.
            Defaults to None.
        solver_options (SolverOptions | None, optional): optional options passed
            to the `create_solver` routine. Ignored if `create_solver` is `None`.
            Defaults to None.

    Returns:
        list[SolverResults]: a list of `SolverResults` objects. Contains as many elements
            as defined in `num_desired`.
    """
    if None in problem.get_ideal_point() or None in problem.get_nadir_point():
        msg = "The given problem must have both an ideal and nadir point defined."
        raise GNIMBUSError(msg)

    DMs = reference_points.keys()
    for dm in DMs:
        reference_point = reference_points[dm]
        # for rp in reference_point:
        if not all(obj.symbol in reference_point for obj in problem.objectives):
            print(reference_point)
            msg = f"The reference point {reference_point} is missing entries " "for one or more of the objective functions."
            raise GNIMBUSError(msg)
        # check that at least one objective function is allowed to be improved and one is allowed to worsen
        classifications = infer_classifications(problem, current_objectives, reference_point)
        if not any(classifications[obj.symbol][0] in ["<", "<="] for obj in problem.objectives) or not any(
            classifications[obj.symbol][0] in [">=", "0"] for obj in problem.objectives
        ):
            msg = (
                f"The given classifications {classifications} should allow at least one objective function value "
                "to improve and one to worsen."
            )
            raise GNIMBUSError(msg)

    if not all(obj.symbol in current_objectives for obj in problem.objectives):
        msg = f"The current point {current_objectives} is missing entries " "for one or more of the objective functions."
        raise GNIMBUSError(msg)

    init_solver = create_solver if create_solver is not None else guess_best_solver(problem)
    _solver_options = solver_options if solver_options is not None else None

    solutions = []
    classification_list = []
    achievable_prefs = []

    ind_sols = []
    reference_points_list = dict_of_rps_to_list_of_rps(reference_points)

    # Solve for individual solutions. TODO: move as own function, should be useful for other methods as well.
    for dm_rp in reference_points:
        classification = infer_classifications(problem, current_objectives, reference_points[dm_rp])
        nimbus_scala = add_nimbus_sf_diff if problem.is_twice_differentiable else add_nimbus_sf_nondiff  # non-diff gnimbus
        add_nimbus_sf = nimbus_scala

        problem_i_nimbus, nimbus_target = add_nimbus_sf(
            problem, "nimbus_sf", classification, current_objectives, **(scalarization_options or {})
        )

        if _solver_options:
            nimbus_solver = init_solver(problem_i_nimbus, _solver_options)
        else:
            nimbus_solver = init_solver(problem_i_nimbus)

        ind_sols.append(nimbus_solver.solve(nimbus_target))

    achievable_prefs = []
    for q in range(len(reference_points)):
        achievable_prefs.append(ind_sols[q].optimal_objectives)

    print(achievable_prefs)
    agg_aspirations, agg_bounds = agg_aspbounds(achievable_prefs, problem)
    delta = scale_delta(problem, d=1e-6)  # TODO: move somewhere else

    if phase == "decision":
        for dm_rp in reference_points:
            classification_list.append(infer_classifications(problem, current_objectives, reference_points[dm_rp]))
        gnimbus_scala = add_group_nimbus_diff if problem.is_twice_differentiable else add_group_nimbus
        add_nimbus_sf = gnimbus_scala

        problem_g_nimbus, gnimbus_target = add_nimbus_sf(
            problem, "nimbus_sf", classification_list, delta, agg_bounds, current_objectives, **(scalarization_options or {})
        )

        if _solver_options:
            gnimbus_solver = init_solver(problem_g_nimbus, _solver_options)  # type:ignore
        else:
            gnimbus_solver = init_solver(problem_g_nimbus)  # type:ignore

        solutions.append(gnimbus_solver.solve(gnimbus_target))

        return solutions

    elif phase == "learning":
        reference_points_list = dict_of_rps_to_list_of_rps(reference_points)

        # Add individual solutions
        for i in range(len(ind_sols)):
            solutions.append(ind_sols[i])
        """ Group nimbus scalarization with delta and added hard_constraints  """
        classification_list = []
        for dm_rp in reference_points:
            classification_list.append(infer_classifications(problem, current_objectives, reference_points[dm_rp]))
        print(classification_list)
        gnimbus_scala = add_group_nimbus_diff if problem.is_twice_differentiable else add_group_nimbus
        add_nimbus_sf = gnimbus_scala

        problem_w_nimbus, nimbus_target = add_nimbus_sf(
            problem, "nimbus_sf", classification_list, current_objectives, agg_bounds, delta, **(scalarization_options or {})
        )

        if _solver_options:
            nimbus_solver = init_solver(problem_w_nimbus, _solver_options)  # type:ignore
        else:
            nimbus_solver = init_solver(problem_w_nimbus)

        solutions.append(nimbus_solver.solve(nimbus_target))

        """ SOLVING Group Scals with scaled delta, original RPs and hard_constraints """
        # solve STOM
        add_stom_sf = add_group_stom_diff if problem.is_twice_differentiable else add_group_stom
        problem_w_stom, stom_target = add_stom_sf(
            problem, "stom_sf", reference_points_list, agg_bounds, delta, **(scalarization_options or {})
        )
        if _solver_options:
            stom_solver = init_solver(problem_w_stom, _solver_options)  # type:ignore
        else:
            stom_solver = init_solver(problem_w_stom)

        solutions.append(stom_solver.solve(stom_target))

        # solve ASF
        add_asf = add_group_asf_diff if problem.is_twice_differentiable else add_group_asf
        problem_w_asf, asf_target = add_asf(
            problem, "asf", reference_points_list, agg_bounds, delta, **(scalarization_options or {})
        )
        if _solver_options:
            asf_solver = init_solver(problem_w_asf, _solver_options)  # type:ignore
        else:
            asf_solver = init_solver(problem_w_asf)

        solutions.append(asf_solver.solve(asf_target))

        # Solve GUESS
        add_guess_sf = add_group_guess_diff if problem.is_twice_differentiable else add_group_guess
        problem_w_guess, guess_target = add_guess_sf(
            problem, "guess_sf", reference_points_list, agg_bounds, delta, **(scalarization_options or {})
        )
        if _solver_options:
            guess_solver = init_solver(problem_w_guess, _solver_options)  # type:ignore
        else:
            guess_solver = init_solver(problem_w_guess)

        solutions.append(guess_solver.solve(guess_target))

        return solutions

    else:  # phase is crp
        # Add individual solutions
        for i in range(len(ind_sols)):
            solutions.append(ind_sols[i])

        """ Group nimbus scalarization with delta and added hard_constraints  """
        classification_list = []
        for dm_rp in reference_points:
            print("RPS", reference_points[dm_rp])
            classification_list.append(infer_classifications(problem, current_objectives, reference_points[dm_rp]))
        print(classification_list)
        gnimbus_scala = add_group_nimbus_diff if problem.is_twice_differentiable else add_group_nimbus
        add_nimbus_sf = gnimbus_scala

        problem_w_nimbus, nimbus_target = add_nimbus_sf(
            problem, "nimbus_sf", classification_list, current_objectives, agg_bounds, delta, **(scalarization_options or {})
        )

        if _solver_options:
            nimbus_solver = init_solver(problem_w_nimbus, _solver_options)  # type:ignore
        else:
            nimbus_solver = init_solver(problem_w_nimbus)

        solutions.append(nimbus_solver.solve(nimbus_target))

        """ SOLVING Group Scals with scaled delta, agg. aspirations and hard_constraints """

        add_stom_sf2 = add_group_stom_agg_diff if problem.is_twice_differentiable else add_group_stom_agg

        problem_g_stom, stomg_target = add_stom_sf2(
            problem, "stom_sf2", agg_aspirations, agg_bounds, delta, **(scalarization_options or {})
        )
        if _solver_options:
            stomg_solver = init_solver(problem_g_stom, _solver_options)  # type:ignore
        else:
            stomg_solver = init_solver(problem_g_stom)

        solutions.append(stomg_solver.solve(stomg_target))

        add_asf2 = add_group_asf_agg_diff if problem.is_twice_differentiable else add_group_asf_agg
        problem_g_asf, asfg_target = add_asf2(
            problem, "asf2", agg_aspirations, agg_bounds, delta, **(scalarization_options or {})
        )
        if _solver_options:
            asfg_solver = init_solver(problem_g_asf, _solver_options)  # type:ignore
        else:
            asfg_solver = init_solver(problem_g_asf)

        solutions.append(asfg_solver.solve(asfg_target))

        add_guess_sf2 = add_group_asf_agg_diff if problem.is_twice_differentiable else add_group_guess_agg

        problem_g_guess, guess2_target = add_guess_sf2(
            problem, "guess_sf2", agg_aspirations, agg_bounds, delta, **(scalarization_options or {})
        )

        if _solver_options:
            guess2_solver = init_solver(problem_g_guess, _solver_options)  # type:ignore
        else:
            guess2_solver = init_solver(problem_g_guess)

        solutions.append(guess2_solver.solve(guess2_target))

        return solutions
