/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/user_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current User Info
         * @description Return information about the current user.
         *
         *     Args:
         *         user (Annotated[User, Depends): user dependency, handled by `get_current_user`.
         *
         *     Returns:
         *         UserPublic: public information about the current user.
         */
        get: operations["get_current_user_info_user_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login
         * @description Login to get an authentication token.
         *
         *     Return an access token in the response and a cookie storing a refresh token.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
         *             The form data to authenticate the user.
         *         session (Annotated[Session, Depends(get_db)]): The database session.
         *         cookie_max_age (int): the lifetime of the cookie storing the refresh token.
         */
        post: operations["login_login_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description Log the current user out. Deletes the refresh token that was set by logging in.
         *
         *     Args:
         *         None
         *
         *     Returns:
         *         JSONResponse: A response in which the cookies are deleted
         */
        post: operations["logout_logout_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Access Token
         * @description Refresh the access token using the refresh token stored in the cookie.
         *
         *     Args:
         *         request (Request): The request containing the cookie.
         *         session (Annotated[Session, Depends(get_db)]): the database session.
         *         refresh_token (Annotated[Str | None, Cookie()]): the refresh
         *             token, which is fetched from a cookie included in the response.
         *
         *     Returns:
         *         dict: A dictionary containing the new access token.
         */
        post: operations["refresh_access_token_refresh_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_dm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Dm
         * @description Add a new user of the role Decision Maker to the database. Requires no login.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_dm_add_new_dm_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_analyst": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Analyst
         * @description Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin.
         *
         *     Args:
         *         user: Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
         *         form_data: (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session: (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if the logged in user is not an analyst or an admin or if
         *         username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_analyst_add_new_analyst_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems
         * @description Get information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfoSmall]: a list of information on all the problems.
         */
        get: operations["get_problems_problem_all_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems Info
         * @description Get detailed information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfo]: a list of the detailed information on all the problems.
         */
        get: operations["get_problems_info_problem_all_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Problem
         * @description Get the model of a specific problem.
         *
         *     Args:
         *         request (ProblemGetRequest): the request containing the problem's id `problem_id`.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find a problem with the given id.
         *
         *     Returns:
         *         ProblemInfo: detailed information on the requested problem.
         */
        post: operations["get_problem_problem_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/add": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Problem
         * @description Add a newly defined problem to the database.
         *
         *     Args:
         *         request (Problem): the JSON representation of the problem.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Note:
         *         Users with the role 'guest' may not add new problems.
         *
         *     Raises:
         *         HTTPException: when any issue with defining the problem arises.
         *
         *     Returns:
         *         ProblemInfo: the information about the problem added.
         */
        post: operations["add_problem_problem_add_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/get_metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Metadata
         * @description Fetch specific metadata for a specific problem.
         *
         *     Fetch specific metadata for a specific problem. See all the possible
         *     metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata
         *     section.
         *
         *     Args:
         *         request (MetaDataGetRequest): the requested metadata type.
         *         user (Annotated[User, Depends]): the current user.
         *         session (Annotated[Session, Depends]): the database session.
         *
         *     Returns:
         *         list[ForestProblemMetadata | RepresentativeNonDominatedSolutions]: list containing all the metadata
         *             defined for the problem with the requested metadata type. If no match is found,
         *             returns an empty list.
         */
        post: operations["get_metadata_problem_get_metadata_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/assign_solver": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Select Solver
         * @description Assign a specific solver for a problem.
         *
         *     request: ProblemSelectSolverRequest: The request containing problem id and string representation of the solver
         *     user: Annotated[User, Depends(get_current_user): The user that is logged in.
         *     session: Annotated[Session, Depends(get_session)]: The database session.
         *
         *     Raises:
         *         HTTPException: Unknown solver, unauthorized user
         *
         *     Returns:
         *         JSONResponse: A simple confirmation.
         */
        post: operations["select_solver_problem_assign_solver_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/new": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create New Session
         * @description .
         */
        post: operations["create_new_session_session_new_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Session
         * @description Return an interactive session with a given id for the current user.
         *
         *     Args:
         *         request (GetSessionRequest): a request containing the id of the session.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find an interactive session with the given id
         *             for the current user.
         *
         *     Returns:
         *         InteractiveSessionInfo: info on the requested interactive session.
         */
        post: operations["get_session_session_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/rpm/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description Runs an iteration of the reference point method.
         *
         *     Args:
         *         request (RPMSolveRequest): a request with the needed information to run the method.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the current database session.
         *
         *     Returns:
         *         RPMState: a state with information on the results of iterating the reference point method
         *             once.
         */
        post: operations["solve_solutions_method_rpm_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description Solve the problem using the NIMBUS method.
         */
        post: operations["solve_solutions_method_nimbus_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initialize
         * @description Initialize the problem for the NIMBUS method.
         */
        post: operations["initialize_method_nimbus_initialize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Save
         * @description Save solutions.
         */
        post: operations["save_method_nimbus_save_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/intermediate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Nimbus Intermediate
         * @description Solve intermediate solutions by forwarding the request to generic intermediate endpoint with context nimbus.
         */
        post: operations["solve_nimbus_intermediate_method_nimbus_intermediate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/get-or-initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Or Initialize
         * @description Get the latest NIMBUS state if it exists, or initialize a new one if it doesn't.
         */
        post: operations["get_or_initialize_method_nimbus_get_or_initialize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/finalize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Finalize Nimbus
         * @description An endpoint for finishing up the nimbus process.
         *
         *     Args:
         *         request (NIMBUSFinalizeRequest): The request containing the final solution, etc.
         *         user (Annotated[User, Depends): The current user.
         *         session (Annotated[Session, Depends): The database session.
         *
         *     Raises:
         *         HTTPException
         *
         *     Returns:
         *         NIMBUSFinalizeResponse: Response containing state id of the final solution.
         */
        post: operations["finalize_nimbus_method_nimbus_finalize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/delete_save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete Save
         * @description Endpoint for deleting saved solutions.
         *
         *     Args:
         *         request (NIMBUSDeleteSaveRequest): request containing necessary information for deleting a save
         *         user (Annotated[User, Depends): the current  (logged in) user
         *         session (Annotated[Session, Depends): database session
         *
         *     Raises:
         *         HTTPException
         *
         *     Returns:
         *         NIMBUSDeleteSaveResponse: Response acknowledging the deletion of save and other useful info.
         */
        post: operations["delete_save_method_nimbus_delete_save_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/generic/intermediate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Intermediate
         * @description Solve intermediate solutions between given two solutions.
         */
        post: operations["solve_intermediate_method_generic_intermediate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/generic/score-bands-obj-data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Calculate Score Bands From Objective Data
         * @description Calculate SCORE bands parameters from objective data.
         */
        post: operations["calculate_score_bands_from_objective_data_method_generic_score_bands_obj_data_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utopia/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Utopia Data
         * @description Request and receive the Utopia map corresponding to the decision variables sent.
         *
         *     Args:
         *         request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested
         *         for.
         *         user (Annotated[User, Depend(get_current_user)]) the current user
         *         session (Annotated[Session, Depends(get_session)]) the current database session
         *     Raises:
         *         HTTPException:
         *     Returns:
         *         UtopiaResponse: the map for the forest, to be rendered in frontend
         */
        post: operations["get_utopia_data_utopia__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm/create_group": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Group
         * @description Create group.
         *
         *     Args:
         *         request (GroupCreateRequest): a request that holds information to be used in creation of the group.
         *         user (Annotated[User, Depends(get_current_user)]): the current user.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: Acknowledgement that the group was created
         *
         *     Raises:
         *         HTTPException
         */
        post: operations["create_group_gdm_create_group_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm/delete_group": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete Group
         * @description Delete the group with given ID.
         *
         *     Args:
         *         request (GroupInfoRequest): Contains the ID of the group to be deleted
         *         user (Annotated[User, Depends(get_current_user)]): The user (in this case must be owner for anything to happen)
         *         session (Annotated[Session, Depends(get_session)]): The database session
         *
         *     Returns:
         *         JSONResponse: Acknowledgement of the deletion
         *
         *     Raises:
         *         HTTPException: Insufficient authorization etc.
         */
        post: operations["delete_group_gdm_delete_group_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm/add_to_group": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add To Group
         * @description Add a user to a group.
         *
         *     Args:
         *         request (GroupModifyRequest): Request object that has group and user IDs.
         *         user (Annotated[User, Depends(get_current_user)]): the current user.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: Aknowledge that user has been added to the group
         *
         *     Raises:
         *         HTTPException: Authorization issues, group or user not found.
         */
        post: operations["add_to_group_gdm_add_to_group_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm/remove_from_group": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remove From Group
         * @description Remove user from group.
         *
         *     Args:
         *         request (GroupModifyRequest): Request object that has group and user IDs.
         *         user (Annotated[User, Depends(get_current_user)]): the current user.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: Aknowledge that user has been removed from the group.
         *
         *     Raises:
         *         HTTPException: Authorization issues, group or user not found.
         */
        post: operations["remove_from_group_gdm_remove_from_group_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm/get_group_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Group Info
         * @description Get information about the group.
         *
         *     Args:
         *         request (GroupInfoRequest): the id of the group for which we desire info on
         *         session (Annotated[Session, Depends(get_session)]): the database session
         *
         *     Returns:
         *         GroupPublic: public info of the group
         *
         *     Raises:
         *         HTTPException: If there's no group with the requests group id
         */
        post: operations["get_group_info_gdm_get_group_info_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gnimbus/initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gnimbus Initialize
         * @description Initialize the problem for GNIMBUS.
         */
        post: operations["gnimbus_initialize_gnimbus_initialize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gnimbus/get_latest_results": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Latest Results
         * @description Get the latest results from group iteration.
         *
         *     (OBSOLETE AND OUT OF DATE!)
         *
         *     Args:
         *         request (GroupInfoRequest): essentially just the ID of the group
         *         user (Annotated[User, Depends(get_current_user)]): Current user
         *         session (Annotated[Session, Depends(get_session)]): Database session.
         *
         *     Returns:
         *         GNIMBUSResultResponse: A GNIMBUSResultResponse response containing the latest gnimbus results
         *
         *     Raises:
         *         HTTPException: Validation errors or no results
         */
        post: operations["get_latest_results_gnimbus_get_latest_results_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gnimbus/all_iterations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Full Iteration
         * @description Get all results from all iterations of the group.
         *
         *     Args:
         *         request (GroupInfoRequest): essentially just the ID of the group
         *         user (Annotated[User, Depends(get_current_user)]): current user
         *         session (Annotated[Session, Depends(get_session)]): current session
         *
         *     Returns:
         *         GNIMBUSAllIterationsResponse: A GNIMBUSAllIterationsResponse response
         *         containing all the results of the iterations. If last iteration was optimization,
         *         the first iteration is incomplete (i.e. the voting preferences and voting results are missing)
         *
         *     Raises:
         *         HTTPException: Validation errors or no results or no states and such.
         */
        post: operations["full_iteration_gnimbus_all_iterations_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gnimbus/toggle_phase": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Switch Phase
         * @description Switch the phase from one to another. "learning", "crp", "decision" and "compromise" phases are allowed.
         */
        post: operations["switch_phase_gnimbus_toggle_phase_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gnimbus/get_phase": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Phase
         * @description Get the current phase of the group.
         */
        post: operations["get_phase_gnimbus_get_phase_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gnimbus/revert_iteration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Revert Iteration
         * @description Changes the starting solution of an iteration so in case of emergency the group owner can just change it.
         *
         *     Args:
         *         request (GNIMBUSChangeStartingSolutionRequest): The request containing necessary details to fulfill the change.
         *         user (Annotated[User, Depends): The current user.
         *         session (Annotated[Session, Depends): The database session.
         *
         *     Raises:
         *         HTTPException
         *
         *     Returns:
         *         JSONResponse: Response that acknowledges the changes.
         */
        post: operations["revert_iteration_gnimbus_revert_iteration_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/enautilus/step": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Step
         * @description .
         */
        post: operations["step_method_enautilus_step_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm-score-bands/vote": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Vote For A Band
         * @description Vote for a band using this endpoint.
         *
         *     Args:
         *         request (GDMScoreBandsVoteRequest): A container for the group id and the vote.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): database session
         *
         *     Raises:
         *         HTTPException: If something goes wrong. It hopefully let's you know what went wrong.
         *
         *     Returns:
         *         JSONResponse: A quick confirmation that vote went through.
         */
        post: operations["vote_for_a_band_gdm_score_bands_vote_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm-score-bands/confirm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Confirm Vote
         * @description Confim the vote. If all confirm, the clustering and new iteration begins.
         *
         *     Args:
         *         request (GroupInfoRequest): Simple request to get the group ID.
         *         user (Annotated[User, Depends): The current user.
         *         session (Annotated[Session, Depends): Database session.
         *
         *     Raises:
         *         HTTPException: If something goes awry. It should let you know what went wrong, though.
         *
         *     Returns:
         *         JSONResponse: A simple confirmation that everything went ok and that vote went in.
         */
        post: operations["confirm_vote_gdm_score_bands_confirm_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm-score-bands/get-or-initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Or Initialize
         * @description An endpoint for two things: Initializing the GDM Score Bands things and Fetching results.
         *
         *     If a group hasn't been initialized, initialize and then return initial clustering information.
         *     If it has been initialized, just fetch the latest iteration's information (clustering, etc.)
         *
         *     Args:
         *         request (GDMScoreBandsInitializationRequest): Request that contains necessary information for initialization.
         *         user (Annotated[User, Depends): The current user.
         *         session (Annotated[Session, Depends): Database session.
         *
         *     Raises:
         *         HTTPException: It'll let you know.
         *
         *     Returns:
         *         GDMSCOREBandsResponse: A response containing Group id, group iter id and ScoreBandsResponse.
         */
        post: operations["get_or_initialize_gdm_score_bands_get_or_initialize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm-score-bands/get-votes-and-confirms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Votes And Confirms
         * @description Returns the current status of votes and confirmations in current iteration.
         *
         *     Args:
         *         request (GroupInfoRequest): The group we'd like the info on.
         *         user (Annotated[User, Depends): The user that requests the data.
         *         session (Annotated[Session, Depends): The database session.
         *
         *     Raises:
         *         HTTPException: If group doesn't exists etc errors.
         *
         *     Returns:
         *         JSONResponse: A response containing the votes and confirmations.
         */
        post: operations["get_votes_and_confirms_gdm_score_bands_get_votes_and_confirms_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm-score-bands/revert": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Revert
         * @description Revert to a previous iteration. Usable only by the analyst.
         *
         *     This implies that we're gonna need to see ALL previous iterations I'd say.
         *
         *     Args:
         *         request (GDMSCOREBandsRevertRequest): The request containing group id and iteration number.
         *         user (Annotated[User, Depends): The current user.
         *         session (Annotated[Session, Depends): The database session.
         *
         *     Returns:
         *         JSONResponse: Acknowledgement of the revert.
         */
        post: operations["revert_gdm_score_bands_revert_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gdm-score-bands/configure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Configure Gdm
         * @description Configure the SCORE Bands settings.
         *
         *     Args:
         *         config (SCOREBandsGDMConfig): The configuration object
         *         group_id (int): group id
         *         user (Annotated[User, Depends): The user doing the request
         *         session (Annotated[Session, Depends): The database session.
         *
         *     Returns:
         *         JSONResponse: Acknowledgement that yeah ok reconfigured.
         */
        post: operations["configure_gdm_gdm_score_bands_configure_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Body_add_new_analyst_add_new_analyst_post */
        Body_add_new_analyst_add_new_analyst_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /** Body_add_new_dm_add_new_dm_post */
        Body_add_new_dm_add_new_dm_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /** Body_login_login_post */
        Body_login_login_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /**
         * ConstantDB
         * @description The SQLModel equivalent to `Constant`.
         */
        ConstantDB: {
            /**
             * Name
             * @description Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'.
             */
            symbol: string;
            /**
             * Value
             * @description The value of the constant.
             */
            value: number;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintDB
         * @description The SQLModel equivalent to `Constraint`.
         */
        ConstraintDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'.
             */
            symbol: string;
            /** @description The type of the constraint. Constraints are assumed to be in a standard form where the supplied 'func' expression is on the left hand side of the constraint's expression, and on the right hand side a zero value is assume. The comparison between the left hand side and right hand side is either and quality comparison ('=') or lesser than equal comparison ('<='). */
            cons_type: components["schemas"]["ConstraintTypeEnum"];
            /**
             * Is Linear
             * @description Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.
             * @default true
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintTypeEnum
         * @description An enumerator for supported constraint expression types.
         * @enum {string}
         */
        ConstraintTypeEnum: "=" | "<=";
        /**
         * CreateSessionRequest
         * @description Model of the request to create a new session.
         */
        CreateSessionRequest: {
            /** Info */
            info?: string | null;
        };
        /**
         * CustomClusterOptions
         * @description Options for custom clustering provided by the user.
         */
        CustomClusterOptions: {
            /**
             * Name
             * @description Custom user-provided clusters.
             * @default Custom
             */
            name: string;
            /**
             * Clusters
             * @description List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.
             */
            clusters: number[];
        };
        /**
         * DBSCANOptions
         * @description Options for DBSCAN clustering algorithm.
         */
        DBSCANOptions: {
            /**
             * Name
             * @description DBSCAN clustering algorithm.
             * @default DBSCAN
             */
            name: string;
        };
        /**
         * DimensionClusterOptions
         * @description Options for clustering by one of the objectives/decision variables.
         */
        DimensionClusterOptions: {
            /**
             * Name
             * @description Clustering by one of the dimensions.
             * @default DimensionCluster
             */
            name: string;
            /**
             * Dimension Name
             * @description Dimension to use for clustering.
             */
            dimension_name: string;
            /**
             * N Clusters
             * @description Number of clusters to use. Defaults to 5.
             * @default 5
             */
            n_clusters: number;
            /**
             * Kind
             * @description Kind of clustering to use. Either "EqualWidth", which divides the dimension range into equal width intervals,
             *     or "EqualFrequency", which divides the dimension values into intervals with equal number of solutions.
             *     Defaults to "EqualWidth".
             * @default EqualWidth
             * @enum {string}
             */
            kind: "EqualWidth" | "EqualFrequency";
        };
        /**
         * DiscreteRepresentationDB
         * @description The SQLModel equivalent to `DiscreteRepresentation`.
         */
        DiscreteRepresentationDB: {
            /**
             * Non Dominated
             * @default false
             */
            non_dominated: boolean;
            /** Variable Values */
            variable_values: {
                [key: string]: (number | boolean)[];
            };
            /** Objective Values */
            objective_values: {
                [key: string]: number[];
            };
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * DistanceFormula
         * @description Distance formulas supported by SCORE bands. See the paper for details.
         * @enum {integer}
         */
        DistanceFormula: 1 | 2;
        /**
         * ENautilusResult
         * @description The result of an iteration of the E-NAUTILUS method.
         */
        ENautilusResult: {
            /**
             * Current Iteration
             * @description Number of the current iteration.
             */
            current_iteration: number;
            /**
             * Iterations Left
             * @description Number of iterations left.
             */
            iterations_left: number;
            /**
             * Intermediate Points
             * @description New intermediate points
             */
            intermediate_points: {
                [key: string]: number;
            }[];
            /**
             * Reachable Best Bounds
             * @description Best bounds of the objective function values reachable from each intermediate point.
             */
            reachable_best_bounds: {
                [key: string]: number;
            }[];
            /**
             * Reachable Worst Bounds
             * @description Worst bounds of the objective function values reachable from each intermediate point.
             */
            reachable_worst_bounds: {
                [key: string]: number;
            }[];
            /**
             * Closeness Measures
             * @description Closeness measures of each intermediate point.
             */
            closeness_measures: number[];
            /**
             * Reachable Point Indices
             * @description Indices of the reachable points from each intermediate point.
             */
            reachable_point_indices: number[][];
        };
        /**
         * ENautilusState
         * @description E-NAUTILUS: one stepping iteration.
         */
        ENautilusState: {
            /** Id */
            id?: number | null;
            /** Non Dominated Solutions Id */
            non_dominated_solutions_id?: number | null;
            /** Current Iteration */
            current_iteration: number;
            /** Iterations Left */
            iterations_left: number;
            /** Selected Point */
            selected_point?: {
                [key: string]: number;
            } | null;
            /** Reachable Point Indices */
            reachable_point_indices?: number[];
            /** Number Of Intermediate Points */
            number_of_intermediate_points: number;
            enautilus_results: components["schemas"]["ENautilusResult"];
        };
        /**
         * EnautilusStepRequest
         * @description Model of the request to the E-NAUTILUS method.
         */
        EnautilusStepRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Representative Solutions Id */
            representative_solutions_id?: number | null;
            /**
             * Current Iteration
             * @description The number of the current iteration.
             */
            current_iteration: number;
            /**
             * Iterations Left
             * @description The number of iterations left.
             */
            iterations_left: number;
            /**
             * Selected Point
             * @description The selected intermediate point. If first iteration, set this to be the (approximated) nadir point.
             */
            selected_point: {
                [key: string]: number;
            };
            /**
             * Reachable Point Indices
             * @description The indices indicating the point on the non-dominated set that are reachable from the currently selected point.
             */
            reachable_point_indices: number[];
            /**
             * Number Of Intermediate Points
             * @description The number of intermediate points to be generated.
             */
            number_of_intermediate_points: number;
        };
        /**
         * EndProcessPreference
         * @description A structure for storing info on whether everyone is happy to end the gnimbus process.
         */
        EndProcessPreference: {
            /**
             * Method
             * @default end
             */
            method: string;
            /** Success */
            success: boolean | null;
            /** Set Preferences */
            set_preferences: {
                [key: string]: boolean;
            };
        };
        /**
         * ExtraFunctionDB
         * @description The SQLModel equivalent to `ExtraFunction`.
         */
        ExtraFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the function. Example: 'normalization'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'.
             */
            symbol: string;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ForestProblemMetaData
         * @description A problem metadata class to hold UTOPIA forest problem specific information.
         */
        ForestProblemMetaData: {
            /** Id */
            id?: number | null;
            /** Metadata Id */
            metadata_id?: number | null;
            /**
             * Metadata Type
             * @default forest_problem_metadata
             */
            metadata_type: string;
            /** Map Json */
            map_json: string;
            /** Schedule Dict */
            schedule_dict: {
                [key: string]: unknown;
            };
            /** Years */
            years: string[];
            /** Stand Id Field */
            stand_id_field: string;
            /** Stand Descriptor */
            stand_descriptor?: {
                [key: string]: unknown;
            } | null;
            /** Compensation */
            compensation?: number | null;
        };
        /**
         * FullIteration
         * @description A full iteration item containing results from a complete or incomplete iteration.
         *
         *     This is a format to send information to the user interface.
         */
        FullIteration: {
            /**
             * Phase
             * @description The phase of the iteration.
             */
            phase: string;
            /** @description The preferences related to the optimization stage of the full iteration. */
            optimization_preferences: components["schemas"]["OptimizationPreference"] | null;
            /**
             * Voting Preferences
             * @description The preferences related to the voting phase of the iteration.             either actual votes or a vote to see whether to just continue.
             */
            voting_preferences: components["schemas"]["VotingPreference"] | components["schemas"]["EndProcessPreference"] | null;
            /** @description The starting result of the optimization process. Fetched from the previous             iteration's final result. */
            starting_result: components["schemas"]["SolutionReferenceLite"] | null;
            /**
             * Common Results
             * @description The common results (1 to 4) generated by gnimbus.
             */
            common_results: components["schemas"]["SolutionReferenceLite"][];
            /**
             * User Results
             * @description The user specific results generated by gnimbus in phases learning and crp.
             */
            user_results: components["schemas"]["SolutionReferenceLite"][];
            /**
             * Personal Result Index
             * @description The user result index of requester.
             */
            personal_result_index: number | null;
            /** @description The final result after voting. */
            final_result: components["schemas"]["SolutionReferenceLite"] | null;
        };
        /**
         * GDMSCOREBandFinalSelection
         * @description Class for containing the final 10 or less solutions, the final solution and the votes that led to it.
         */
        GDMSCOREBandFinalSelection: {
            /**
             * Method
             * @default gdm-score-bands-final
             */
            method: string;
            /**
             * User Votes
             * @description Dictionary of votes.
             */
            user_votes: {
                [key: string]: number;
            };
            /**
             * User Confirms
             * @description List of users who want to move on.
             */
            user_confirms: number[];
            /** Solution Variables */
            solution_variables: {
                [key: string]: (number | boolean)[];
            };
            /** Solution Objectives */
            solution_objectives: {
                [key: string]: number[];
            };
            /** Winner Solution Variables */
            winner_solution_variables: {
                [key: string]: number | boolean;
            };
            /** Winner Solution Objectives */
            winner_solution_objectives: {
                [key: string]: number;
            };
        };
        /**
         * GDMSCOREBandsDecisionResponse
         * @description Response class for gdm score bands that includes the last 10 or less solutions.
         */
        GDMSCOREBandsDecisionResponse: {
            /**
             * Method
             * @default gdm-score-bands-final
             */
            method: string;
            /**
             * Group Id
             * @description The group in question.
             */
            group_id: number;
            /**
             * Group Iter Id
             * @description ID of the latest group iteration.
             */
            group_iter_id: number;
            /** @description The container for the solutions and the winner solution. */
            result: components["schemas"]["GDMSCOREBandFinalSelection"];
        };
        /**
         * GDMSCOREBandsHistoryResponse
         * @description Response class for all history. Allows for going to a previous iteration.
         */
        GDMSCOREBandsHistoryResponse: {
            /** History */
            history: (components["schemas"]["GDMSCOREBandsResponse"] | components["schemas"]["GDMSCOREBandsDecisionResponse"])[];
        };
        /**
         * GDMSCOREBandsResponse
         * @description Response class for GDMSCOREBands, whether it is initialization or not.
         */
        GDMSCOREBandsResponse: {
            /**
             * Method
             * @default gdm-score-bands
             */
            method: string;
            /**
             * Group Id
             * @description The group in question.
             */
            group_id: number;
            /**
             * Group Iter Id
             * @description ID of the latest group iteration.
             */
            group_iter_id: number;
            /**
             * Latest Iteration
             * @description The latest GDM iteration number. Different from Group Iteration id.
             */
            latest_iteration: number;
            /** @description The results of the score bands procedure. */
            result: components["schemas"]["SCOREBandsResult"];
        };
        /**
         * GDMSCOREBandsRevertRequest
         * @description Request for reverting to a previous setup.
         */
        GDMSCOREBandsRevertRequest: {
            /**
             * Group Id
             * @description Group ID.
             */
            group_id: number;
            /**
             * Iteration Number
             * @description The number of the iteration that we want to revert to.
             */
            iteration_number: number;
        };
        /**
         * GDMScoreBandsInitializationRequest
         * @description Request class for initialization of score bands.
         */
        GDMScoreBandsInitializationRequest: {
            /**
             * Group Id
             * @description The group to be initialized.
             */
            group_id: number;
            /** @description The configuration for the initial score banding. */
            score_bands_config: components["schemas"]["SCOREBandsGDMConfig"];
        };
        /**
         * GDMScoreBandsVoteRequest
         * @description Request for voting for a band.
         */
        GDMScoreBandsVoteRequest: {
            /**
             * Group Id
             * @description ID of the group in question
             */
            group_id: number;
            /**
             * Vote
             * @description The vote. Vaalisalaisuus.
             */
            vote: number;
        };
        /**
         * GMMOptions
         * @description Options for Gaussian Mixture Model clustering algorithm.
         */
        GMMOptions: {
            /**
             * Name
             * @description Gaussian Mixture Model clustering algorithm.
             * @default GMM
             */
            name: string;
            /**
             * Scoring Method
             * @description Scoring method to use for GMM. Either "BIC" or "silhouette". Defaults to "silhouette".
             *     This option determines how the number of clusters is chosen.
             * @default silhouette
             * @enum {string}
             */
            scoring_method: "BIC" | "silhouette";
        };
        /**
         * GNIMBUSAllIterationsResponse
         * @description The response model for getting all found solutions among others.
         */
        GNIMBUSAllIterationsResponse: {
            /** All Full Iterations */
            all_full_iterations: components["schemas"]["FullIteration"][];
        };
        /**
         * GNIMBUSResultResponse
         * @description The response for getting GNIMBUS results. NOTE: OBSOLETE!
         */
        GNIMBUSResultResponse: {
            /** Method */
            method: string;
            /** Phase */
            phase: string;
            /** Preferences */
            preferences: components["schemas"]["VotingPreference"] | components["schemas"]["OptimizationPreference"];
            /** Common Results */
            common_results: components["schemas"]["SolutionReference"][];
            /** User Results */
            user_results: components["schemas"]["SolutionReference"][];
            /** Personal Result Index */
            personal_result_index: number | null;
        };
        /**
         * GNIMBUSSwitchPhaseRequest
         * @description A request for a certain phase. Comes from the group owner/analyst.
         */
        GNIMBUSSwitchPhaseRequest: {
            /** Group Id */
            group_id: number;
            /** New Phase */
            new_phase: string;
        };
        /**
         * GNIMBUSSwitchPhaseResponse
         * @description A response for the above request.
         */
        GNIMBUSSwitchPhaseResponse: {
            /** Old Phase */
            old_phase: string;
            /** New Phase */
            new_phase: string;
        };
        /**
         * GenericIntermediateSolutionResponse
         * @description The response from computing intermediate values.
         */
        GenericIntermediateSolutionResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /** @description The first solution used when computing intermediate solutions. */
            reference_solution_1: components["schemas"]["SolutionReferenceResponse"];
            /** @description The second solution used when computing intermediate solutions. */
            reference_solution_2: components["schemas"]["SolutionReferenceResponse"];
            /**
             * Intermediate Solutions
             * @description The intermediate solutions computed.
             */
            intermediate_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * GetSessionRequest
         * @description Model of the request to get a specific session.
         */
        GetSessionRequest: {
            /** Session Id */
            session_id: number;
        };
        /**
         * GroupCreateRequest
         * @description Used for requesting a group to be created.
         */
        GroupCreateRequest: {
            /** Group Name */
            group_name: string;
            /** Problem Id */
            problem_id: number;
        };
        /**
         * GroupInfoRequest
         * @description Class for requesting group information.
         */
        GroupInfoRequest: {
            /** Group Id */
            group_id: number;
        };
        /**
         * GroupModifyRequest
         * @description Used for adding a user into group and removing a user from group.
         */
        GroupModifyRequest: {
            /** Group Id */
            group_id: number;
            /** User Id */
            user_id: number;
        };
        /**
         * GroupPublic
         * @description Response model for Group.
         */
        GroupPublic: {
            /** Id */
            id: number;
            /** Name */
            name: string;
            /** Owner Id */
            owner_id: number;
            /** User Ids */
            user_ids: number[];
            /** Problem Id */
            problem_id: number;
        };
        /**
         * GroupRevertRequest
         * @description Class for requesting reverting to certain iteration.
         */
        GroupRevertRequest: {
            /**
             * Group Id
             * @description The ID of the group we wish to revert.
             */
            group_id: number;
            /**
             * State Id
             * @description The state's ID to which we want to revert to. Corresponds to state_id in GroupIteration.
             */
            state_id: number;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * InteractiveSessionBase
         * @description The base model for representing interactive sessions.
         */
        InteractiveSessionBase: {
            /** Id */
            id: number | null;
            /** User Id */
            user_id: number | null;
            /** Info */
            info: string | null;
        };
        /**
         * IntermediateSolutionRequest
         * @description Model of the request to solve intermediate solutions between two solutions.
         */
        IntermediateSolutionRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Context */
            context?: string | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            reference_solution_1: components["schemas"]["SolutionInfo"];
            reference_solution_2: components["schemas"]["SolutionInfo"];
        };
        /**
         * KMeansOptions
         * @description Options for KMeans clustering algorithm.
         */
        KMeansOptions: {
            /**
             * Name
             * @description KMeans clustering algorithm.
             * @default KMeans
             */
            name: string;
            /**
             * N Clusters
             * @description Number of clusters to use. Defaults to 5.
             * @default 5
             */
            n_clusters: number;
        };
        /**
         * NIMBUSClassificationRequest
         * @description Model of the request to the nimbus method.
         */
        NIMBUSClassificationRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
            /**
             * Current Objectives
             * @description The objectives used for iteration.
             */
            current_objectives: {
                [key: string]: number;
            };
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
        };
        /**
         * NIMBUSClassificationResponse
         * @description The response from NIMBUS classification endpoint.
         */
        NIMBUSClassificationResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /** @description The previous preference used. */
            previous_preference: components["schemas"]["ReferencePoint"];
            /**
             * Previous Objectives
             * @description The previous solutions objectives used for iteration.
             */
            previous_objectives: {
                [key: string]: number;
            };
            /**
             * Current Solutions
             * @description The solutions from the current iteration of nimbus.
             */
            current_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * Saved Solutions
             * @description The best candidate solutions saved by the decision maker.
             */
            saved_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * All Solutions
             * @description All solutions generated by NIMBUS in all iterations.
             */
            all_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * NIMBUSDeleteSaveRequest
         * @description Request model for deletion of a saved solution.
         */
        NIMBUSDeleteSaveRequest: {
            /**
             * State Id
             * @description The ID of the save state.
             */
            state_id: number;
            /**
             * Solution Index
             * @description The ID of the solution within the above state.
             */
            solution_index: number;
        };
        /**
         * NIMBUSDeleteSaveResponse
         * @description Response of NIMBUS save deletion.
         */
        NIMBUSDeleteSaveResponse: {
            /** Message */
            message: string | null;
        };
        /**
         * NIMBUSFinalizeRequest
         * @description Request model for finalizing the NIMBUS procedure.
         */
        NIMBUSFinalizeRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            solution_info: components["schemas"]["SolutionInfo"];
            preferences: components["schemas"]["ReferencePoint"];
        };
        /**
         * NIMBUSFinalizeResponse
         * @description The response from NIMBUS finish endpoint.
         */
        NIMBUSFinalizeResponse: {
            /**
             * State Id
             * @description The id of the newest state
             */
            state_id: number | null;
            /** @description The final solution */
            final_solution: components["schemas"]["SolutionReferenceResponse"];
        };
        /**
         * NIMBUSInitializationRequest
         * @description Model of the request to the nimbus method.
         */
        NIMBUSInitializationRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Starting Point */
            starting_point?: components["schemas"]["ReferencePoint"] | components["schemas"]["SolutionInfo"] | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
        };
        /**
         * NIMBUSInitializationResponse
         * @description The response from NIMBUS classification endpoint.
         */
        NIMBUSInitializationResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /**
             * Current Solutions
             * @description The solutions from the current interation of nimbus.
             */
            current_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * Saved Solutions
             * @description The best candidate solutions saved by the decision maker.
             */
            saved_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * All Solutions
             * @description All solutions generated by NIMBUS in all iterations.
             */
            all_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * NIMBUSIntermediateSolutionResponse
         * @description The response from NIMBUS classification endpoint.
         */
        NIMBUSIntermediateSolutionResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /**
             * Reference Solution 1
             * @description The first solution used when computing intermediate points.
             */
            reference_solution_1: {
                [key: string]: number;
            };
            /**
             * Reference Solution 2
             * @description The second solution used when computing intermediate points.
             */
            reference_solution_2: {
                [key: string]: number;
            };
            /**
             * Current Solutions
             * @description The solutions from the current iteration of NIMBUS.
             */
            current_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * Saved Solutions
             * @description The best candidate solutions saved by the decision maker.
             */
            saved_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * All Solutions
             * @description All solutions generated by NIMBUS in all iterations.
             */
            all_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * NIMBUSSaveRequest
         * @description Request model for saving solutions from any method's state.
         */
        NIMBUSSaveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Solution Info */
            solution_info: components["schemas"]["SolutionInfo"][];
        };
        /**
         * NIMBUSSaveResponse
         * @description The response from NIMBUS save endpoint.
         */
        NIMBUSSaveResponse: {
            /**
             * State Id
             * @description The id of the newest state
             */
            state_id: number | null;
        };
        /**
         * ObjectiveDB
         * @description The SQLModel equivalent to `Objective`.
         */
        ObjectiveDB: {
            /** Func */
            func: unknown[] | null;
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Description
             * @description A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.
             */
            description?: string | null;
            /**
             * Name
             * @description Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'.
             */
            symbol: string;
            /**
             * Unit
             * @description The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'.
             */
            unit?: string | null;
            /**
             * Maximize
             * @description Whether the objective function is to be maximized or minimized.
             * @default false
             */
            maximize: boolean;
            /**
             * Ideal
             * @description Ideal value of the objective. This is optional.
             */
            ideal?: number | null;
            /**
             * Nadir
             * @description Nadir value of the objective. This is optional.
             */
            nadir?: number | null;
            /**
             * @description The type of objective function. 'analytical' means the objective function value is calculated based on 'func'. 'data_based' means the objective function value should be retrieved from a table. In case of 'data_based' objective function, the 'func' field is ignored. Defaults to 'analytical'.
             * @default analytical
             */
            objective_type: components["schemas"]["ObjectiveTypeEnum"];
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ObjectiveTypeEnum
         * @description An enumerator for supported objective function types.
         * @enum {string}
         */
        ObjectiveTypeEnum: "analytical" | "data_based" | "simulator" | "surrogate";
        /**
         * OptimizationPreference
         * @description A structure for storing optimization preferences. See GNIMBUS for details.
         */
        OptimizationPreference: {
            /**
             * Method
             * @default optimization
             */
            method: string;
            /**
             * Phase
             * @default learning
             */
            phase: string;
            /** Set Preferences */
            set_preferences: {
                [key: string]: components["schemas"]["ReferencePoint"];
            };
        };
        /**
         * ProblemGetRequest
         * @description Model to deal with problem fetching requests.
         */
        ProblemGetRequest: {
            /** Problem Id */
            problem_id: number;
        };
        /**
         * ProblemInfo
         * @description Problem info request return data.
         */
        ProblemInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
            /** Constants */
            constants: components["schemas"]["ConstantDB"][] | null;
            /** Tensor Constants */
            tensor_constants: components["schemas"]["TensorConstantDB"][] | null;
            /** Variables */
            variables: components["schemas"]["VariableDB"][] | null;
            /** Tensor Variables */
            tensor_variables: components["schemas"]["TensorVariableDB"][] | null;
            /** Objectives */
            objectives: components["schemas"]["ObjectiveDB"][];
            /** Constraints */
            constraints: components["schemas"]["ConstraintDB"][] | null;
            /** Scalarization Funcs */
            scalarization_funcs: components["schemas"]["ScalarizationFunctionDB"][] | null;
            /** Extra Funcs */
            extra_funcs: components["schemas"]["ExtraFunctionDB"][] | null;
            discrete_representation: components["schemas"]["DiscreteRepresentationDB"] | null;
            /** Simulators */
            simulators: components["schemas"]["SimulatorDB"][] | null;
            problem_metadata: components["schemas"]["ProblemMetaDataPublic"] | null;
        };
        /**
         * ProblemInfoSmall
         * @description Problem info request return data, but smaller.
         */
        ProblemInfoSmall: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
            problem_metadata: components["schemas"]["ProblemMetaDataPublic"] | null;
        };
        /**
         * ProblemMetaDataGetRequest
         * @description Request model for getting specific type of metadata from a specific problem.
         */
        ProblemMetaDataGetRequest: {
            /** Problem Id */
            problem_id: number;
            /** Metadata Type */
            metadata_type: string;
        };
        /**
         * ProblemMetaDataPublic
         * @description Response model for ProblemMetaData.
         */
        ProblemMetaDataPublic: {
            /** Problem Id */
            problem_id: number;
            /** Forest Metadata */
            forest_metadata: components["schemas"]["ForestProblemMetaData"][] | null;
            /** Representative Nd Metadata */
            representative_nd_metadata: components["schemas"]["RepresentativeNonDominatedSolutions"][] | null;
        };
        /**
         * ProblemSelectSolverRequest
         * @description Model to request a specific solver for a problem.
         */
        ProblemSelectSolverRequest: {
            /**
             * Problem Id
             * @description ID of the problem that the solver is assigned to.
             */
            problem_id: number;
            /**
             * Solver String Representation
             * @description One of the following: ['scipy_minimize', 'scipy_de', 'proximal', 'nevergrad', 'pyomo_bonmin', 'pyomo_cbc', 'pyomo_ipopt', 'pyomo_gurobi', 'gurobipy', 'gurobipy_persistent']
             */
            solver_string_representation: string;
        };
        /**
         * RPMSolveRequest
         * @description Model of the request to the reference point method.
         */
        RPMSolveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
        };
        /**
         * RPMState
         * @description Reference Point Method (k+1 candidates).
         */
        RPMState: {
            /** Id */
            id?: number | null;
            preferences: components["schemas"]["ReferencePoint"];
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * ReferencePoint
         * @description Model for representing a reference point type of preference.
         */
        ReferencePoint: {
            /**
             * Preference Type
             * @default reference_point
             * @constant
             */
            preference_type: "reference_point";
            /** Aspiration Levels */
            aspiration_levels: {
                [key: string]: number;
            };
        };
        /**
         * RepresentativeNonDominatedSolutions
         * @description A problem metadata class to store representative solutions sets, i.e., non-dominated sets...
         *
         *     A problem metadata class to store representative solutions sets, i.e., non-dominated sets that
         *     represent/approximate the Pareto optimal solution set of the problem.
         *
         *     Note:
         *         It is assumed that the solution set is non-dominated.
         */
        RepresentativeNonDominatedSolutions: {
            /** Id */
            id?: number | null;
            /** Metadata Id */
            metadata_id?: number | null;
            /**
             * Metadata Type
             * @default representative_non_dominated_solutions
             */
            metadata_type: string;
            /**
             * Name
             * @description The name of the representative set.
             */
            name: string;
            /**
             * Description
             * @description A description of the representative set. Optional.
             */
            description?: string | null;
            /**
             * Solution Data
             * @description The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.
             */
            solution_data: {
                [key: string]: number[];
            };
            /**
             * Ideal
             * @description The ideal objective function values of the representative set.
             */
            ideal: {
                [key: string]: number;
            };
            /**
             * Nadir
             * @description The nadir objective function values of the representative set.
             */
            nadir: {
                [key: string]: number;
            };
        };
        /**
         * SCOREBandsConfig
         * @description Configuration options for SCORE bands visualization.
         */
        SCOREBandsConfig: {
            /**
             * Dimensions
             * @description List of variable/objective names (i.e., column names in the data) to include in the visualization.
             *     If None, all columns in the data are used. Defaults to None.
             */
            dimensions?: string[] | null;
            /**
             * Descriptive Names
             * @description Optional dictionary mapping dimensions to descriptive names for display in the visualization.
             *     If None, the original dimension names are used. Defaults to None.
             */
            descriptive_names?: {
                [key: string]: string;
            } | null;
            /**
             * Units
             * @description Optional dictionary mapping dimensions to their units for display in the visualization.
             *     If None, no units are displayed. Defaults to None.
             */
            units?: {
                [key: string]: string;
            } | null;
            /**
             * Axis Positions
             * @description Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first
             *     objective is at position 0.0, and the last objective is at position 1.0. Use this option if you want to
             *     manually set the axis positions. If None, the axis positions are calculated automatically based on correlations.
             *     Defaults to None.
             */
            axis_positions?: {
                [key: string]: number;
            } | null;
            /**
             * Clustering Algorithm
             * @description Clustering algorithm to use. Currently supported options: "GMM", "DBSCAN",
             *         and "KMeans". Defaults to "DBSCAN".
             * @default {
             *       "name": "DBSCAN"
             *     }
             */
            clustering_algorithm: components["schemas"]["GMMOptions"] | components["schemas"]["DBSCANOptions"] | components["schemas"]["KMeansOptions"] | components["schemas"]["DimensionClusterOptions"] | components["schemas"]["CustomClusterOptions"];
            /**
             * @description Distance formula to use. The value should be 1 or 2. Check the paper for details. Defaults to 1.
             * @default 1
             */
            distance_formula: components["schemas"]["DistanceFormula"];
            /**
             * Distance Parameter
             * @description Change the relative distances between the objective axes. Increase this value if objectives are placed too close
             *     together. Decrease this value if the objectives are equidistant in a problem with objective clusters. Defaults
             *     to 0.05.
             * @default 0.05
             */
            distance_parameter: number;
            /**
             * Use Absolute Correlations
             * @description Whether to use absolute value of the correlation to calculate the placement of axes. Defaults to False.
             * @default false
             */
            use_absolute_correlations: boolean;
            /**
             * Include Solutions
             * @description Whether to include individual solutions. Defaults to False. If True, the size of the resulting figure may be
             *     very large for datasets with many solutions. Moreover, the individual traces are hidden by default, but can be
             *     viewed interactively in the figure.
             * @default false
             */
            include_solutions: boolean;
            /**
             * Include Medians
             * @description Whether to include cluster medians. Defaults to False. If True, the median traces are hidden by default, but
             *     can be viewed interactively in the figure.
             * @default false
             */
            include_medians: boolean;
            /**
             * Interval Size
             * @description The size (as a fraction) of the interval to use for the bands. Defaults to 0.95, meaning that 95% of the
             *     middle solutions in a cluster will be included in the band. The rest will be considered outliers.
             * @default 0.95
             */
            interval_size: number;
            /**
             * Scales
             * @description Optional dictionary specifying the min and max values for each objective. The keys should be the
             *     objective names (i.e., column names in the data), and the values should be tuples of (min, max).
             *     If not provided, the min and max will be calculated from the data.
             */
            scales?: {
                [key: string]: [
                    number,
                    number
                ];
            } | null;
        };
        /**
         * SCOREBandsGDMConfig
         * @description Configuration for the SCORE bands based GDM.
         */
        SCOREBandsGDMConfig: {
            score_bands_config?: components["schemas"]["SCOREBandsConfig"];
            /**
             * Minimum Votes
             * @default 1
             */
            minimum_votes: number;
            /** From Iteration */
            from_iteration: number | null;
        };
        /**
         * SCOREBandsResult
         * @description Pydantic/JSON model for representing SCORE Bands.
         */
        SCOREBandsResult: {
            /** @description Configuration options used to generate the SCORE bands. */
            options: components["schemas"]["SCOREBandsConfig"];
            /**
             * Ordered Dimensions
             * @description List of variable/objective names (i.e., column names in the data).
             *     Ordered according to their placement in the SCORE bands visualization.
             */
            ordered_dimensions: string[];
            /**
             * Clusters
             * @description List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.
             */
            clusters: number[];
            /**
             * Axis Positions
             * @description Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first
             *     objective is at position 0.0, and the last objective is at position 1.0.
             */
            axis_positions: {
                [key: string]: number;
            };
            /**
             * Bands
             * @description Dictionary mapping cluster IDs to dictionaries of objective names and their corresponding band
             *     extremes (min, max).
             */
            bands: {
                [key: string]: {
                    [key: string]: [
                        number,
                        number
                    ];
                };
            };
            /**
             * Medians
             * @description Dictionary mapping cluster IDs to dictionaries of objective names and their corresponding median values.
             */
            medians: {
                [key: string]: {
                    [key: string]: number;
                };
            };
            /**
             * Cardinalities
             * @description Dictionary mapping cluster IDs to the number of solutions in each cluster.
             */
            cardinalities: {
                [key: string]: number;
            };
        };
        /**
         * ScalarizationFunctionDB
         * @description The SQLModel equivalent to `ScalarizationFunction`.
         */
        ScalarizationFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys: string[];
            /**
             * Name
             * @description Name of the scalarization function.
             */
            name: string;
            /**
             * Symbol
             * @description Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.
             */
            symbol?: string | null;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ScoreBandsRequest
         * @description Model of the request to calculate SCORE bands parameters.
         */
        ScoreBandsRequest: {
            /**
             * Data
             * @description Matrix of objective values
             */
            data: number[][];
            /**
             * Objs
             * @description Array of objective names for each column
             */
            objs: string[];
            /**
             * Dist Parameter
             * @description Distance parameter for axis positioning
             * @default 0.05
             */
            dist_parameter: number;
            /**
             * Use Absolute Corr
             * @description Use absolute correlation values
             * @default false
             */
            use_absolute_corr: boolean;
            /**
             * Distance Formula
             * @description Distance formula (1 or 2)
             * @default 1
             */
            distance_formula: number;
            /**
             * Flip Axes
             * @description Whether to flip axes based on correlation signs
             * @default true
             */
            flip_axes: boolean;
            /**
             * Clustering Algorithm
             * @description Clustering algorithm (DBSCAN or GMM)
             * @default DBSCAN
             */
            clustering_algorithm: string;
            /**
             * Clustering Score
             * @description Clustering score metric
             * @default silhoutte
             */
            clustering_score: string;
        };
        /**
         * ScoreBandsResponse
         * @description Model of the response containing SCORE bands parameters.
         */
        ScoreBandsResponse: {
            /**
             * Groups
             * @description Cluster group assignments for each data point
             */
            groups: number[];
            /**
             * Axis Dist
             * @description Normalized axis positions
             */
            axis_dist: number[];
            /**
             * Axis Signs
             * @description Axis direction signs (1 or -1)
             */
            axis_signs: number[] | null;
            /**
             * Obj Order
             * @description Optimal order of objectives
             */
            obj_order: number[];
        };
        /**
         * SimulatorDB
         * @description The SQLModel equivalent to `Simulator`.
         */
        SimulatorDB: {
            /** File */
            file?: string | null;
            url?: components["schemas"]["Url"] | null;
            /** Parameter Options */
            parameter_options?: {
                [key: string]: unknown;
            } | null;
            /**
             * Name
             * @description Descriptive name of the simulator. This can be used in UI and visualizations.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * SolutionInfo
         * @description Used when we wish to reference a solution in some `StateDB` stored in the database.
         */
        SolutionInfo: {
            /** State Id */
            state_id: number;
            /** Solution Index */
            solution_index: number;
            /**
             * Name
             * @description Name to be given to the solution. Optional.
             */
            name?: string | null;
        };
        /**
         * SolutionReference
         * @description A full solution reference with objectives and variables.
         */
        SolutionReference: {
            /**
             * Name
             * @description Optional name to help identify the solution if, e.g., saved.
             */
            name?: string | null;
            /**
             * Solution Index
             * @description The index of the referenced solution, if multiple solutions exist in the reference state.
             */
            solution_index?: number | null;
            /** @description The reference state with the solution information. */
            state: components["schemas"]["StateDB"];
            /** State Id */
            readonly state_id: number;
            /** Num Solutions */
            readonly num_solutions: number;
            /** Objective Values All */
            readonly objective_values_all: {
                [key: string]: number;
            }[];
            /** Variable Values All */
            readonly variable_values_all: {
                [key: string]: number | boolean | components["schemas"]["Tensor"];
            }[];
            /** Objective Values */
            readonly objective_values: {
                [key: string]: number;
            } | null;
            /** Variable Values */
            readonly variable_values: {
                [key: string]: number | boolean | components["schemas"]["Tensor"];
            } | null;
        };
        /**
         * SolutionReferenceLite
         * @description The same as SolutionReference, but without decision variables for more efficient transport over the internet.
         */
        SolutionReferenceLite: {
            /**
             * Name
             * @description Optional name to help identify the solution if, e.g., saved.
             */
            name?: string | null;
            /**
             * Solution Index
             * @description The index of the referenced solution, if multiple solutions exist in the reference state.
             */
            solution_index?: number | null;
            /** @description The reference state with the solution information. */
            state: components["schemas"]["StateDB"];
            /** State Id */
            readonly state_id: number;
            /** Num Solutions */
            readonly num_solutions: number;
            /** Objective Values */
            readonly objective_values: {
                [key: string]: number;
            } | null;
        };
        /**
         * SolutionReferenceResponse
         * @description The response information provided when `SolutionReference` object are returned from the client.
         */
        SolutionReferenceResponse: {
            /** Name */
            name: string | null;
            /** Solution Index */
            solution_index: number | null;
            /** State Id */
            state_id: number;
            /** Objective Values */
            objective_values: {
                [key: string]: number;
            } | null;
            /** Variable Values */
            variable_values: {
                [key: string]: number | boolean | components["schemas"]["Tensor"];
            } | null;
        };
        /**
         * SolverResults
         * @description Defines a schema for a dataclass to store the results of a solver.
         */
        SolverResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Scalarization Values
             * @description The scalarization function values of the problem.
             */
            scalarization_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Success
             * @description A boolean flag indicating whether the optimization was successful or not.
             */
            success: boolean;
            /**
             * Message
             * @description Description of the cause of termination.
             */
            message: string;
        };
        /**
         * SolverSelectionMetadata
         * @description A problem metadata class to store the preferred solver of a problem.
         *
         *     A problem metadata class to store the preferred solver of a problem.
         *     See desdeo/tools/utils.py -> available_solvers for available solvers.
         */
        SolverSelectionMetadata: {
            /** Id */
            id?: number | null;
            /** Metadata Id */
            metadata_id?: number | null;
            /**
             * Metadata Type
             * @default solver_selection_metadata
             */
            metadata_type: string;
            /**
             * Solver String Representation
             * @description The string representation of the selected solver.
             */
            solver_string_representation: string;
        };
        /**
         * StateDB
         * @description State holder with a single relationship to the base State.
         */
        StateDB: {
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
            /** Session Id */
            session_id?: number | null;
            /** Parent Id */
            parent_id?: number | null;
            /** State Id */
            state_id?: number | null;
        };
        Tensor: components["schemas"]["Tensor"][] | (number | boolean)[] | number | boolean | "List" | null;
        /**
         * TensorConstantDB
         * @description The SQLModel equivalent to `TensorConstant`.
         */
        TensorConstantDB: {
            values: components["schemas"]["Tensor"];
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the tensor representing the values. E.g., 'distances'
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * TensorVariableDB
         * @description The SQLModel equivalent to `TensorVariable`.
         */
        TensorVariableDB: {
            initial_values: components["schemas"]["Tensor"] | null;
            lowerbounds: components["schemas"]["Tensor"] | null;
            upperbounds: components["schemas"]["Tensor"] | null;
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer, or binary. Note that each element of a TensorVariable is assumed to be of the same type. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * Tokens
         * @description A model for the authentication token.
         */
        Tokens: {
            /** Access Token */
            access_token: string;
            /** Refresh Token */
            refresh_token: string;
            /** Token Type */
            token_type: string;
        };
        /**
         * Url
         * @description Model for a URL.
         */
        Url: {
            /**
             * Url
             * @description A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.
             */
            url: string;
            /**
             * Auth
             * @description Optional. A tuple of username and password to be used for authentication when making requests to the URL.
             */
            auth?: [
                string,
                string
            ] | null;
        };
        /**
         * UserPublic
         * @description The object to handle public user information.
         */
        UserPublic: {
            /** Username */
            username: string;
            /** Id */
            id: number;
            role: components["schemas"]["UserRole"];
            /** Group Ids */
            group_ids: number[] | null;
        };
        /**
         * UserRole
         * @description Possible user roles.
         * @enum {string}
         */
        UserRole: "guest" | "dm" | "analyst" | "admin";
        /**
         * UtopiaRequest
         * @description The request for an Utopia map.
         */
        UtopiaRequest: {
            /**
             * Problem Id
             * @description Problem for which the map is generated
             */
            problem_id: number;
            /** @description Solution for which to generate the map */
            solution: components["schemas"]["SolutionInfo"];
        };
        /**
         * UtopiaResponse
         * @description The response to an UtopiaRequest.
         */
        UtopiaResponse: {
            /**
             * Is Utopia
             * @description True if map exists for this problem.
             */
            is_utopia: boolean;
            /**
             * Map Name
             * @description Name of the map.
             */
            map_name: string;
            /**
             * Map Json
             * @description MapJSON representation of the geography.
             */
            map_json: {
                [key: string]: unknown;
            };
            /**
             * Options
             * @description A dict with given years as keys containing options for each year.
             */
            options: {
                [key: string]: unknown;
            };
            /**
             * Description
             * @description Description shown above the map.
             */
            description: string;
            /**
             * Years
             * @description A list of years for which the maps have been generated.
             */
            years: string[];
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VariableDB
         * @description The SQLModel equivalent to `Variable`.
         */
        VariableDB: {
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer or binary. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /**
             * Lowerbound
             * @description Lower bound of the variable.
             */
            lowerbound?: number | null;
            /**
             * Upperbound
             * @description Upper bound of the variable.
             */
            upperbound?: number | null;
            /**
             * Initial Value
             * @description Initial value of the variable. This is optional.
             */
            initial_value?: number | null;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * VariableDomainTypeEnum
         * @description An enumerator for the possible variable type domains of a problem.
         * @enum {string}
         */
        VariableDomainTypeEnum: "continuous" | "binary" | "integer" | "mixed";
        /**
         * VariableTypeEnum
         * @description An enumerator for possible variable types.
         * @enum {string}
         */
        VariableTypeEnum: "real" | "integer" | "binary";
        /**
         * VotingPreference
         * @description A structure for storing voting preferences.
         */
        VotingPreference: {
            /**
             * Method
             * @default voting
             */
            method: string;
            /** Set Preferences */
            set_preferences: {
                [key: string]: number;
            };
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_current_user_info_user_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserPublic"];
                };
            };
        };
    };
    login_login_post: {
        parameters: {
            query?: {
                cookie_max_age?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_login_login_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Tokens"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    logout_logout_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    refresh_access_token_refresh_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: {
                refresh_token?: string | null;
            };
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_dm_add_new_dm_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_dm_add_new_dm_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_analyst_add_new_analyst_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_analyst_add_new_analyst_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_problems_problem_all_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfoSmall"][];
                };
            };
        };
    };
    get_problems_info_problem_all_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"][];
                };
            };
        };
    };
    get_problem_problem_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemGetRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_problem_problem_add_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
        };
    };
    get_metadata_problem_get_metadata_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemMetaDataGetRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": (components["schemas"]["ForestProblemMetaData"] | components["schemas"]["RepresentativeNonDominatedSolutions"] | components["schemas"]["SolverSelectionMetadata"])[];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    select_solver_problem_assign_solver_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemSelectSolverRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_new_session_session_new_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_session_session_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_rpm_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RPMSolveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RPMState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_nimbus_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSClassificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSClassificationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    initialize_method_nimbus_initialize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSInitializationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSInitializationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    save_method_nimbus_save_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSSaveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSSaveResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_nimbus_intermediate_method_nimbus_intermediate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IntermediateSolutionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSIntermediateSolutionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_or_initialize_method_nimbus_get_or_initialize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSInitializationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSInitializationResponse"] | components["schemas"]["NIMBUSClassificationResponse"] | components["schemas"]["NIMBUSIntermediateSolutionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    finalize_nimbus_method_nimbus_finalize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSFinalizeRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSFinalizeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_save_method_nimbus_delete_save_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSDeleteSaveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSDeleteSaveResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_intermediate_method_generic_intermediate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IntermediateSolutionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenericIntermediateSolutionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    calculate_score_bands_from_objective_data_method_generic_score_bands_obj_data_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ScoreBandsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScoreBandsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_utopia_data_utopia__post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UtopiaRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UtopiaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_group_gdm_create_group_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_group_gdm_delete_group_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_to_group_gdm_add_to_group_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupModifyRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    remove_from_group_gdm_remove_from_group_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupModifyRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_group_info_gdm_get_group_info_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GroupPublic"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    gnimbus_initialize_gnimbus_initialize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_latest_results_gnimbus_get_latest_results_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GNIMBUSResultResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    full_iteration_gnimbus_all_iterations_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GNIMBUSAllIterationsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    switch_phase_gnimbus_toggle_phase_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GNIMBUSSwitchPhaseRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GNIMBUSSwitchPhaseResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_phase_gnimbus_get_phase_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    revert_iteration_gnimbus_revert_iteration_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupRevertRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    step_method_enautilus_step_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EnautilusStepRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ENautilusState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    vote_for_a_band_gdm_score_bands_vote_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GDMScoreBandsVoteRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    confirm_vote_gdm_score_bands_confirm_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_or_initialize_gdm_score_bands_get_or_initialize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GDMScoreBandsInitializationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GDMSCOREBandsHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_votes_and_confirms_gdm_score_bands_get_votes_and_confirms_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupInfoRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    revert_gdm_score_bands_revert_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GDMSCOREBandsRevertRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    configure_gdm_gdm_score_bands_configure_post: {
        parameters: {
            query: {
                group_id: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SCOREBandsGDMConfig"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
