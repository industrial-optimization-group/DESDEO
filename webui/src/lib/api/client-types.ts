/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/user_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current User Info
         * @description Return information about the current user.
         *
         *     Args:
         *         user (Annotated[User, Depends): user dependency, handled by `get_current_user`.
         *
         *     Returns:
         *         UserPublic: public information about the current user.
         */
        get: operations["get_current_user_info_user_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login
         * @description Login to get an authentication token.
         *
         *     Return an access token in the response and a cookie storing a refresh token.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
         *             The form data to authenticate the user.
         *         session (Annotated[Session, Depends(get_db)]): The database session.
         *         cookie_max_age (int): the lifetime of the cookie storing the refresh token.
         */
        post: operations["login_login_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description Log the current user out. Deletes the refresh token that was set by logging in.
         *
         *     Args:
         *         None
         *
         *     Returns:
         *         JSONResponse: A response in which the cookies are deleted
         */
        post: operations["logout_logout_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Access Token
         * @description Refresh the access token using the refresh token stored in the cookie.
         *
         *     Args:
         *         request (Request): The request containing the cookie.
         *         session (Annotated[Session, Depends(get_db)]): the database session.
         *         refresh_token (Annotated[Str | None, Cookie()]): the refresh
         *             token, which is fetched from a cookie included in the response.
         *
         *     Returns:
         *         dict: A dictionary containing the new access token.
         */
        post: operations["refresh_access_token_refresh_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_dm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Dm
         * @description Add a new user of the role Decision Maker to the database. Requires no login.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_dm_add_new_dm_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_analyst": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Analyst
         * @description Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin
         *
         *     Args:
         *         user Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if the logged in user is not an analyst or an admin or if
         *         username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_analyst_add_new_analyst_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems
         * @description Get information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfoSmall]: a list of information on all the problems.
         */
        get: operations["get_problems_problem_all_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems Info
         * @description Get detailed information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfo]: a list of the detailed information on all the problems.
         */
        get: operations["get_problems_info_problem_all_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Problem
         * @description Get the model of a specific problem.
         *
         *     Args:
         *         request (ProblemGetRequest): the request containing the problem's id `problem_id`.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find a problem with the given id.
         *
         *     Returns:
         *         ProblemInfo: detailed information on the requested problem.
         */
        post: operations["get_problem_problem_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/add": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Problem
         * @description Add a newly defined problem to the database.
         *
         *     Args:
         *         request (Problem): the JSON representation of the problem.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Note:
         *         Users with the role 'guest' may not add new problems.
         *
         *     Raises:
         *         HTTPException: when any issue with defining the problem arises.
         *
         *     Returns:
         *         ProblemInfo: the information about the problem added.
         */
        post: operations["add_problem_problem_add_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/new": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create New Session
         * @description .
         */
        post: operations["create_new_session_session_new_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Session
         * @description Return an interactive session with a given id for the current user.
         *
         *     Args:
         *         request (GetSessionRequest): a request containing the id of the session.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find an interactive session with the given id
         *             for the current user.
         *
         *     Returns:
         *         InteractiveSessionInfo: info on the requested interactive session.
         */
        post: operations["get_session_session_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/rpm/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description .
         */
        post: operations["solve_solutions_method_rpm_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description Solve the problem using the NIMBUS method.
         */
        post: operations["solve_solutions_method_nimbus_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Save
         * @description Save solutions.
         */
        post: operations["save_method_nimbus_save_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/generic/intermediate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Intermediate
         * @description Solve intermediate solutions between given two solutions.
         */
        post: operations["solve_intermediate_method_generic_intermediate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Body_add_new_analyst_add_new_analyst_post */
        Body_add_new_analyst_add_new_analyst_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /** Password */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /** Client Secret */
            client_secret?: string | null;
        };
        /** Body_add_new_dm_add_new_dm_post */
        Body_add_new_dm_add_new_dm_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /** Password */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /** Client Secret */
            client_secret?: string | null;
        };
        /** Body_login_login_post */
        Body_login_login_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /** Password */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /** Client Secret */
            client_secret?: string | null;
        };
        /**
         * ConstantDB
         * @description The SQLModel equivalent to `Constant`.
         */
        ConstantDB: {
            /**
             * Name
             * @description Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'.
             */
            symbol: string;
            /**
             * Value
             * @description The value of the constant.
             */
            value: number;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintDB
         * @description The SQLModel equivalent to `Constraint`.
         */
        ConstraintDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | null;
            /**
             * Name
             * @description Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'.
             */
            symbol: string;
            /** @description The type of the constraint. Constraints are assumed to be in a standard form where the supplied 'func' expression is on the left hand side of the constraint's expression, and on the right hand side a zero value is assume. The comparison between the left hand side and right hand side is either and quality comparison ('=') or lesser than equal comparison ('<='). */
            cons_type: components["schemas"]["ConstraintTypeEnum"];
            /**
             * Is Linear
             * @description Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.
             * @default true
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintTypeEnum
         * @description An enumerator for supported constraint expression types.
         * @enum {string}
         */
        ConstraintTypeEnum: "=" | "<=";
        /**
         * CreateSessionRequest
         * @description Model of the request to create a new session.
         */
        CreateSessionRequest: {
            /** Info */
            info?: string | null;
        };
        /**
         * DiscreteRepresentationDB
         * @description The SQLModel equivalent to `DiscreteRepresentation`.
         */
        DiscreteRepresentationDB: {
            /**
             * Non Dominated
             * @default false
             */
            non_dominated: boolean;
            /** Variable Values */
            variable_values: {
                [key: string]: (number | boolean)[];
            };
            /** Objective Values */
            objective_values: {
                [key: string]: number[];
            };
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ExtraFunctionDB
         * @description The SQLModel equivalent to `ExtraFunction`.
         */
        ExtraFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | null;
            /**
             * Name
             * @description Descriptive name of the function. Example: 'normalization'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'.
             */
            symbol: string;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * GetSessionRequest
         * @description Model of the request to get a specific session.
         */
        GetSessionRequest: {
            /** Session Id */
            session_id: number;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * InteractiveSessionBase
         * @description The base model for representing interactive sessions.
         */
        InteractiveSessionBase: {
            /** Id */
            id: number | null;
            /** User Id */
            user_id: number | null;
            /** Info */
            info: string | null;
        };
        /**
         * IntermediateSolutionRequest
         * @description Model of the request to solve intermediate solutions between two solutions.
         */
        IntermediateSolutionRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            /** Reference Solution 1 */
            reference_solution_1: {
                [key: string]: number;
            };
            /** Reference Solution 2 */
            reference_solution_2: {
                [key: string]: number;
            };
        };
        /**
         * IntermediateSolutionState
         * @description State of the nimbus method for computing solutions.
         */
        IntermediateSolutionState: {
            /**
             * Method
             * @default generic
             * @constant
             */
            method: "generic";
            /**
             * Phase
             * @default solve_intermediate
             * @constant
             */
            phase: "solve_intermediate";
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            /** Reference Solution 1 */
            reference_solution_1: {
                [key: string]: number;
            };
            /** Reference Solution 2 */
            reference_solution_2: {
                [key: string]: number;
            };
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * NIMBUSClassificationRequest
         * @description Model of the request to the nimbus method.
         */
        NIMBUSClassificationRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
            /** Current Objectives */
            current_objectives: {
                [key: string]: number;
            };
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
        };
        /**
         * NIMBUSClassificationState
         * @description State of the nimbus method for computing solutions.
         */
        NIMBUSClassificationState: {
            /**
             * Method
             * @default nimbus
             * @constant
             */
            method: "nimbus";
            /**
             * Phase
             * @default solve_candidates
             * @constant
             */
            phase: "solve_candidates";
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Current Objectives */
            current_objectives: {
                [key: string]: number;
            };
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            previous_preference?: components["schemas"]["ReferencePoint"];
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * NIMBUSSaveRequest
         * @description Request model for saving solutions from any method's state.
         */
        NIMBUSSaveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Solutions */
            solutions: components["schemas"]["UserSavedSolverResults"][];
        };
        /**
         * NIMBUSSaveState
         * @description State of the nimbus method for saving solutions.
         */
        NIMBUSSaveState: {
            /**
             * Method
             * @default nimbus
             * @constant
             */
            method: "nimbus";
            /**
             * Phase
             * @default save_solutions
             * @constant
             */
            phase: "save_solutions";
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * ObjectiveDB
         * @description The SQLModel equivalent to `Objective`.
         */
        ObjectiveDB: {
            /** Func */
            func: unknown[] | null;
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | null;
            /**
             * Name
             * @description Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'.
             */
            symbol: string;
            /**
             * Unit
             * @description The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'.
             */
            unit?: string | null;
            /**
             * Maximize
             * @description Whether the objective function is to be maximized or minimized.
             * @default false
             */
            maximize: boolean;
            /**
             * Ideal
             * @description Ideal value of the objective. This is optional.
             */
            ideal?: number | null;
            /**
             * Nadir
             * @description Nadir value of the objective. This is optional.
             */
            nadir?: number | null;
            /**
             * @description The type of objective function. 'analytical' means the objective function value is calculated based on 'func'. 'data_based' means the objective function value should be retrieved from a table. In case of 'data_based' objective function, the 'func' field is ignored. Defaults to 'analytical'.
             * @default analytical
             */
            objective_type: components["schemas"]["ObjectiveTypeEnum"];
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ObjectiveTypeEnum
         * @description An enumerator for supported objective function types.
         * @enum {string}
         */
        ObjectiveTypeEnum: "analytical" | "data_based" | "simulator" | "surrogate";
        /**
         * ProblemGetRequest
         * @description Model to deal with problem fetching requests.
         */
        ProblemGetRequest: {
            /** Problem Id */
            problem_id: number;
        };
        /**
         * ProblemInfo
         * @description .
         */
        ProblemInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
            /** Constants */
            constants: components["schemas"]["ConstantDB"][] | null;
            /** Tensor Constants */
            tensor_constants: components["schemas"]["TensorConstantDB"][] | null;
            /** Variables */
            variables: components["schemas"]["VariableDB"][] | null;
            /** Tensor Variables */
            tensor_variables: components["schemas"]["TensorVariableDB"][] | null;
            /** Objectives */
            objectives: components["schemas"]["ObjectiveDB"][];
            /** Constraints */
            constraints: components["schemas"]["ConstraintDB"][] | null;
            /** Scalarization Funcs */
            scalarization_funcs: components["schemas"]["ScalarizationFunctionDB"][] | null;
            /** Extra Funcs */
            extra_funcs: components["schemas"]["ExtraFunctionDB"][] | null;
            discrete_representation: components["schemas"]["DiscreteRepresentationDB"] | null;
            /** Simulators */
            simulators: components["schemas"]["SimulatorDB"][] | null;
        };
        /**
         * ProblemInfoSmall
         * @description .
         */
        ProblemInfoSmall: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
        };
        /**
         * RPMSolveRequest
         * @description Model of the request to the reference point method.
         */
        RPMSolveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
        };
        /**
         * RPMState
         * @description State of the reference point method for computing solutions.
         */
        RPMState: {
            /**
             * Method
             * @default reference_point_method
             * @constant
             */
            method: "reference_point_method";
            /**
             * Phase
             * @default solve_candidates
             * @constant
             */
            phase: "solve_candidates";
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * ReferencePoint
         * @description Model for representing a reference point type of preference.
         */
        ReferencePoint: {
            /**
             * Preference Type
             * @default reference_point
             * @constant
             */
            preference_type: "reference_point";
            /** Aspiration Levels */
            aspiration_levels: {
                [key: string]: number;
            };
        };
        /**
         * ScalarizationFunctionDB
         * @description The SQLModel equivalent to `ScalarizationFunction`.
         */
        ScalarizationFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys: string[];
            /**
             * Name
             * @description Name of the scalarization function.
             */
            name: string;
            /**
             * Symbol
             * @description Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.
             */
            symbol?: string | null;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * SimulatorDB
         * @description The SQLModel equivalent to `Simulator`.
         */
        SimulatorDB: {
            /**
             * File
             * Format: path
             */
            file: string;
            /** Parameter Options */
            parameter_options?: {
                [key: string]: unknown;
            } | null;
            /**
             * Name
             * @description Descriptive name of the simulator. This can be used in UI and visualizations.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * SolverResults
         * @description Defines a schema for a dataclass to store the results of a solver.
         */
        SolverResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Scalarization Values
             * @description The scalarization function values of the problem.
             */
            scalarization_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Success
             * @description A boolean flag indicating whether the optimization was successful or not.
             */
            success: boolean;
            /**
             * Message
             * @description Description of the cause of termination.
             */
            message: string;
        };
        Tensor: components["schemas"]["Tensor"][] | (number | boolean)[] | number | boolean | "List" | null;
        /**
         * TensorConstantDB
         * @description The SQLModel equivalent to `TensorConstant`.
         */
        TensorConstantDB: {
            values: components["schemas"]["Tensor"];
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the tensor representing the values. E.g., 'distances'
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * TensorVariableDB
         * @description The SQLModel equivalent to `TensorVariable`.
         */
        TensorVariableDB: {
            initial_values: components["schemas"]["Tensor"] | null;
            lowerbounds: components["schemas"]["Tensor"] | null;
            upperbounds: components["schemas"]["Tensor"] | null;
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer, or binary. Note that each element of a TensorVariable is assumed to be of the same type. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * Tokens
         * @description A model for the authentication token.
         */
        Tokens: {
            /** Access Token */
            access_token: string;
            /** Refresh Token */
            refresh_token: string;
            /** Token Type */
            token_type: string;
        };
        /**
         * UserPublic
         * @description The object to handle public user information.
         */
        UserPublic: {
            /** Username */
            username: string;
            /** Id */
            id: number;
            role: components["schemas"]["UserRole"];
            /** Group */
            group: string;
        };
        /**
         * UserRole
         * @description Possible user roles.
         * @enum {string}
         */
        UserRole: "guest" | "dm" | "analyst" | "admin";
        /**
         * UserSavedSolverResults
         * @description Defines a schema for storing archived solutions.
         */
        UserSavedSolverResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Scalarization Values
             * @description The scalarization function values of the problem.
             */
            scalarization_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Success
             * @description A boolean flag indicating whether the optimization was successful or not.
             */
            success: boolean;
            /**
             * Message
             * @description Description of the cause of termination.
             */
            message: string;
            /**
             * Name
             * @description An optional name for the solution, useful for archiving purposes.
             */
            name?: string | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VariableDB
         * @description The SQLModel equivalent to `Variable`.
         */
        VariableDB: {
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer or binary. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /**
             * Lowerbound
             * @description Lower bound of the variable.
             */
            lowerbound?: number | null;
            /**
             * Upperbound
             * @description Upper bound of the variable.
             */
            upperbound?: number | null;
            /**
             * Initial Value
             * @description Initial value of the variable. This is optional.
             */
            initial_value?: number | null;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * VariableDomainTypeEnum
         * @description An enumerator for the possible variable type domains of a problem.
         * @enum {string}
         */
        VariableDomainTypeEnum: "continuous" | "binary" | "integer" | "mixed";
        /**
         * VariableTypeEnum
         * @description An enumerator for possible variable types.
         * @enum {string}
         */
        VariableTypeEnum: "real" | "integer" | "binary";
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_current_user_info_user_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserPublic"];
                };
            };
        };
    };
    login_login_post: {
        parameters: {
            query?: {
                cookie_max_age?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_login_login_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Tokens"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    logout_logout_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    refresh_access_token_refresh_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: {
                refresh_token?: string | null;
            };
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_dm_add_new_dm_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_dm_add_new_dm_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_analyst_add_new_analyst_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_analyst_add_new_analyst_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_problems_problem_all_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfoSmall"][];
                };
            };
        };
    };
    get_problems_info_problem_all_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"][];
                };
            };
        };
    };
    get_problem_problem_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemGetRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_problem_problem_add_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
        };
    };
    create_new_session_session_new_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_session_session_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_rpm_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RPMSolveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RPMState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_nimbus_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSClassificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSClassificationState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    save_method_nimbus_save_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSSaveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSSaveState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_intermediate_method_generic_intermediate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IntermediateSolutionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IntermediateSolutionState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
