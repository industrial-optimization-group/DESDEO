/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/user_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current User Info
         * @description Return information about the current user.
         *
         *     Args:
         *         user (Annotated[User, Depends): user dependency, handled by `get_current_user`.
         *
         *     Returns:
         *         UserPublic: public information about the current user.
         */
        get: operations["get_current_user_info_user_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login
         * @description Login to get an authentication token.
         *
         *     Return an access token in the response and a cookie storing a refresh token.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
         *             The form data to authenticate the user.
         *         session (Annotated[Session, Depends(get_db)]): The database session.
         *         cookie_max_age (int): the lifetime of the cookie storing the refresh token.
         */
        post: operations["login_login_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description Log the current user out. Deletes the refresh token that was set by logging in.
         *
         *     Args:
         *         None
         *
         *     Returns:
         *         JSONResponse: A response in which the cookies are deleted
         */
        post: operations["logout_logout_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Access Token
         * @description Refresh the access token using the refresh token stored in the cookie.
         *
         *     Args:
         *         request (Request): The request containing the cookie.
         *         session (Annotated[Session, Depends(get_db)]): the database session.
         *         refresh_token (Annotated[Str | None, Cookie()]): the refresh
         *             token, which is fetched from a cookie included in the response.
         *
         *     Returns:
         *         dict: A dictionary containing the new access token.
         */
        post: operations["refresh_access_token_refresh_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_dm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Dm
         * @description Add a new user of the role Decision Maker to the database. Requires no login.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_dm_add_new_dm_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_analyst": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Analyst
         * @description Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin
         *
         *     Args:
         *         user Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if the logged in user is not an analyst or an admin or if
         *         username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_analyst_add_new_analyst_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems
         * @description Get information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfoSmall]: a list of information on all the problems.
         */
        get: operations["get_problems_problem_all_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems Info
         * @description Get detailed information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfo]: a list of the detailed information on all the problems.
         */
        get: operations["get_problems_info_problem_all_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Problem
         * @description Get the model of a specific problem.
         *
         *     Args:
         *         request (ProblemGetRequest): the request containing the problem's id `problem_id`.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find a problem with the given id.
         *
         *     Returns:
         *         ProblemInfo: detailed information on the requested problem.
         */
        post: operations["get_problem_problem_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/add": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Problem
         * @description Add a newly defined problem to the database.
         *
         *     Args:
         *         request (Problem): the JSON representation of the problem.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Note:
         *         Users with the role 'guest' may not add new problems.
         *
         *     Raises:
         *         HTTPException: when any issue with defining the problem arises.
         *
         *     Returns:
         *         ProblemInfo: the information about the problem added.
         */
        post: operations["add_problem_problem_add_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/get_metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Metadata
         * @description Fetch specific metadata for a specific problem. See all the possible metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata section.
         *
         *     Args:
         *         request (MetaDataGetRequest): requesting certain problem's certain metadata
         *         user (Annotated[User, Depends]): the current user
         *         session (Annotated[Session, Depends]): the database session
         *
         *     Returns:
         *         list[Any] | None: list of all forest metadata for this problem, or nothing if there's nothing
         */
        post: operations["get_metadata_problem_get_metadata_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/new": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create New Session
         * @description .
         */
        post: operations["create_new_session_session_new_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Session
         * @description Return an interactive session with a given id for the current user.
         *
         *     Args:
         *         request (GetSessionRequest): a request containing the id of the session.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find an interactive session with the given id
         *             for the current user.
         *
         *     Returns:
         *         InteractiveSessionInfo: info on the requested interactive session.
         */
        post: operations["get_session_session_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/rpm/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description .
         */
        post: operations["solve_solutions_method_rpm_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description Solve the problem using the NIMBUS method.
         */
        post: operations["solve_solutions_method_nimbus_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initialize
         * @description Initialize the problem for the NIMBUS method.
         */
        post: operations["initialize_method_nimbus_initialize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Save
         * @description Save solutions.
         */
        post: operations["save_method_nimbus_save_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/emo/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Emo Optimization
         * @description Start interactive evolutionary multiobjective optimization.
         */
        post: operations["start_emo_optimization_method_emo_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/emo/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Save
         * @description Save solutions.
         */
        post: operations["save_method_emo_save_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/emo/saved-solutions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Saved Solutions
         * @description Get all saved solutions for the current user.
         */
        get: operations["get_saved_solutions_method_emo_saved_solutions_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/generic/intermediate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Intermediate
         * @description Solve intermediate solutions between given two solutions.
         */
        post: operations["solve_intermediate_method_generic_intermediate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utopia/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Utopia Data
         * @description Request and receive the Utopia map corresponding to the decision variables sent. Can be just the optimal_variables form a SolverResult
         *
         *     Args:
         *         request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested for.
         *         user (Annotated[User, Depend(get_current_user)]) the current user
         *         session (Annotated[Session, Depends(get_session)]) the current database session
         *
         *     Raises:
         *         HTTPException:
         *
         *     Returns:
         *         UtopiaResponse: the map for the forest, to be rendered in frontend
         */
        post: operations["get_utopia_data_utopia__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * BaseProblemMetaData
         * @description Derive other problem metadata classes from this one.
         */
        BaseProblemMetaData: {
            /**
             * Metadata Type
             * @default unset
             */
            metadata_type: string;
        };
        /** Body_add_new_analyst_add_new_analyst_post */
        Body_add_new_analyst_add_new_analyst_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /** Body_add_new_dm_add_new_dm_post */
        Body_add_new_dm_add_new_dm_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /** Body_login_login_post */
        Body_login_login_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /**
         * ConstantDB
         * @description The SQLModel equivalent to `Constant`.
         */
        ConstantDB: {
            /**
             * Name
             * @description Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'.
             */
            symbol: string;
            /**
             * Value
             * @description The value of the constant.
             */
            value: number;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintDB
         * @description The SQLModel equivalent to `Constraint`.
         */
        ConstraintDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'.
             */
            symbol: string;
            /** @description The type of the constraint. Constraints are assumed to be in a standard form where the supplied 'func' expression is on the left hand side of the constraint's expression, and on the right hand side a zero value is assume. The comparison between the left hand side and right hand side is either and quality comparison ('=') or lesser than equal comparison ('<='). */
            cons_type: components["schemas"]["ConstraintTypeEnum"];
            /**
             * Is Linear
             * @description Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.
             * @default true
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintTypeEnum
         * @description An enumerator for supported constraint expression types.
         * @enum {string}
         */
        ConstraintTypeEnum: "=" | "<=";
        /**
         * CreateSessionRequest
         * @description Model of the request to create a new session.
         */
        CreateSessionRequest: {
            /** Info */
            info?: string | null;
        };
        /**
         * DiscreteRepresentationDB
         * @description The SQLModel equivalent to `DiscreteRepresentation`.
         */
        DiscreteRepresentationDB: {
            /**
             * Non Dominated
             * @default false
             */
            non_dominated: boolean;
            /** Variable Values */
            variable_values: {
                [key: string]: (number | boolean)[];
            };
            /** Objective Values */
            objective_values: {
                [key: string]: number[];
            };
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * EMOResults
         * @description Defines a schema for storing results of an evolutionary multi-objective optimization (EMO) solver.
         */
        EMOResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
        };
        /**
         * EMOSaveRequest
         * @description Request model for saving selected EMO solutions.
         */
        EMOSaveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /**
             * Solutions
             * @description List of EMO solutions to save with optional names
             */
            solutions: components["schemas"]["UserSavedEMOResults"][];
        };
        /**
         * EMOSaveState
         * @description State of the EMO methods for saving solutions.
         */
        EMOSaveState: {
            /**
             * Method
             * @description The EMO method name (e.g., NSGA3, RVEA, etc.)
             * @default EMO
             */
            method: string;
            /**
             * Phase
             * @default save_solutions
             * @constant
             */
            phase: "save_solutions";
            /**
             * Max Evaluations
             * @default 1000
             */
            max_evaluations: number;
            /**
             * Number Of Vectors
             * @default 20
             */
            number_of_vectors: number;
            /**
             * Use Archive
             * @default true
             */
            use_archive: boolean;
            /** Problem Id */
            problem_id: number;
            /** Saved Solutions */
            saved_solutions: components["schemas"]["EMOResults"][];
            /**
             * Solutions
             * @description Original solutions from request
             */
            solutions?: unknown[];
        };
        /**
         * EMOSolveRequest
         * @description Request model for starting EMO optimization.
         */
        EMOSolveRequest: {
            /** Problem Id */
            problem_id: number;
            /**
             * Method
             * @description EMO method: 'NSGA3' or 'RVEA'
             * @default NSGA3
             */
            method: string;
            /**
             * Max Evaluations
             * @description Maximum number of function evaluations
             * @default 50000
             */
            max_evaluations: number;
            /**
             * Number Of Vectors
             * @description Number of reference vectors
             * @default 30
             */
            number_of_vectors: number;
            /**
             * Use Archive
             * @description Whether to use solution archive
             * @default true
             */
            use_archive: boolean;
            /**
             * Preference
             * @description Preference information for interactive adaptation
             */
            preference: components["schemas"]["ReferencePoint"] | components["schemas"]["PreferedSolutions"] | components["schemas"]["NonPreferredSolutions"] | components["schemas"]["PreferredRanges"];
            /**
             * Session Id
             * @description Interactive session ID
             */
            session_id?: number | null;
            /**
             * Parent State Id
             * @description Parent state ID for continuation
             */
            parent_state_id?: number | null;
        };
        /**
         * EMOState
         * @description State for EMO methods.
         */
        EMOState: {
            /**
             * Method
             * @description The EMO method name (e.g., NSGA3, RVEA, etc.)
             * @default EMO
             */
            method: string;
            /**
             * Phase
             * @default unset
             * @constant
             */
            phase: "unset";
            /**
             * Max Evaluations
             * @default 1000
             */
            max_evaluations: number;
            /**
             * Number Of Vectors
             * @default 20
             */
            number_of_vectors: number;
            /**
             * Use Archive
             * @default true
             */
            use_archive: boolean;
            /**
             * Solutions
             * @description Optimization results
             */
            solutions: unknown[];
            /**
             * Outputs
             * @description Optimization results
             */
            outputs: unknown[];
        };
        /**
         * ExtraFunctionDB
         * @description The SQLModel equivalent to `ExtraFunction`.
         */
        ExtraFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the function. Example: 'normalization'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'.
             */
            symbol: string;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * GetSessionRequest
         * @description Model of the request to get a specific session.
         */
        GetSessionRequest: {
            /** Session Id */
            session_id: number;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * InteractiveSessionBase
         * @description The base model for representing interactive sessions.
         */
        InteractiveSessionBase: {
            /** Id */
            id: number | null;
            /** User Id */
            user_id: number | null;
            /** Info */
            info: string | null;
        };
        /**
         * IntermediateSolutionRequest
         * @description Model of the request to solve intermediate solutions between two solutions.
         */
        IntermediateSolutionRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            /** Reference Solution 1 */
            reference_solution_1: {
                [key: string]: number;
            };
            /** Reference Solution 2 */
            reference_solution_2: {
                [key: string]: number;
            };
        };
        /**
         * IntermediateSolutionState
         * @description State of the nimbus method for computing solutions.
         */
        IntermediateSolutionState: {
            /**
             * Method
             * @default generic
             * @constant
             */
            method: "generic";
            /**
             * Phase
             * @default solve_intermediate
             * @constant
             */
            phase: "solve_intermediate";
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            /** Reference Solution 1 */
            reference_solution_1: {
                [key: string]: number;
            };
            /** Reference Solution 2 */
            reference_solution_2: {
                [key: string]: number;
            };
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * NIMBUSClassificationRequest
         * @description Model of the request to the nimbus method.
         */
        NIMBUSClassificationRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
            /** Current Objectives */
            current_objectives: {
                [key: string]: number;
            };
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
        };
        /**
         * NIMBUSClassificationState
         * @description State of the nimbus method for computing solutions.
         */
        NIMBUSClassificationState: {
            /**
             * Method
             * @default nimbus
             * @constant
             */
            method: "nimbus";
            /**
             * Phase
             * @default solve_candidates
             * @constant
             */
            phase: "solve_candidates";
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Current Objectives */
            current_objectives: {
                [key: string]: number;
            };
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            previous_preference?: components["schemas"]["ReferencePoint"];
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * NIMBUSInitializationRequest
         * @description Model of the request to the nimbus method.
         */
        NIMBUSInitializationRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Solver */
            solver?: string | null;
        };
        /**
         * NIMBUSInitializationState
         * @description State of the nimbus method for computing solutions.
         */
        NIMBUSInitializationState: {
            /**
             * Method
             * @default nimbus
             * @constant
             */
            method: "nimbus";
            /**
             * Phase
             * @default initialize
             * @constant
             */
            phase: "initialize";
            /** Solver */
            solver?: string | null;
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * NIMBUSSaveRequest
         * @description Request model for saving solutions from any method's state.
         */
        NIMBUSSaveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Solutions */
            solutions: components["schemas"]["UserSavedSolverResults"][];
        };
        /**
         * NIMBUSSaveState
         * @description State of the nimbus method for saving solutions.
         */
        NIMBUSSaveState: {
            /**
             * Method
             * @default nimbus
             * @constant
             */
            method: "nimbus";
            /**
             * Phase
             * @default save_solutions
             * @constant
             */
            phase: "save_solutions";
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * NonPreferredSolutions
         * @description Model for representing a non-preferred solution type of preference.
         */
        NonPreferredSolutions: {
            /**
             * Preference Type
             * @default non_preferred_solutions
             * @constant
             */
            preference_type: "non_preferred_solutions";
            /** Non Preferred Solutions */
            non_preferred_solutions: {
                [key: string]: number[];
            };
        };
        /**
         * ObjectiveDB
         * @description The SQLModel equivalent to `Objective`.
         */
        ObjectiveDB: {
            /** Func */
            func: unknown[] | null;
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'.
             */
            symbol: string;
            /**
             * Unit
             * @description The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'.
             */
            unit?: string | null;
            /**
             * Maximize
             * @description Whether the objective function is to be maximized or minimized.
             * @default false
             */
            maximize: boolean;
            /**
             * Ideal
             * @description Ideal value of the objective. This is optional.
             */
            ideal?: number | null;
            /**
             * Nadir
             * @description Nadir value of the objective. This is optional.
             */
            nadir?: number | null;
            /**
             * @description The type of objective function. 'analytical' means the objective function value is calculated based on 'func'. 'data_based' means the objective function value should be retrieved from a table. In case of 'data_based' objective function, the 'func' field is ignored. Defaults to 'analytical'.
             * @default analytical
             */
            objective_type: components["schemas"]["ObjectiveTypeEnum"];
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ObjectiveTypeEnum
         * @description An enumerator for supported objective function types.
         * @enum {string}
         */
        ObjectiveTypeEnum: "analytical" | "data_based" | "simulator" | "surrogate";
        /**
         * PreferedSolutions
         * @description Model for representing a preferred solution type of preference.
         */
        PreferedSolutions: {
            /**
             * Preference Type
             * @default preferred_solutions
             * @constant
             */
            preference_type: "preferred_solutions";
            /** Preferred Solutions */
            preferred_solutions: {
                [key: string]: number[];
            };
        };
        /**
         * PreferredRanges
         * @description Model for representing desired upper and lower bounds for objective functions.
         */
        PreferredRanges: {
            /**
             * Preference Type
             * @default preferred_ranges
             * @constant
             */
            preference_type: "preferred_ranges";
            /** Preferred Ranges */
            preferred_ranges: {
                [key: string]: number[];
            };
        };
        /**
         * ProblemGetRequest
         * @description Model to deal with problem fetching requests.
         */
        ProblemGetRequest: {
            /** Problem Id */
            problem_id: number;
        };
        /**
         * ProblemInfo
         * @description .
         */
        ProblemInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
            /** Constants */
            constants: components["schemas"]["ConstantDB"][] | null;
            /** Tensor Constants */
            tensor_constants: components["schemas"]["TensorConstantDB"][] | null;
            /** Variables */
            variables: components["schemas"]["VariableDB"][] | null;
            /** Tensor Variables */
            tensor_variables: components["schemas"]["TensorVariableDB"][] | null;
            /** Objectives */
            objectives: components["schemas"]["ObjectiveDB"][];
            /** Constraints */
            constraints: components["schemas"]["ConstraintDB"][] | null;
            /** Scalarization Funcs */
            scalarization_funcs: components["schemas"]["ScalarizationFunctionDB"][] | null;
            /** Extra Funcs */
            extra_funcs: components["schemas"]["ExtraFunctionDB"][] | null;
            discrete_representation: components["schemas"]["DiscreteRepresentationDB"] | null;
            /** Simulators */
            simulators: components["schemas"]["SimulatorDB"][] | null;
            problem_metadata: components["schemas"]["ProblemMetaDataPublic"] | null;
        };
        /**
         * ProblemInfoSmall
         * @description .
         */
        ProblemInfoSmall: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
            problem_metadata: components["schemas"]["ProblemMetaDataPublic"] | null;
        };
        /**
         * ProblemMetaDataGetRequest
         * @description Request model for getting specific type of metadata from a specific problem.
         */
        ProblemMetaDataGetRequest: {
            /** Problem Id */
            problem_id: number;
            /** Metadata Type */
            metadata_type: string;
        };
        /**
         * ProblemMetaDataPublic
         * @description Response model for ProblemMetaData.
         */
        ProblemMetaDataPublic: {
            /** Data */
            data: components["schemas"]["BaseProblemMetaData"][] | null;
        };
        /**
         * RPMSolveRequest
         * @description Model of the request to the reference point method.
         */
        RPMSolveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
        };
        /**
         * RPMState
         * @description State of the reference point method for computing solutions.
         */
        RPMState: {
            /**
             * Method
             * @default reference_point_method
             * @constant
             */
            method: "reference_point_method";
            /**
             * Phase
             * @default solve_candidates
             * @constant
             */
            phase: "solve_candidates";
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * ReferencePoint
         * @description Model for representing a reference point type of preference.
         */
        ReferencePoint: {
            /**
             * Preference Type
             * @default reference_point
             * @constant
             */
            preference_type: "reference_point";
            /** Aspiration Levels */
            aspiration_levels: {
                [key: string]: number;
            };
        };
        /**
         * ScalarizationFunctionDB
         * @description The SQLModel equivalent to `ScalarizationFunction`.
         */
        ScalarizationFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys: string[];
            /**
             * Name
             * @description Name of the scalarization function.
             */
            name: string;
            /**
             * Symbol
             * @description Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.
             */
            symbol?: string | null;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * SimulatorDB
         * @description The SQLModel equivalent to `Simulator`.
         */
        SimulatorDB: {
            /** File */
            file?: string | null;
            url?: components["schemas"]["Url"] | null;
            /** Parameter Options */
            parameter_options?: {
                [key: string]: unknown;
            } | null;
            /**
             * Name
             * @description Descriptive name of the simulator. This can be used in UI and visualizations.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * SolverResults
         * @description Defines a schema for a dataclass to store the results of a solver.
         */
        SolverResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Scalarization Values
             * @description The scalarization function values of the problem.
             */
            scalarization_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Success
             * @description A boolean flag indicating whether the optimization was successful or not.
             */
            success: boolean;
            /**
             * Message
             * @description Description of the cause of termination.
             */
            message: string;
        };
        Tensor: components["schemas"]["Tensor"][] | (number | boolean)[] | number | boolean | "List" | null;
        /**
         * TensorConstantDB
         * @description The SQLModel equivalent to `TensorConstant`.
         */
        TensorConstantDB: {
            values: components["schemas"]["Tensor"];
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the tensor representing the values. E.g., 'distances'
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * TensorVariableDB
         * @description The SQLModel equivalent to `TensorVariable`.
         */
        TensorVariableDB: {
            initial_values: components["schemas"]["Tensor"] | null;
            lowerbounds: components["schemas"]["Tensor"] | null;
            upperbounds: components["schemas"]["Tensor"] | null;
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer, or binary. Note that each element of a TensorVariable is assumed to be of the same type. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * Tokens
         * @description A model for the authentication token.
         */
        Tokens: {
            /** Access Token */
            access_token: string;
            /** Refresh Token */
            refresh_token: string;
            /** Token Type */
            token_type: string;
        };
        /**
         * Url
         * @description Model for a URL.
         */
        Url: {
            /**
             * Url
             * @description A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.
             */
            url: string;
            /**
             * Auth
             * @description Optional. A tuple of username and password to be used for authentication when making requests to the URL.
             */
            auth?: [
                string,
                string
            ] | null;
        };
        /**
         * UserPublic
         * @description The object to handle public user information.
         */
        UserPublic: {
            /** Username */
            username: string;
            /** Id */
            id: number;
            role: components["schemas"]["UserRole"];
            /** Group */
            group: string;
        };
        /**
         * UserRole
         * @description Possible user roles.
         * @enum {string}
         */
        UserRole: "guest" | "dm" | "analyst" | "admin";
        /**
         * UserSavedEMOResults
         * @description Defines a schema for storing emo solutions.
         */
        UserSavedEMOResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Name
             * @description An optional name for the solution, useful for archiving purposes.
             */
            name?: string | null;
        };
        /**
         * UserSavedSolverResults
         * @description Defines a schema for storing archived solutions.
         */
        UserSavedSolverResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Scalarization Values
             * @description The scalarization function values of the problem.
             */
            scalarization_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Success
             * @description A boolean flag indicating whether the optimization was successful or not.
             */
            success: boolean;
            /**
             * Message
             * @description Description of the cause of termination.
             */
            message: string;
            /**
             * Name
             * @description An optional name for the solution, useful for archiving purposes.
             */
            name?: string | null;
        };
        /**
         * UtopiaRequest
         * @description The request for an Utopia map.
         */
        UtopiaRequest: {
            /**
             * Problem Id
             * @description Problem for which the map is generated
             */
            problem_id: number;
            /**
             * Decision Variables
             * @description Decision variables with which to generate the map
             */
            decision_variables: {
                [key: string]: number | unknown[];
            };
        };
        /**
         * UtopiaResponse
         * @description The response to an UtopiaRequest.
         */
        UtopiaResponse: {
            /**
             * Is Utopia
             * @description True if map exists for this problem.
             */
            is_utopia: boolean;
            /**
             * Map Name
             * @description Name of the map.
             */
            map_name: string;
            /**
             * Map Json
             * @description MapJSON representation of the geography.
             */
            map_json: {
                [key: string]: unknown;
            };
            /**
             * Options
             * @description A dict with given years as keys containing options for each year.
             */
            options: {
                [key: string]: unknown;
            };
            /**
             * Description
             * @description Description shown above the map.
             */
            description: string;
            /**
             * Years
             * @description A list of years for which the maps have been generated.
             */
            years: string[];
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VariableDB
         * @description The SQLModel equivalent to `Variable`.
         */
        VariableDB: {
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer or binary. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /**
             * Lowerbound
             * @description Lower bound of the variable.
             */
            lowerbound?: number | null;
            /**
             * Upperbound
             * @description Upper bound of the variable.
             */
            upperbound?: number | null;
            /**
             * Initial Value
             * @description Initial value of the variable. This is optional.
             */
            initial_value?: number | null;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * VariableDomainTypeEnum
         * @description An enumerator for the possible variable type domains of a problem.
         * @enum {string}
         */
        VariableDomainTypeEnum: "continuous" | "binary" | "integer" | "mixed";
        /**
         * VariableTypeEnum
         * @description An enumerator for possible variable types.
         * @enum {string}
         */
        VariableTypeEnum: "real" | "integer" | "binary";
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_current_user_info_user_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserPublic"];
                };
            };
        };
    };
    login_login_post: {
        parameters: {
            query?: {
                cookie_max_age?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_login_login_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Tokens"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    logout_logout_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    refresh_access_token_refresh_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: {
                refresh_token?: string | null;
            };
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_dm_add_new_dm_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_dm_add_new_dm_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_analyst_add_new_analyst_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_analyst_add_new_analyst_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_problems_problem_all_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfoSmall"][];
                };
            };
        };
    };
    get_problems_info_problem_all_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"][];
                };
            };
        };
    };
    get_problem_problem_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemGetRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_problem_problem_add_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
        };
    };
    get_metadata_problem_get_metadata_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemMetaDataGetRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown[];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_new_session_session_new_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_session_session_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_rpm_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RPMSolveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RPMState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_nimbus_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSClassificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSClassificationState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    initialize_method_nimbus_initialize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSInitializationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSInitializationState"] | components["schemas"]["NIMBUSClassificationState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    save_method_nimbus_save_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSSaveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSSaveState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    start_emo_optimization_method_emo_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EMOSolveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EMOState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    save_method_emo_save_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EMOSaveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EMOSaveState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_saved_solutions_method_emo_saved_solutions_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    solve_intermediate_method_generic_intermediate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IntermediateSolutionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IntermediateSolutionState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_utopia_data_utopia__post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UtopiaRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UtopiaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
