/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/user_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current User Info
         * @description Return information about the current user.
         *
         *     Args:
         *         user (Annotated[User, Depends): user dependency, handled by `get_current_user`.
         *
         *     Returns:
         *         UserPublic: public information about the current user.
         */
        get: operations["get_current_user_info_user_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login
         * @description Login to get an authentication token.
         *
         *     Return an access token in the response and a cookie storing a refresh token.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
         *             The form data to authenticate the user.
         *         session (Annotated[Session, Depends(get_db)]): The database session.
         *         cookie_max_age (int): the lifetime of the cookie storing the refresh token.
         */
        post: operations["login_login_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description Log the current user out. Deletes the refresh token that was set by logging in.
         *
         *     Args:
         *         None
         *
         *     Returns:
         *         JSONResponse: A response in which the cookies are deleted
         */
        post: operations["logout_logout_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Access Token
         * @description Refresh the access token using the refresh token stored in the cookie.
         *
         *     Args:
         *         request (Request): The request containing the cookie.
         *         session (Annotated[Session, Depends(get_db)]): the database session.
         *         refresh_token (Annotated[Str | None, Cookie()]): the refresh
         *             token, which is fetched from a cookie included in the response.
         *
         *     Returns:
         *         dict: A dictionary containing the new access token.
         */
        post: operations["refresh_access_token_refresh_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_dm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Dm
         * @description Add a new user of the role Decision Maker to the database. Requires no login.
         *
         *     Args:
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_dm_add_new_dm_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/add_new_analyst": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add New Analyst
         * @description Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin
         *
         *     Args:
         *         user Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
         *         form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
         *         session (Annotated[Session, Depends(get_session)]): the database session.
         *
         *     Returns:
         *         JSONResponse: A JSON response
         *
         *     Raises:
         *         HTTPException: if the logged in user is not an analyst or an admin or if
         *         username is already in use or if saving to the database fails for some reason.
         */
        post: operations["add_new_analyst_add_new_analyst_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems
         * @description Get information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfoSmall]: a list of information on all the problems.
         */
        get: operations["get_problems_problem_all_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/all_info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Problems Info
         * @description Get detailed information on all the current user's problems.
         *
         *     Args:
         *         user (Annotated[User, Depends): the current user.
         *
         *     Returns:
         *         list[ProblemInfo]: a list of the detailed information on all the problems.
         */
        get: operations["get_problems_info_problem_all_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Problem
         * @description Get the model of a specific problem.
         *
         *     Args:
         *         request (ProblemGetRequest): the request containing the problem's id `problem_id`.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find a problem with the given id.
         *
         *     Returns:
         *         ProblemInfo: detailed information on the requested problem.
         */
        post: operations["get_problem_problem_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/add": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Problem
         * @description Add a newly defined problem to the database.
         *
         *     Args:
         *         request (Problem): the JSON representation of the problem.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Note:
         *         Users with the role 'guest' may not add new problems.
         *
         *     Raises:
         *         HTTPException: when any issue with defining the problem arises.
         *
         *     Returns:
         *         ProblemInfo: the information about the problem added.
         */
        post: operations["add_problem_problem_add_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/problem/get_metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Metadata
         * @description Fetch specific metadata for a specific problem.
         *
         *     Fetch specific metadata for a specific problem. See all the possible
         *     metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata
         *     section.
         *
         *     Args:
         *         request (MetaDataGetRequest): the requested metadata type.
         *         user (Annotated[User, Depends]): the current user.
         *         session (Annotated[Session, Depends]): the database session.
         *
         *     Returns:
         *         list[ForestProblemMetadata | RepresentativeNonDominatedSolutions]: list containing all the metadata
         *             defined for the problem with the requested metadata type. If no match is found,
         *             returns an empty list.
         */
        post: operations["get_metadata_problem_get_metadata_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/new": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create New Session
         * @description .
         */
        post: operations["create_new_session_session_new_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Session
         * @description Return an interactive session with a given id for the current user.
         *
         *     Args:
         *         request (GetSessionRequest): a request containing the id of the session.
         *         user (Annotated[User, Depends): the current user.
         *         session (Annotated[Session, Depends): the database session.
         *
         *     Raises:
         *         HTTPException: could not find an interactive session with the given id
         *             for the current user.
         *
         *     Returns:
         *         InteractiveSessionInfo: info on the requested interactive session.
         */
        post: operations["get_session_session_get_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/rpm/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description .
         */
        post: operations["solve_solutions_method_rpm_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/solve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Solutions
         * @description Solve the problem using the NIMBUS method.
         */
        post: operations["solve_solutions_method_nimbus_solve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initialize
         * @description Initialize the problem for the NIMBUS method.
         */
        post: operations["initialize_method_nimbus_initialize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Save
         * @description Save solutions.
         */
        post: operations["save_method_nimbus_save_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/intermediate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Nimbus Intermediate
         * @description Solve intermediate solutions by forwarding the request to generic intermediate endpoint with context nimbus.
         */
        post: operations["solve_nimbus_intermediate_method_nimbus_intermediate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/nimbus/get-or-initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Or Initialize
         * @description Get the latest NIMBUS state if it exists, or initialize a new one if it doesn't.
         */
        post: operations["get_or_initialize_method_nimbus_get_or_initialize_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/generic/intermediate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Solve Intermediate
         * @description Solve intermediate solutions between given two solutions.
         */
        post: operations["solve_intermediate_method_generic_intermediate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/method/generic/score-bands": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Calculate Score Bands
         * @description Calculate SCORE bands parameters from objective data.
         */
        post: operations["calculate_score_bands_method_generic_score_bands_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utopia/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Utopia Data
         * @description Request and receive the Utopia map corresponding to the decision variables sent. Can be just the optimal_variables form a SolverResult.
         *
         *     Args:
         *         request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested for.
         *         user (Annotated[User, Depend(get_current_user)]) the current user
         *         session (Annotated[Session, Depends(get_session)]) the current database session
         *     Raises:
         *         HTTPException:
         *     Returns:
         *         UtopiaResponse: the map for the forest, to be rendered in frontend
         */
        post: operations["get_utopia_data_utopia__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Body_add_new_analyst_add_new_analyst_post */
        Body_add_new_analyst_add_new_analyst_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /** Body_add_new_dm_add_new_dm_post */
        Body_add_new_dm_add_new_dm_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /** Body_login_login_post */
        Body_login_login_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /**
         * ConstantDB
         * @description The SQLModel equivalent to `Constant`.
         */
        ConstantDB: {
            /**
             * Name
             * @description Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'.
             */
            symbol: string;
            /**
             * Value
             * @description The value of the constant.
             */
            value: number;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintDB
         * @description The SQLModel equivalent to `Constraint`.
         */
        ConstraintDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'.
             */
            symbol: string;
            /** @description The type of the constraint. Constraints are assumed to be in a standard form where the supplied 'func' expression is on the left hand side of the constraint's expression, and on the right hand side a zero value is assume. The comparison between the left hand side and right hand side is either and quality comparison ('=') or lesser than equal comparison ('<='). */
            cons_type: components["schemas"]["ConstraintTypeEnum"];
            /**
             * Is Linear
             * @description Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.
             * @default true
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ConstraintTypeEnum
         * @description An enumerator for supported constraint expression types.
         * @enum {string}
         */
        ConstraintTypeEnum: "=" | "<=";
        /**
         * CreateSessionRequest
         * @description Model of the request to create a new session.
         */
        CreateSessionRequest: {
            /** Info */
            info?: string | null;
        };
        /**
         * DiscreteRepresentationDB
         * @description The SQLModel equivalent to `DiscreteRepresentation`.
         */
        DiscreteRepresentationDB: {
            /**
             * Non Dominated
             * @default false
             */
            non_dominated: boolean;
            /** Variable Values */
            variable_values: {
                [key: string]: (number | boolean)[];
            };
            /** Objective Values */
            objective_values: {
                [key: string]: number[];
            };
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ExtraFunctionDB
         * @description The SQLModel equivalent to `ExtraFunction`.
         */
        ExtraFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the function. Example: 'normalization'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'.
             */
            symbol: string;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ForestProblemMetaData
         * @description A problem metadata class to hold UTOPIA forest problem specific information.
         */
        ForestProblemMetaData: {
            /** Id */
            id?: number | null;
            /** Metadata Id */
            metadata_id?: number | null;
            /**
             * Metadata Type
             * @default forest_problem_metadata
             */
            metadata_type: string;
            /** Map Json */
            map_json: string;
            /** Schedule Dict */
            schedule_dict: {
                [key: string]: unknown;
            };
            /** Years */
            years: string[];
            /** Stand Id Field */
            stand_id_field: string;
            /** Stand Descriptor */
            stand_descriptor?: {
                [key: string]: unknown;
            } | null;
            /** Compensation */
            compensation?: number | null;
        };
        /**
         * GenericIntermediateSolutionResponse
         * @description The response from computing intermediate values.
         */
        GenericIntermediateSolutionResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /** @description The first solution used when computing intermediate solutions. */
            reference_solution_1: components["schemas"]["SolutionReferenceResponse"];
            /** @description The second solution used when computing intermediate solutions. */
            reference_solution_2: components["schemas"]["SolutionReferenceResponse"];
            /**
             * Intermediate Solutions
             * @description The intermediate solutions computed.
             */
            intermediate_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * GetSessionRequest
         * @description Model of the request to get a specific session.
         */
        GetSessionRequest: {
            /** Session Id */
            session_id: number;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * InteractiveSessionBase
         * @description The base model for representing interactive sessions.
         */
        InteractiveSessionBase: {
            /** Id */
            id: number | null;
            /** User Id */
            user_id: number | null;
            /** Info */
            info: string | null;
        };
        /**
         * IntermediateSolutionRequest
         * @description Model of the request to solve intermediate solutions between two solutions.
         */
        IntermediateSolutionRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Context */
            context?: string | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
            reference_solution_1: components["schemas"]["SolutionInfo"];
            reference_solution_2: components["schemas"]["SolutionInfo"];
        };
        /**
         * NIMBUSClassificationRequest
         * @description Model of the request to the nimbus method.
         */
        NIMBUSClassificationRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
            /**
             * Current Objectives
             * @description The objectives used for iteration.
             */
            current_objectives: {
                [key: string]: number;
            };
            /**
             * Num Desired
             * @default 1
             */
            num_desired: number | null;
        };
        /**
         * NIMBUSClassificationResponse
         * @description The response from NIMBUS classification endpoint.
         */
        NIMBUSClassificationResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /** @description The previous preference used. */
            previous_preference: components["schemas"]["ReferencePoint"];
            /**
             * Previous Objectives
             * @description The previous solutions objectives used for iteration.
             */
            previous_objectives: {
                [key: string]: number;
            };
            /**
             * Current Solutions
             * @description The solutions from the current iteration of nimbus.
             */
            current_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * Saved Solutions
             * @description The best candidate solutions saved by the decision maker.
             */
            saved_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * All Solutions
             * @description All solutions generated by NIMBUS in all iterations.
             */
            all_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * NIMBUSInitializationRequest
         * @description Model of the request to the nimbus method.
         */
        NIMBUSInitializationRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Starting Point */
            starting_point?: components["schemas"]["ReferencePoint"] | components["schemas"]["SolutionInfo"] | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
        };
        /**
         * NIMBUSInitializationResponse
         * @description The response from NIMBUS classification endpoint.
         */
        NIMBUSInitializationResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /**
             * Current Solutions
             * @description The solutions from the current interation of nimbus.
             */
            current_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * Saved Solutions
             * @description The best candidate solutions saved by the decision maker.
             */
            saved_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * All Solutions
             * @description All solutions generated by NIMBUS in all iterations.
             */
            all_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * NIMBUSIntermediateSolutionResponse
         * @description The response from NIMBUS classification endpoint.
         */
        NIMBUSIntermediateSolutionResponse: {
            /**
             * State Id
             * @description The newly created state id
             */
            state_id: number | null;
            /**
             * Reference Solution 1
             * @description The first solution used when computing intermediate points.
             */
            reference_solution_1: {
                [key: string]: number;
            };
            /**
             * Reference Solution 2
             * @description The second solution used when computing intermediate points.
             */
            reference_solution_2: {
                [key: string]: number;
            };
            /**
             * Current Solutions
             * @description The solutions from the current iteration of NIMBUS.
             */
            current_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * Saved Solutions
             * @description The best candidate solutions saved by the decision maker.
             */
            saved_solutions: components["schemas"]["SolutionReferenceResponse"][];
            /**
             * All Solutions
             * @description All solutions generated by NIMBUS in all iterations.
             */
            all_solutions: components["schemas"]["SolutionReferenceResponse"][];
        };
        /**
         * NIMBUSSaveRequest
         * @description Request model for saving solutions from any method's state.
         */
        NIMBUSSaveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Solution Info */
            solution_info: components["schemas"]["SolutionInfo"][];
        };
        /**
         * NIMBUSSaveResponse
         * @description The response from NIMBUS save endpoint.
         */
        NIMBUSSaveResponse: {
            /**
             * State Id
             * @description The id of the newest state
             */
            state_id: number | null;
        };
        /**
         * ObjectiveDB
         * @description The SQLModel equivalent to `Objective`.
         */
        ObjectiveDB: {
            /** Func */
            func: unknown[] | null;
            /** Scenario Keys */
            scenario_keys?: string[] | null;
            /** Surrogates */
            surrogates?: string[] | null;
            /** Simulator Path */
            simulator_path?: string | components["schemas"]["Url"] | null;
            /**
             * Name
             * @description Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'.
             */
            symbol: string;
            /**
             * Unit
             * @description The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'.
             */
            unit?: string | null;
            /**
             * Maximize
             * @description Whether the objective function is to be maximized or minimized.
             * @default false
             */
            maximize: boolean;
            /**
             * Ideal
             * @description Ideal value of the objective. This is optional.
             */
            ideal?: number | null;
            /**
             * Nadir
             * @description Nadir value of the objective. This is optional.
             */
            nadir?: number | null;
            /**
             * @description The type of objective function. 'analytical' means the objective function value is calculated based on 'func'. 'data_based' means the objective function value should be retrieved from a table. In case of 'data_based' objective function, the 'func' field is ignored. Defaults to 'analytical'.
             * @default analytical
             */
            objective_type: components["schemas"]["ObjectiveTypeEnum"];
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ObjectiveTypeEnum
         * @description An enumerator for supported objective function types.
         * @enum {string}
         */
        ObjectiveTypeEnum: "analytical" | "data_based" | "simulator" | "surrogate";
        /**
         * ProblemGetRequest
         * @description Model to deal with problem fetching requests.
         */
        ProblemGetRequest: {
            /** Problem Id */
            problem_id: number;
        };
        /**
         * ProblemInfo
         * @description Problem info request return data.
         */
        ProblemInfo: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
            /** Constants */
            constants: components["schemas"]["ConstantDB"][] | null;
            /** Tensor Constants */
            tensor_constants: components["schemas"]["TensorConstantDB"][] | null;
            /** Variables */
            variables: components["schemas"]["VariableDB"][] | null;
            /** Tensor Variables */
            tensor_variables: components["schemas"]["TensorVariableDB"][] | null;
            /** Objectives */
            objectives: components["schemas"]["ObjectiveDB"][];
            /** Constraints */
            constraints: components["schemas"]["ConstraintDB"][] | null;
            /** Scalarization Funcs */
            scalarization_funcs: components["schemas"]["ScalarizationFunctionDB"][] | null;
            /** Extra Funcs */
            extra_funcs: components["schemas"]["ExtraFunctionDB"][] | null;
            discrete_representation: components["schemas"]["DiscreteRepresentationDB"] | null;
            /** Simulators */
            simulators: components["schemas"]["SimulatorDB"][] | null;
            problem_metadata: components["schemas"]["ProblemMetaDataPublic"] | null;
        };
        /**
         * ProblemInfoSmall
         * @description Problem info request return data, but smaller.
         */
        ProblemInfoSmall: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Is Convex */
            is_convex: boolean | null;
            /** Is Linear */
            is_linear: boolean | null;
            /** Is Twice Differentiable */
            is_twice_differentiable: boolean | null;
            /** Scenario Keys */
            scenario_keys: string[] | null;
            variable_domain: components["schemas"]["VariableDomainTypeEnum"];
            /** Id */
            id: number;
            /** User Id */
            user_id: number;
            problem_metadata: components["schemas"]["ProblemMetaDataPublic"] | null;
        };
        /**
         * ProblemMetaDataGetRequest
         * @description Request model for getting specific type of metadata from a specific problem.
         */
        ProblemMetaDataGetRequest: {
            /** Problem Id */
            problem_id: number;
            /** Metadata Type */
            metadata_type: string;
        };
        /**
         * ProblemMetaDataPublic
         * @description Response model for ProblemMetaData.
         */
        ProblemMetaDataPublic: {
            /** Problem Id */
            problem_id: number;
            /** Forest Metadata */
            forest_metadata: components["schemas"]["ForestProblemMetaData"][] | null;
            /** Representative Nd Metadata */
            representative_nd_metadata: components["schemas"]["RepresentativeNonDominatedSolutions"][] | null;
        };
        /**
         * RPMSolveRequest
         * @description Model of the request to the reference point method.
         */
        RPMSolveRequest: {
            /** Problem Id */
            problem_id: number;
            /** Session Id */
            session_id?: number | null;
            /** Parent State Id */
            parent_state_id?: number | null;
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            preference?: components["schemas"]["ReferencePoint"];
        };
        /**
         * RPMState
         * @description Reference Point Method (k+1 candidates).
         */
        RPMState: {
            /** Id */
            id?: number | null;
            preferences: components["schemas"]["ReferencePoint"];
            /** Scalarization Options */
            scalarization_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver */
            solver?: string | null;
            /** Solver Options */
            solver_options?: {
                [key: string]: number | string | boolean;
            } | null;
            /** Solver Results */
            solver_results: components["schemas"]["SolverResults"][];
        };
        /**
         * ReferencePoint
         * @description Model for representing a reference point type of preference.
         */
        ReferencePoint: {
            /**
             * Preference Type
             * @default reference_point
             * @constant
             */
            preference_type: "reference_point";
            /** Aspiration Levels */
            aspiration_levels: {
                [key: string]: number;
            };
        };
        /**
         * RepresentativeNonDominatedSolutions
         * @description A problem metadata class to store representative solutions sets, i.e., non-dominated sets...
         *
         *     A problem metadata class to store representative solutions sets, i.e., non-dominated sets that
         *     represent/approximate the Pareto optimal solution set of the problem.
         *
         *     Note:
         *         It is assumed that the solution set is non-dominated.
         */
        RepresentativeNonDominatedSolutions: {
            /** Id */
            id?: number | null;
            /** Metadata Id */
            metadata_id?: number | null;
            /**
             * Metadata Type
             * @default representative_non_dominated_solutions
             */
            metadata_type: string;
            /**
             * Name
             * @description The name of the representative set.
             */
            name: string;
            /**
             * Description
             * @description A description of the representative set. Optional.
             */
            description?: string | null;
            /**
             * Solution Data
             * @description The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.
             */
            solution_data: {
                [key: string]: number[];
            };
            /**
             * Ideal
             * @description The ideal objective function values of the representative set.
             */
            ideal: {
                [key: string]: number;
            };
            /**
             * Nadir
             * @description The nadir objective function values of the representative set.
             */
            nadir: {
                [key: string]: number;
            };
        };
        /**
         * ScalarizationFunctionDB
         * @description The SQLModel equivalent to `ScalarizationFunction`.
         */
        ScalarizationFunctionDB: {
            /** Func */
            func: unknown[];
            /** Scenario Keys */
            scenario_keys: string[];
            /**
             * Name
             * @description Name of the scalarization function.
             */
            name: string;
            /**
             * Symbol
             * @description Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.
             */
            symbol?: string | null;
            /**
             * Is Linear
             * @description Whether the function expression is linear or not. Defaults to `False`.
             * @default false
             */
            is_linear: boolean;
            /**
             * Is Convex
             * @description Whether the function expression is convex or not (non-convex). Defaults to `False`.
             * @default false
             */
            is_convex: boolean;
            /**
             * Is Twice Differentiable
             * @description Whether the function expression is twice differentiable or not. Defaults to `False`
             * @default false
             */
            is_twice_differentiable: boolean;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * ScoreBandsRequest
         * @description Model of the request to calculate SCORE bands parameters.
         */
        ScoreBandsRequest: {
            /**
             * Data
             * @description Matrix of objective values
             */
            data: number[][];
            /**
             * Objs
             * @description Array of objective names for each column
             */
            objs: string[];
            /**
             * Dist Parameter
             * @description Distance parameter for axis positioning
             * @default 0.05
             */
            dist_parameter: number;
            /**
             * Use Absolute Corr
             * @description Use absolute correlation values
             * @default false
             */
            use_absolute_corr: boolean;
            /**
             * Distance Formula
             * @description Distance formula (1 or 2)
             * @default 1
             */
            distance_formula: number;
            /**
             * Flip Axes
             * @description Whether to flip axes based on correlation signs
             * @default true
             */
            flip_axes: boolean;
            /**
             * Clustering Algorithm
             * @description Clustering algorithm (DBSCAN or GMM)
             * @default DBSCAN
             */
            clustering_algorithm: string;
            /**
             * Clustering Score
             * @description Clustering score metric
             * @default silhoutte
             */
            clustering_score: string;
        };
        /**
         * ScoreBandsResponse
         * @description Model of the response containing SCORE bands parameters.
         */
        ScoreBandsResponse: {
            /**
             * Groups
             * @description Cluster group assignments for each data point
             */
            groups: number[];
            /**
             * Axis Dist
             * @description Normalized axis positions
             */
            axis_dist: number[];
            /**
             * Axis Signs
             * @description Axis direction signs (1 or -1)
             */
            axis_signs: number[] | null;
            /**
             * Obj Order
             * @description Optimal order of objectives
             */
            obj_order: number[];
        };
        /**
         * SimulatorDB
         * @description The SQLModel equivalent to `Simulator`.
         */
        SimulatorDB: {
            /** File */
            file?: string | null;
            url?: components["schemas"]["Url"] | null;
            /** Parameter Options */
            parameter_options?: {
                [key: string]: unknown;
            } | null;
            /**
             * Name
             * @description Descriptive name of the simulator. This can be used in UI and visualizations.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * SolutionInfo
         * @description Used when we wish to reference a solution in some `StateDB` stored in the database.
         */
        SolutionInfo: {
            /** State Id */
            state_id: number;
            /** Solution Index */
            solution_index: number;
            /**
             * Name
             * @description Name to be given to the solution. Optional.
             */
            name?: string | null;
        };
        /**
         * SolutionReferenceResponse
         * @description The response information provided when `SolutionReference` object are returned from the client.
         */
        SolutionReferenceResponse: {
            /** Name */
            name: string | null;
            /** Solution Index */
            solution_index: number | null;
            /** State Id */
            state_id: number;
            /** Objective Values */
            objective_values: {
                [key: string]: number;
            } | null;
            /** Variable Values */
            variable_values: {
                [key: string]: number | boolean | components["schemas"]["Tensor"];
            } | null;
        };
        /**
         * SolverResults
         * @description Defines a schema for a dataclass to store the results of a solver.
         */
        SolverResults: {
            /**
             * Optimal Variables
             * @description The optimal decision variables found.
             */
            optimal_variables: {
                [key: string]: number | unknown[];
            };
            /**
             * Optimal Objectives
             * @description The objective function values corresponding to the optimal decision variables found.
             */
            optimal_objectives: {
                [key: string]: number | number[];
            };
            /**
             * Constraint Values
             * @description The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.
             */
            constraint_values?: {
                [key: string]: number | number[] | unknown[];
            } | unknown | null;
            /**
             * Extra Func Values
             * @description The extra function values of the problem.
             */
            extra_func_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Scalarization Values
             * @description The scalarization function values of the problem.
             */
            scalarization_values?: {
                [key: string]: number | number[];
            } | null;
            /**
             * Success
             * @description A boolean flag indicating whether the optimization was successful or not.
             */
            success: boolean;
            /**
             * Message
             * @description Description of the cause of termination.
             */
            message: string;
        };
        Tensor: components["schemas"]["Tensor"][] | (number | boolean)[] | number | boolean | "List" | null;
        /**
         * TensorConstantDB
         * @description The SQLModel equivalent to `TensorConstant`.
         */
        TensorConstantDB: {
            values: components["schemas"]["Tensor"];
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the tensor representing the values. E.g., 'distances'
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * TensorVariableDB
         * @description The SQLModel equivalent to `TensorVariable`.
         */
        TensorVariableDB: {
            initial_values: components["schemas"]["Tensor"] | null;
            lowerbounds: components["schemas"]["Tensor"] | null;
            upperbounds: components["schemas"]["Tensor"] | null;
            /** Shape */
            shape: number[];
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer, or binary. Note that each element of a TensorVariable is assumed to be of the same type. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * Tokens
         * @description A model for the authentication token.
         */
        Tokens: {
            /** Access Token */
            access_token: string;
            /** Refresh Token */
            refresh_token: string;
            /** Token Type */
            token_type: string;
        };
        /**
         * Url
         * @description Model for a URL.
         */
        Url: {
            /**
             * Url
             * @description A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.
             */
            url: string;
            /**
             * Auth
             * @description Optional. A tuple of username and password to be used for authentication when making requests to the URL.
             */
            auth?: [
                string,
                string
            ] | null;
        };
        /**
         * UserPublic
         * @description The object to handle public user information.
         */
        UserPublic: {
            /** Username */
            username: string;
            /** Id */
            id: number;
            role: components["schemas"]["UserRole"];
            /** Group */
            group: string;
        };
        /**
         * UserRole
         * @description Possible user roles.
         * @enum {string}
         */
        UserRole: "guest" | "dm" | "analyst" | "admin";
        /**
         * UtopiaRequest
         * @description The request for an Utopia map.
         */
        UtopiaRequest: {
            /**
             * Problem Id
             * @description Problem for which the map is generated
             */
            problem_id: number;
            /** @description Solution for which to generate the map */
            solution: components["schemas"]["SolutionInfo"];
        };
        /**
         * UtopiaResponse
         * @description The response to an UtopiaRequest.
         */
        UtopiaResponse: {
            /**
             * Is Utopia
             * @description True if map exists for this problem.
             */
            is_utopia: boolean;
            /**
             * Map Name
             * @description Name of the map.
             */
            map_name: string;
            /**
             * Map Json
             * @description MapJSON representation of the geography.
             */
            map_json: {
                [key: string]: unknown;
            };
            /**
             * Options
             * @description A dict with given years as keys containing options for each year.
             */
            options: {
                [key: string]: unknown;
            };
            /**
             * Description
             * @description Description shown above the map.
             */
            description: string;
            /**
             * Years
             * @description A list of years for which the maps have been generated.
             */
            years: string[];
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VariableDB
         * @description The SQLModel equivalent to `Variable`.
         */
        VariableDB: {
            /**
             * Name
             * @description Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'.
             */
            name: string;
            /**
             * Symbol
             * @description Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'.
             */
            symbol: string;
            /** @description Type of the variable. Can be real, integer or binary. */
            variable_type: components["schemas"]["VariableTypeEnum"];
            /**
             * Lowerbound
             * @description Lower bound of the variable.
             */
            lowerbound?: number | null;
            /**
             * Upperbound
             * @description Upper bound of the variable.
             */
            upperbound?: number | null;
            /**
             * Initial Value
             * @description Initial value of the variable. This is optional.
             */
            initial_value?: number | null;
            /** Id */
            id?: number | null;
            /** Problem Id */
            problem_id?: number | null;
        };
        /**
         * VariableDomainTypeEnum
         * @description An enumerator for the possible variable type domains of a problem.
         * @enum {string}
         */
        VariableDomainTypeEnum: "continuous" | "binary" | "integer" | "mixed";
        /**
         * VariableTypeEnum
         * @description An enumerator for possible variable types.
         * @enum {string}
         */
        VariableTypeEnum: "real" | "integer" | "binary";
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_current_user_info_user_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserPublic"];
                };
            };
        };
    };
    login_login_post: {
        parameters: {
            query?: {
                cookie_max_age?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_login_login_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Tokens"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    logout_logout_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    refresh_access_token_refresh_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: {
                refresh_token?: string | null;
            };
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_dm_add_new_dm_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_dm_add_new_dm_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_new_analyst_add_new_analyst_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_add_new_analyst_add_new_analyst_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_problems_problem_all_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfoSmall"][];
                };
            };
        };
    };
    get_problems_info_problem_all_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"][];
                };
            };
        };
    };
    get_problem_problem_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemGetRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_problem_problem_add_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProblemInfo"];
                };
            };
        };
    };
    get_metadata_problem_get_metadata_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProblemMetaDataGetRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": (components["schemas"]["ForestProblemMetaData"] | components["schemas"]["RepresentativeNonDominatedSolutions"])[];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_new_session_session_new_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_session_session_get_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetSessionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InteractiveSessionBase"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_rpm_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RPMSolveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RPMState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_solutions_method_nimbus_solve_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSClassificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSClassificationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    initialize_method_nimbus_initialize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSInitializationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSInitializationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    save_method_nimbus_save_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSSaveRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSSaveResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_nimbus_intermediate_method_nimbus_intermediate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IntermediateSolutionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSIntermediateSolutionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_or_initialize_method_nimbus_get_or_initialize_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NIMBUSInitializationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NIMBUSInitializationResponse"] | components["schemas"]["NIMBUSClassificationResponse"] | components["schemas"]["NIMBUSIntermediateSolutionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    solve_intermediate_method_generic_intermediate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IntermediateSolutionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenericIntermediateSolutionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    calculate_score_bands_method_generic_score_bands_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ScoreBandsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScoreBandsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_utopia_data_utopia__post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UtopiaRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UtopiaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
