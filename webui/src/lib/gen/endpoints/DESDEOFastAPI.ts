/**
 * Generated by orval v8.0.2 ðŸº
 * Do not edit manually.
 * DESDEO (fast)API
 * A rest API for the DESDEO framework.
 * OpenAPI spec version: 0.1.0
 */
import type {
	BodyAddNewAnalystAddNewAnalystPost,
	BodyAddNewDmAddNewDmPost,
	BodyAddProblemJsonProblemAddJsonPost,
	BodyLoginLoginPost,
	ConfigureGdmGdmScoreBandsConfigurePostParams,
	CreateSessionRequest,
	ENautilusRepresentativeSolutionsResponse,
	ENautilusStateResponse,
	ENautilusStepRequest,
	ENautilusStepResponse,
	ForestProblemMetaData,
	GDMSCOREBandsHistoryResponse,
	GDMSCOREBandsRevertRequest,
	GDMScoreBandsInitializationRequest,
	GDMScoreBandsVoteRequest,
	GNIMBUSAllIterationsResponse,
	GNIMBUSResultResponse,
	GNIMBUSSwitchPhaseRequest,
	GNIMBUSSwitchPhaseResponse,
	GenericIntermediateSolutionResponse,
	GroupCreateRequest,
	GroupInfoRequest,
	GroupModifyRequest,
	GroupPublic,
	GroupRevertRequest,
	HTTPValidationError,
	InteractiveSessionBase,
	IntermediateSolutionRequest,
	LoginLoginPostParams,
	NIMBUSClassificationRequest,
	NIMBUSClassificationResponse,
	NIMBUSDeleteSaveRequest,
	NIMBUSDeleteSaveResponse,
	NIMBUSFinalizeRequest,
	NIMBUSFinalizeResponse,
	NIMBUSInitializationRequest,
	NIMBUSInitializationResponse,
	NIMBUSIntermediateSolutionResponse,
	NIMBUSSaveRequest,
	NIMBUSSaveResponse,
	ProblemGetRequest,
	ProblemInfo,
	ProblemInfoSmall,
	ProblemMetaDataGetRequest,
	ProblemSelectSolverRequest,
	RPMSolveRequest,
	RPMState,
	RepresentativeNonDominatedSolutions,
	SCOREBandsGDMConfig,
	ScoreBandsRequest,
	ScoreBandsResponse,
	SolverSelectionMetadata,
	Tokens,
	UserPublic,
	UtopiaRequest,
	UtopiaResponse
} from '../models';

import { customFetch } from '../../api/new-client';
/**
 * Return information about the current user.

Args:
    user (Annotated[User, Depends): user dependency, handled by `get_current_user`.

Returns:
    UserPublic: public information about the current user.
 * @summary Get Current User Info
 */
export type getCurrentUserInfoUserInfoGetResponse200 = {
	data: UserPublic;
	status: 200;
};

export type getCurrentUserInfoUserInfoGetResponseSuccess =
	getCurrentUserInfoUserInfoGetResponse200 & {
		headers: Headers;
	};
export type getCurrentUserInfoUserInfoGetResponse = getCurrentUserInfoUserInfoGetResponseSuccess;

export const getGetCurrentUserInfoUserInfoGetUrl = () => {
	return `http://localhost:8000/user_info`;
};

export const getCurrentUserInfoUserInfoGet = async (
	options?: RequestInit
): Promise<getCurrentUserInfoUserInfoGetResponse> => {
	return customFetch<getCurrentUserInfoUserInfoGetResponse>(getGetCurrentUserInfoUserInfoGetUrl(), {
		...options,
		method: 'GET'
	});
};

/**
 * Login to get an authentication token.

Return an access token in the response and a cookie storing a refresh token.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
        The form data to authenticate the user.
    session (Annotated[Session, Depends(get_db)]): The database session.
    cookie_max_age (int): the lifetime of the cookie storing the refresh token.
 * @summary Login
 */
export type loginLoginPostResponse200 = {
	data: Tokens;
	status: 200;
};

export type loginLoginPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type loginLoginPostResponseSuccess = loginLoginPostResponse200 & {
	headers: Headers;
};
export type loginLoginPostResponseError = loginLoginPostResponse422 & {
	headers: Headers;
};

export type loginLoginPostResponse = loginLoginPostResponseSuccess | loginLoginPostResponseError;

export const getLoginLoginPostUrl = (params?: LoginLoginPostParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? 'null' : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `http://localhost:8000/login?${stringifiedParams}`
		: `http://localhost:8000/login`;
};

export const loginLoginPost = async (
	bodyLoginLoginPost: BodyLoginLoginPost,
	params?: LoginLoginPostParams,
	options?: RequestInit
): Promise<loginLoginPostResponse> => {
	const formUrlEncoded = new URLSearchParams();
	if (bodyLoginLoginPost.grant_type !== undefined && bodyLoginLoginPost.grant_type !== null) {
		formUrlEncoded.append(`grant_type`, bodyLoginLoginPost.grant_type);
	}
	formUrlEncoded.append(`username`, bodyLoginLoginPost.username);
	formUrlEncoded.append(`password`, bodyLoginLoginPost.password);
	if (bodyLoginLoginPost.scope !== undefined) {
		formUrlEncoded.append(`scope`, bodyLoginLoginPost.scope);
	}
	if (bodyLoginLoginPost.client_id !== undefined && bodyLoginLoginPost.client_id !== null) {
		formUrlEncoded.append(`client_id`, bodyLoginLoginPost.client_id);
	}
	if (bodyLoginLoginPost.client_secret !== undefined && bodyLoginLoginPost.client_secret !== null) {
		formUrlEncoded.append(`client_secret`, bodyLoginLoginPost.client_secret);
	}

	return customFetch<loginLoginPostResponse>(getLoginLoginPostUrl(params), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
		body: formUrlEncoded
	});
};

/**
 * Log the current user out. Deletes the refresh token that was set by logging in.

Args:
    None

Returns:
    JSONResponse: A response in which the cookies are deleted
 * @summary Logout
 */
export type logoutLogoutPostResponse200 = {
	data: unknown;
	status: 200;
};

export type logoutLogoutPostResponseSuccess = logoutLogoutPostResponse200 & {
	headers: Headers;
};
export type logoutLogoutPostResponse = logoutLogoutPostResponseSuccess;

export const getLogoutLogoutPostUrl = () => {
	return `http://localhost:8000/logout`;
};

export const logoutLogoutPost = async (
	options?: RequestInit
): Promise<logoutLogoutPostResponse> => {
	return customFetch<logoutLogoutPostResponse>(getLogoutLogoutPostUrl(), {
		...options,
		method: 'POST'
	});
};

/**
 * Refresh the access token using the refresh token stored in the cookie.

Args:
    request (Request): The request containing the cookie.
    session (Annotated[Session, Depends(get_db)]): the database session.
    refresh_token (Annotated[Str | None, Cookie()]): the refresh
        token, which is fetched from a cookie included in the response.

Returns:
    dict: A dictionary containing the new access token.
 * @summary Refresh Access Token
 */
export type refreshAccessTokenRefreshPostResponse200 = {
	data: unknown;
	status: 200;
};

export type refreshAccessTokenRefreshPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type refreshAccessTokenRefreshPostResponseSuccess =
	refreshAccessTokenRefreshPostResponse200 & {
		headers: Headers;
	};
export type refreshAccessTokenRefreshPostResponseError =
	refreshAccessTokenRefreshPostResponse422 & {
		headers: Headers;
	};

export type refreshAccessTokenRefreshPostResponse =
	| refreshAccessTokenRefreshPostResponseSuccess
	| refreshAccessTokenRefreshPostResponseError;

export const getRefreshAccessTokenRefreshPostUrl = () => {
	return `http://localhost:8000/refresh`;
};

export const refreshAccessTokenRefreshPost = async (
	options?: RequestInit
): Promise<refreshAccessTokenRefreshPostResponse> => {
	return customFetch<refreshAccessTokenRefreshPostResponse>(getRefreshAccessTokenRefreshPostUrl(), {
		...options,
		method: 'POST'
	});
};

/**
 * Add a new user of the role Decision Maker to the database. Requires no login.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if username is already in use or if saving to the database fails for some reason.
 * @summary Add New Dm
 */
export type addNewDmAddNewDmPostResponse200 = {
	data: unknown;
	status: 200;
};

export type addNewDmAddNewDmPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addNewDmAddNewDmPostResponseSuccess = addNewDmAddNewDmPostResponse200 & {
	headers: Headers;
};
export type addNewDmAddNewDmPostResponseError = addNewDmAddNewDmPostResponse422 & {
	headers: Headers;
};

export type addNewDmAddNewDmPostResponse =
	| addNewDmAddNewDmPostResponseSuccess
	| addNewDmAddNewDmPostResponseError;

export const getAddNewDmAddNewDmPostUrl = () => {
	return `http://localhost:8000/add_new_dm`;
};

export const addNewDmAddNewDmPost = async (
	bodyAddNewDmAddNewDmPost: BodyAddNewDmAddNewDmPost,
	options?: RequestInit
): Promise<addNewDmAddNewDmPostResponse> => {
	const formUrlEncoded = new URLSearchParams();
	if (
		bodyAddNewDmAddNewDmPost.grant_type !== undefined &&
		bodyAddNewDmAddNewDmPost.grant_type !== null
	) {
		formUrlEncoded.append(`grant_type`, bodyAddNewDmAddNewDmPost.grant_type);
	}
	formUrlEncoded.append(`username`, bodyAddNewDmAddNewDmPost.username);
	formUrlEncoded.append(`password`, bodyAddNewDmAddNewDmPost.password);
	if (bodyAddNewDmAddNewDmPost.scope !== undefined) {
		formUrlEncoded.append(`scope`, bodyAddNewDmAddNewDmPost.scope);
	}
	if (
		bodyAddNewDmAddNewDmPost.client_id !== undefined &&
		bodyAddNewDmAddNewDmPost.client_id !== null
	) {
		formUrlEncoded.append(`client_id`, bodyAddNewDmAddNewDmPost.client_id);
	}
	if (
		bodyAddNewDmAddNewDmPost.client_secret !== undefined &&
		bodyAddNewDmAddNewDmPost.client_secret !== null
	) {
		formUrlEncoded.append(`client_secret`, bodyAddNewDmAddNewDmPost.client_secret);
	}

	return customFetch<addNewDmAddNewDmPostResponse>(getAddNewDmAddNewDmPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
		body: formUrlEncoded
	});
};

/**
 * Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin.

Args:
    user: Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
    form_data: (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session: (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if the logged in user is not an analyst or an admin or if
    username is already in use or if saving to the database fails for some reason.
 * @summary Add New Analyst
 */
export type addNewAnalystAddNewAnalystPostResponse200 = {
	data: unknown;
	status: 200;
};

export type addNewAnalystAddNewAnalystPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addNewAnalystAddNewAnalystPostResponseSuccess =
	addNewAnalystAddNewAnalystPostResponse200 & {
		headers: Headers;
	};
export type addNewAnalystAddNewAnalystPostResponseError =
	addNewAnalystAddNewAnalystPostResponse422 & {
		headers: Headers;
	};

export type addNewAnalystAddNewAnalystPostResponse =
	| addNewAnalystAddNewAnalystPostResponseSuccess
	| addNewAnalystAddNewAnalystPostResponseError;

export const getAddNewAnalystAddNewAnalystPostUrl = () => {
	return `http://localhost:8000/add_new_analyst`;
};

export const addNewAnalystAddNewAnalystPost = async (
	bodyAddNewAnalystAddNewAnalystPost: BodyAddNewAnalystAddNewAnalystPost,
	options?: RequestInit
): Promise<addNewAnalystAddNewAnalystPostResponse> => {
	const formUrlEncoded = new URLSearchParams();
	if (
		bodyAddNewAnalystAddNewAnalystPost.grant_type !== undefined &&
		bodyAddNewAnalystAddNewAnalystPost.grant_type !== null
	) {
		formUrlEncoded.append(`grant_type`, bodyAddNewAnalystAddNewAnalystPost.grant_type);
	}
	formUrlEncoded.append(`username`, bodyAddNewAnalystAddNewAnalystPost.username);
	formUrlEncoded.append(`password`, bodyAddNewAnalystAddNewAnalystPost.password);
	if (bodyAddNewAnalystAddNewAnalystPost.scope !== undefined) {
		formUrlEncoded.append(`scope`, bodyAddNewAnalystAddNewAnalystPost.scope);
	}
	if (
		bodyAddNewAnalystAddNewAnalystPost.client_id !== undefined &&
		bodyAddNewAnalystAddNewAnalystPost.client_id !== null
	) {
		formUrlEncoded.append(`client_id`, bodyAddNewAnalystAddNewAnalystPost.client_id);
	}
	if (
		bodyAddNewAnalystAddNewAnalystPost.client_secret !== undefined &&
		bodyAddNewAnalystAddNewAnalystPost.client_secret !== null
	) {
		formUrlEncoded.append(`client_secret`, bodyAddNewAnalystAddNewAnalystPost.client_secret);
	}

	return customFetch<addNewAnalystAddNewAnalystPostResponse>(
		getAddNewAnalystAddNewAnalystPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
			body: formUrlEncoded
		}
	);
};

/**
 * Get information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfoSmall]: a list of information on all the problems.
 * @summary Get Problems
 */
export type getProblemsProblemAllGetResponse200 = {
	data: ProblemInfoSmall[];
	status: 200;
};

export type getProblemsProblemAllGetResponseSuccess = getProblemsProblemAllGetResponse200 & {
	headers: Headers;
};
export type getProblemsProblemAllGetResponse = getProblemsProblemAllGetResponseSuccess;

export const getGetProblemsProblemAllGetUrl = () => {
	return `http://localhost:8000/problem/all`;
};

export const getProblemsProblemAllGet = async (
	options?: RequestInit
): Promise<getProblemsProblemAllGetResponse> => {
	return customFetch<getProblemsProblemAllGetResponse>(getGetProblemsProblemAllGetUrl(), {
		...options,
		method: 'GET'
	});
};

/**
 * Get detailed information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfo]: a list of the detailed information on all the problems.
 * @summary Get Problems Info
 */
export type getProblemsInfoProblemAllInfoGetResponse200 = {
	data: ProblemInfo[];
	status: 200;
};

export type getProblemsInfoProblemAllInfoGetResponseSuccess =
	getProblemsInfoProblemAllInfoGetResponse200 & {
		headers: Headers;
	};
export type getProblemsInfoProblemAllInfoGetResponse =
	getProblemsInfoProblemAllInfoGetResponseSuccess;

export const getGetProblemsInfoProblemAllInfoGetUrl = () => {
	return `http://localhost:8000/problem/all_info`;
};

export const getProblemsInfoProblemAllInfoGet = async (
	options?: RequestInit
): Promise<getProblemsInfoProblemAllInfoGetResponse> => {
	return customFetch<getProblemsInfoProblemAllInfoGetResponse>(
		getGetProblemsInfoProblemAllInfoGetUrl(),
		{
			...options,
			method: 'GET'
		}
	);
};

/**
 * Get the model of a specific problem.

Args:
    request (ProblemGetRequest): the request containing the problem's id `problem_id`.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find a problem with the given id.

Returns:
    ProblemInfo: detailed information on the requested problem.
 * @summary Get Problem
 */
export type getProblemProblemGetPostResponse200 = {
	data: ProblemInfo;
	status: 200;
};

export type getProblemProblemGetPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getProblemProblemGetPostResponseSuccess = getProblemProblemGetPostResponse200 & {
	headers: Headers;
};
export type getProblemProblemGetPostResponseError = getProblemProblemGetPostResponse422 & {
	headers: Headers;
};

export type getProblemProblemGetPostResponse =
	| getProblemProblemGetPostResponseSuccess
	| getProblemProblemGetPostResponseError;

export const getGetProblemProblemGetPostUrl = () => {
	return `http://localhost:8000/problem/get`;
};

export const getProblemProblemGetPost = async (
	problemGetRequest: ProblemGetRequest,
	options?: RequestInit
): Promise<getProblemProblemGetPostResponse> => {
	return customFetch<getProblemProblemGetPostResponse>(getGetProblemProblemGetPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(problemGetRequest)
	});
};

/**
 * Add a newly defined problem to the database.

Args:
    request (Problem): the JSON representation of the problem.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Note:
    Users with the role 'guest' may not add new problems.

Raises:
    HTTPException: when any issue with defining the problem arises.

Returns:
    ProblemInfo: the information about the problem added.
 * @summary Add Problem
 */
export type addProblemProblemAddPostResponse200 = {
	data: ProblemInfo;
	status: 200;
};

export type addProblemProblemAddPostResponseSuccess = addProblemProblemAddPostResponse200 & {
	headers: Headers;
};
export type addProblemProblemAddPostResponse = addProblemProblemAddPostResponseSuccess;

export const getAddProblemProblemAddPostUrl = () => {
	return `http://localhost:8000/problem/add`;
};

export const addProblemProblemAddPost = async (
	options?: RequestInit
): Promise<addProblemProblemAddPostResponse> => {
	return customFetch<addProblemProblemAddPostResponse>(getAddProblemProblemAddPostUrl(), {
		...options,
		method: 'POST'
	});
};

/**
 * Adds a problem to the database based on its JSON definition.

Args:
    json_file (UploadFile): a file in JSON format describing the problem.
    user (Annotated[User, Depends): the usr for which the problem is added.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: if the provided `json_file` is empty.
    HTTPException: if the content in the provided `json_file` is not in JSON format.__annotations__

Returns:
    ProblemInfo: a description of the added problem.
 * @summary Add Problem Json
 */
export type addProblemJsonProblemAddJsonPostResponse200 = {
	data: ProblemInfo;
	status: 200;
};

export type addProblemJsonProblemAddJsonPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addProblemJsonProblemAddJsonPostResponseSuccess =
	addProblemJsonProblemAddJsonPostResponse200 & {
		headers: Headers;
	};
export type addProblemJsonProblemAddJsonPostResponseError =
	addProblemJsonProblemAddJsonPostResponse422 & {
		headers: Headers;
	};

export type addProblemJsonProblemAddJsonPostResponse =
	| addProblemJsonProblemAddJsonPostResponseSuccess
	| addProblemJsonProblemAddJsonPostResponseError;

export const getAddProblemJsonProblemAddJsonPostUrl = () => {
	return `http://localhost:8000/problem/add_json`;
};

export const addProblemJsonProblemAddJsonPost = async (
	bodyAddProblemJsonProblemAddJsonPost: BodyAddProblemJsonProblemAddJsonPost,
	options?: RequestInit
): Promise<addProblemJsonProblemAddJsonPostResponse> => {
	const formData = new FormData();
	formData.append(`json_file`, bodyAddProblemJsonProblemAddJsonPost.json_file);

	return customFetch<addProblemJsonProblemAddJsonPostResponse>(
		getAddProblemJsonProblemAddJsonPostUrl(),
		{
			...options,
			method: 'POST',
			body: formData
		}
	);
};

/**
 * Fetch specific metadata for a specific problem.

Fetch specific metadata for a specific problem. See all the possible
metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata
section.

Args:
    request (MetaDataGetRequest): the requested metadata type.
    user (Annotated[User, Depends]): the current user.
    session (Annotated[Session, Depends]): the database session.

Returns:
    list[ForestProblemMetadata | RepresentativeNonDominatedSolutions]: list containing all the metadata
        defined for the problem with the requested metadata type. If no match is found,
        returns an empty list.
 * @summary Get Metadata
 */
export type getMetadataProblemGetMetadataPostResponse200 = {
	data: (ForestProblemMetaData | RepresentativeNonDominatedSolutions | SolverSelectionMetadata)[];
	status: 200;
};

export type getMetadataProblemGetMetadataPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getMetadataProblemGetMetadataPostResponseSuccess =
	getMetadataProblemGetMetadataPostResponse200 & {
		headers: Headers;
	};
export type getMetadataProblemGetMetadataPostResponseError =
	getMetadataProblemGetMetadataPostResponse422 & {
		headers: Headers;
	};

export type getMetadataProblemGetMetadataPostResponse =
	| getMetadataProblemGetMetadataPostResponseSuccess
	| getMetadataProblemGetMetadataPostResponseError;

export const getGetMetadataProblemGetMetadataPostUrl = () => {
	return `http://localhost:8000/problem/get_metadata`;
};

export const getMetadataProblemGetMetadataPost = async (
	problemMetaDataGetRequest: ProblemMetaDataGetRequest,
	options?: RequestInit
): Promise<getMetadataProblemGetMetadataPostResponse> => {
	return customFetch<getMetadataProblemGetMetadataPostResponse>(
		getGetMetadataProblemGetMetadataPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(problemMetaDataGetRequest)
		}
	);
};

/**
 * Return the list of available solver names.
 * @summary Get Available Solvers
 */
export type getAvailableSolversProblemAssignSolverGetResponse200 = {
	data: string[];
	status: 200;
};

export type getAvailableSolversProblemAssignSolverGetResponseSuccess =
	getAvailableSolversProblemAssignSolverGetResponse200 & {
		headers: Headers;
	};
export type getAvailableSolversProblemAssignSolverGetResponse =
	getAvailableSolversProblemAssignSolverGetResponseSuccess;

export const getGetAvailableSolversProblemAssignSolverGetUrl = () => {
	return `http://localhost:8000/problem/assign/solver`;
};

export const getAvailableSolversProblemAssignSolverGet = async (
	options?: RequestInit
): Promise<getAvailableSolversProblemAssignSolverGetResponse> => {
	return customFetch<getAvailableSolversProblemAssignSolverGetResponse>(
		getGetAvailableSolversProblemAssignSolverGetUrl(),
		{
			...options,
			method: 'GET'
		}
	);
};

/**
 * Assign a specific solver for a problem.

request: ProblemSelectSolverRequest: The request containing problem id and string representation of the solver
user: Annotated[User, Depends(get_current_user): The user that is logged in.
session: Annotated[Session, Depends(get_session)]: The database session.

Raises:
    HTTPException: Unknown solver, unauthorized user

Returns:
    JSONResponse: A simple confirmation.
 * @summary Select Solver
 */
export type selectSolverProblemAssignSolverPostResponse200 = {
	data: unknown;
	status: 200;
};

export type selectSolverProblemAssignSolverPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type selectSolverProblemAssignSolverPostResponseSuccess =
	selectSolverProblemAssignSolverPostResponse200 & {
		headers: Headers;
	};
export type selectSolverProblemAssignSolverPostResponseError =
	selectSolverProblemAssignSolverPostResponse422 & {
		headers: Headers;
	};

export type selectSolverProblemAssignSolverPostResponse =
	| selectSolverProblemAssignSolverPostResponseSuccess
	| selectSolverProblemAssignSolverPostResponseError;

export const getSelectSolverProblemAssignSolverPostUrl = () => {
	return `http://localhost:8000/problem/assign_solver`;
};

export const selectSolverProblemAssignSolverPost = async (
	problemSelectSolverRequest: ProblemSelectSolverRequest,
	options?: RequestInit
): Promise<selectSolverProblemAssignSolverPostResponse> => {
	return customFetch<selectSolverProblemAssignSolverPostResponse>(
		getSelectSolverProblemAssignSolverPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(problemSelectSolverRequest)
		}
	);
};

/**
 * .
 * @summary Create New Session
 */
export type createNewSessionSessionNewPostResponse200 = {
	data: InteractiveSessionBase;
	status: 200;
};

export type createNewSessionSessionNewPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createNewSessionSessionNewPostResponseSuccess =
	createNewSessionSessionNewPostResponse200 & {
		headers: Headers;
	};
export type createNewSessionSessionNewPostResponseError =
	createNewSessionSessionNewPostResponse422 & {
		headers: Headers;
	};

export type createNewSessionSessionNewPostResponse =
	| createNewSessionSessionNewPostResponseSuccess
	| createNewSessionSessionNewPostResponseError;

export const getCreateNewSessionSessionNewPostUrl = () => {
	return `http://localhost:8000/session/new`;
};

export const createNewSessionSessionNewPost = async (
	createSessionRequest: CreateSessionRequest,
	options?: RequestInit
): Promise<createNewSessionSessionNewPostResponse> => {
	return customFetch<createNewSessionSessionNewPostResponse>(
		getCreateNewSessionSessionNewPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(createSessionRequest)
		}
	);
};

/**
 * Return an interactive session with a current user.
 * @summary Get Session
 */
export type getSessionSessionGetSessionIdGetResponse200 = {
	data: InteractiveSessionBase;
	status: 200;
};

export type getSessionSessionGetSessionIdGetResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getSessionSessionGetSessionIdGetResponseSuccess =
	getSessionSessionGetSessionIdGetResponse200 & {
		headers: Headers;
	};
export type getSessionSessionGetSessionIdGetResponseError =
	getSessionSessionGetSessionIdGetResponse422 & {
		headers: Headers;
	};

export type getSessionSessionGetSessionIdGetResponse =
	| getSessionSessionGetSessionIdGetResponseSuccess
	| getSessionSessionGetSessionIdGetResponseError;

export const getGetSessionSessionGetSessionIdGetUrl = (sessionId: number) => {
	return `http://localhost:8000/session/get/${sessionId}`;
};

export const getSessionSessionGetSessionIdGet = async (
	sessionId: number,
	options?: RequestInit
): Promise<getSessionSessionGetSessionIdGetResponse> => {
	return customFetch<getSessionSessionGetSessionIdGetResponse>(
		getGetSessionSessionGetSessionIdGetUrl(sessionId),
		{
			...options,
			method: 'GET'
		}
	);
};

/**
 * Return all interactive sessions of the current user.
 * @summary Get All Sessions
 */
export type getAllSessionsSessionGetAllGetResponse200 = {
	data: InteractiveSessionBase[];
	status: 200;
};

export type getAllSessionsSessionGetAllGetResponseSuccess =
	getAllSessionsSessionGetAllGetResponse200 & {
		headers: Headers;
	};
export type getAllSessionsSessionGetAllGetResponse = getAllSessionsSessionGetAllGetResponseSuccess;

export const getGetAllSessionsSessionGetAllGetUrl = () => {
	return `http://localhost:8000/session/get_all`;
};

export const getAllSessionsSessionGetAllGet = async (
	options?: RequestInit
): Promise<getAllSessionsSessionGetAllGetResponse> => {
	return customFetch<getAllSessionsSessionGetAllGetResponse>(
		getGetAllSessionsSessionGetAllGetUrl(),
		{
			...options,
			method: 'GET'
		}
	);
};

/**
 * Delete an interactive session and all its related states.
 * @summary Delete Session
 */
export type deleteSessionSessionSessionIdDeleteResponse204 = {
	data: void;
	status: 204;
};

export type deleteSessionSessionSessionIdDeleteResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type deleteSessionSessionSessionIdDeleteResponseSuccess =
	deleteSessionSessionSessionIdDeleteResponse204 & {
		headers: Headers;
	};
export type deleteSessionSessionSessionIdDeleteResponseError =
	deleteSessionSessionSessionIdDeleteResponse422 & {
		headers: Headers;
	};

export type deleteSessionSessionSessionIdDeleteResponse =
	| deleteSessionSessionSessionIdDeleteResponseSuccess
	| deleteSessionSessionSessionIdDeleteResponseError;

export const getDeleteSessionSessionSessionIdDeleteUrl = (sessionId: number) => {
	return `http://localhost:8000/session/${sessionId}`;
};

export const deleteSessionSessionSessionIdDelete = async (
	sessionId: number,
	options?: RequestInit
): Promise<deleteSessionSessionSessionIdDeleteResponse> => {
	return customFetch<deleteSessionSessionSessionIdDeleteResponse>(
		getDeleteSessionSessionSessionIdDeleteUrl(sessionId),
		{
			...options,
			method: 'DELETE'
		}
	);
};

/**
 * Runs an iteration of the reference point method.

Args:
    request (RPMSolveRequest): a request with the needed information to run the method.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the current database session.

Returns:
    RPMState: a state with information on the results of iterating the reference point method
        once.
 * @summary Solve Solutions
 */
export type solveSolutionsMethodRpmSolvePostResponse200 = {
	data: RPMState;
	status: 200;
};

export type solveSolutionsMethodRpmSolvePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveSolutionsMethodRpmSolvePostResponseSuccess =
	solveSolutionsMethodRpmSolvePostResponse200 & {
		headers: Headers;
	};
export type solveSolutionsMethodRpmSolvePostResponseError =
	solveSolutionsMethodRpmSolvePostResponse422 & {
		headers: Headers;
	};

export type solveSolutionsMethodRpmSolvePostResponse =
	| solveSolutionsMethodRpmSolvePostResponseSuccess
	| solveSolutionsMethodRpmSolvePostResponseError;

export const getSolveSolutionsMethodRpmSolvePostUrl = () => {
	return `http://localhost:8000/method/rpm/solve`;
};

export const solveSolutionsMethodRpmSolvePost = async (
	rPMSolveRequest: RPMSolveRequest,
	options?: RequestInit
): Promise<solveSolutionsMethodRpmSolvePostResponse> => {
	return customFetch<solveSolutionsMethodRpmSolvePostResponse>(
		getSolveSolutionsMethodRpmSolvePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(rPMSolveRequest)
		}
	);
};

/**
 * Solve the problem using the NIMBUS method.
 * @summary Solve Solutions
 */
export type solveSolutionsMethodNimbusSolvePostResponse200 = {
	data: NIMBUSClassificationResponse;
	status: 200;
};

export type solveSolutionsMethodNimbusSolvePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveSolutionsMethodNimbusSolvePostResponseSuccess =
	solveSolutionsMethodNimbusSolvePostResponse200 & {
		headers: Headers;
	};
export type solveSolutionsMethodNimbusSolvePostResponseError =
	solveSolutionsMethodNimbusSolvePostResponse422 & {
		headers: Headers;
	};

export type solveSolutionsMethodNimbusSolvePostResponse =
	| solveSolutionsMethodNimbusSolvePostResponseSuccess
	| solveSolutionsMethodNimbusSolvePostResponseError;

export const getSolveSolutionsMethodNimbusSolvePostUrl = () => {
	return `http://localhost:8000/method/nimbus/solve`;
};

export const solveSolutionsMethodNimbusSolvePost = async (
	nIMBUSClassificationRequest: NIMBUSClassificationRequest,
	options?: RequestInit
): Promise<solveSolutionsMethodNimbusSolvePostResponse> => {
	return customFetch<solveSolutionsMethodNimbusSolvePostResponse>(
		getSolveSolutionsMethodNimbusSolvePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSClassificationRequest)
		}
	);
};

/**
 * Initialize the problem for the NIMBUS method.
 * @summary Initialize
 */
export type initializeMethodNimbusInitializePostResponse200 = {
	data: NIMBUSInitializationResponse;
	status: 200;
};

export type initializeMethodNimbusInitializePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type initializeMethodNimbusInitializePostResponseSuccess =
	initializeMethodNimbusInitializePostResponse200 & {
		headers: Headers;
	};
export type initializeMethodNimbusInitializePostResponseError =
	initializeMethodNimbusInitializePostResponse422 & {
		headers: Headers;
	};

export type initializeMethodNimbusInitializePostResponse =
	| initializeMethodNimbusInitializePostResponseSuccess
	| initializeMethodNimbusInitializePostResponseError;

export const getInitializeMethodNimbusInitializePostUrl = () => {
	return `http://localhost:8000/method/nimbus/initialize`;
};

export const initializeMethodNimbusInitializePost = async (
	nIMBUSInitializationRequest: NIMBUSInitializationRequest,
	options?: RequestInit
): Promise<initializeMethodNimbusInitializePostResponse> => {
	return customFetch<initializeMethodNimbusInitializePostResponse>(
		getInitializeMethodNimbusInitializePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSInitializationRequest)
		}
	);
};

/**
 * Save solutions.
 * @summary Save
 */
export type saveMethodNimbusSavePostResponse200 = {
	data: NIMBUSSaveResponse;
	status: 200;
};

export type saveMethodNimbusSavePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type saveMethodNimbusSavePostResponseSuccess = saveMethodNimbusSavePostResponse200 & {
	headers: Headers;
};
export type saveMethodNimbusSavePostResponseError = saveMethodNimbusSavePostResponse422 & {
	headers: Headers;
};

export type saveMethodNimbusSavePostResponse =
	| saveMethodNimbusSavePostResponseSuccess
	| saveMethodNimbusSavePostResponseError;

export const getSaveMethodNimbusSavePostUrl = () => {
	return `http://localhost:8000/method/nimbus/save`;
};

export const saveMethodNimbusSavePost = async (
	nIMBUSSaveRequest: NIMBUSSaveRequest,
	options?: RequestInit
): Promise<saveMethodNimbusSavePostResponse> => {
	return customFetch<saveMethodNimbusSavePostResponse>(getSaveMethodNimbusSavePostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(nIMBUSSaveRequest)
	});
};

/**
 * Solve intermediate solutions by forwarding the request to generic intermediate endpoint with context nimbus.
 * @summary Solve Nimbus Intermediate
 */
export type solveNimbusIntermediateMethodNimbusIntermediatePostResponse200 = {
	data: NIMBUSIntermediateSolutionResponse;
	status: 200;
};

export type solveNimbusIntermediateMethodNimbusIntermediatePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveNimbusIntermediateMethodNimbusIntermediatePostResponseSuccess =
	solveNimbusIntermediateMethodNimbusIntermediatePostResponse200 & {
		headers: Headers;
	};
export type solveNimbusIntermediateMethodNimbusIntermediatePostResponseError =
	solveNimbusIntermediateMethodNimbusIntermediatePostResponse422 & {
		headers: Headers;
	};

export type solveNimbusIntermediateMethodNimbusIntermediatePostResponse =
	| solveNimbusIntermediateMethodNimbusIntermediatePostResponseSuccess
	| solveNimbusIntermediateMethodNimbusIntermediatePostResponseError;

export const getSolveNimbusIntermediateMethodNimbusIntermediatePostUrl = () => {
	return `http://localhost:8000/method/nimbus/intermediate`;
};

export const solveNimbusIntermediateMethodNimbusIntermediatePost = async (
	intermediateSolutionRequest: IntermediateSolutionRequest,
	options?: RequestInit
): Promise<solveNimbusIntermediateMethodNimbusIntermediatePostResponse> => {
	return customFetch<solveNimbusIntermediateMethodNimbusIntermediatePostResponse>(
		getSolveNimbusIntermediateMethodNimbusIntermediatePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(intermediateSolutionRequest)
		}
	);
};

/**
 * Get the latest NIMBUS state if it exists, or initialize a new one if it doesn't.
 * @summary Get Or Initialize
 */
export type getOrInitializeMethodNimbusGetOrInitializePostResponse200 = {
	data:
		| NIMBUSInitializationResponse
		| NIMBUSClassificationResponse
		| NIMBUSIntermediateSolutionResponse
		| NIMBUSFinalizeResponse;
	status: 200;
};

export type getOrInitializeMethodNimbusGetOrInitializePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getOrInitializeMethodNimbusGetOrInitializePostResponseSuccess =
	getOrInitializeMethodNimbusGetOrInitializePostResponse200 & {
		headers: Headers;
	};
export type getOrInitializeMethodNimbusGetOrInitializePostResponseError =
	getOrInitializeMethodNimbusGetOrInitializePostResponse422 & {
		headers: Headers;
	};

export type getOrInitializeMethodNimbusGetOrInitializePostResponse =
	| getOrInitializeMethodNimbusGetOrInitializePostResponseSuccess
	| getOrInitializeMethodNimbusGetOrInitializePostResponseError;

export const getGetOrInitializeMethodNimbusGetOrInitializePostUrl = () => {
	return `http://localhost:8000/method/nimbus/get-or-initialize`;
};

export const getOrInitializeMethodNimbusGetOrInitializePost = async (
	nIMBUSInitializationRequest: NIMBUSInitializationRequest,
	options?: RequestInit
): Promise<getOrInitializeMethodNimbusGetOrInitializePostResponse> => {
	return customFetch<getOrInitializeMethodNimbusGetOrInitializePostResponse>(
		getGetOrInitializeMethodNimbusGetOrInitializePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSInitializationRequest)
		}
	);
};

/**
 * An endpoint for finishing up the nimbus process.

Args:
    request (NIMBUSFinalizeRequest): The request containing the final solution, etc.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): The database session.

Raises:
    HTTPException

Returns:
    NIMBUSFinalizeResponse: Response containing info on the final solution.
 * @summary Finalize Nimbus
 */
export type finalizeNimbusMethodNimbusFinalizePostResponse200 = {
	data: NIMBUSFinalizeResponse;
	status: 200;
};

export type finalizeNimbusMethodNimbusFinalizePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type finalizeNimbusMethodNimbusFinalizePostResponseSuccess =
	finalizeNimbusMethodNimbusFinalizePostResponse200 & {
		headers: Headers;
	};
export type finalizeNimbusMethodNimbusFinalizePostResponseError =
	finalizeNimbusMethodNimbusFinalizePostResponse422 & {
		headers: Headers;
	};

export type finalizeNimbusMethodNimbusFinalizePostResponse =
	| finalizeNimbusMethodNimbusFinalizePostResponseSuccess
	| finalizeNimbusMethodNimbusFinalizePostResponseError;

export const getFinalizeNimbusMethodNimbusFinalizePostUrl = () => {
	return `http://localhost:8000/method/nimbus/finalize`;
};

export const finalizeNimbusMethodNimbusFinalizePost = async (
	nIMBUSFinalizeRequest: NIMBUSFinalizeRequest,
	options?: RequestInit
): Promise<finalizeNimbusMethodNimbusFinalizePostResponse> => {
	return customFetch<finalizeNimbusMethodNimbusFinalizePostResponse>(
		getFinalizeNimbusMethodNimbusFinalizePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSFinalizeRequest)
		}
	);
};

/**
 * Endpoint for deleting saved solutions.

Args:
    request (NIMBUSDeleteSaveRequest): request containing necessary information for deleting a save
    user (Annotated[User, Depends): the current  (logged in) user
    session (Annotated[Session, Depends): database session

Raises:
    HTTPException

Returns:
    NIMBUSDeleteSaveResponse: Response acknowledging the deletion of save and other useful info.
 * @summary Delete Save
 */
export type deleteSaveMethodNimbusDeleteSavePostResponse200 = {
	data: NIMBUSDeleteSaveResponse;
	status: 200;
};

export type deleteSaveMethodNimbusDeleteSavePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type deleteSaveMethodNimbusDeleteSavePostResponseSuccess =
	deleteSaveMethodNimbusDeleteSavePostResponse200 & {
		headers: Headers;
	};
export type deleteSaveMethodNimbusDeleteSavePostResponseError =
	deleteSaveMethodNimbusDeleteSavePostResponse422 & {
		headers: Headers;
	};

export type deleteSaveMethodNimbusDeleteSavePostResponse =
	| deleteSaveMethodNimbusDeleteSavePostResponseSuccess
	| deleteSaveMethodNimbusDeleteSavePostResponseError;

export const getDeleteSaveMethodNimbusDeleteSavePostUrl = () => {
	return `http://localhost:8000/method/nimbus/delete_save`;
};

export const deleteSaveMethodNimbusDeleteSavePost = async (
	nIMBUSDeleteSaveRequest: NIMBUSDeleteSaveRequest,
	options?: RequestInit
): Promise<deleteSaveMethodNimbusDeleteSavePostResponse> => {
	return customFetch<deleteSaveMethodNimbusDeleteSavePostResponse>(
		getDeleteSaveMethodNimbusDeleteSavePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSDeleteSaveRequest)
		}
	);
};

/**
 * Solve intermediate solutions between given two solutions.
 * @summary Solve Intermediate
 */
export type solveIntermediateMethodGenericIntermediatePostResponse200 = {
	data: GenericIntermediateSolutionResponse;
	status: 200;
};

export type solveIntermediateMethodGenericIntermediatePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveIntermediateMethodGenericIntermediatePostResponseSuccess =
	solveIntermediateMethodGenericIntermediatePostResponse200 & {
		headers: Headers;
	};
export type solveIntermediateMethodGenericIntermediatePostResponseError =
	solveIntermediateMethodGenericIntermediatePostResponse422 & {
		headers: Headers;
	};

export type solveIntermediateMethodGenericIntermediatePostResponse =
	| solveIntermediateMethodGenericIntermediatePostResponseSuccess
	| solveIntermediateMethodGenericIntermediatePostResponseError;

export const getSolveIntermediateMethodGenericIntermediatePostUrl = () => {
	return `http://localhost:8000/method/generic/intermediate`;
};

export const solveIntermediateMethodGenericIntermediatePost = async (
	intermediateSolutionRequest: IntermediateSolutionRequest,
	options?: RequestInit
): Promise<solveIntermediateMethodGenericIntermediatePostResponse> => {
	return customFetch<solveIntermediateMethodGenericIntermediatePostResponse>(
		getSolveIntermediateMethodGenericIntermediatePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(intermediateSolutionRequest)
		}
	);
};

/**
 * Calculate SCORE bands parameters from objective data.
 * @summary Calculate Score Bands From Objective Data
 */
export type calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse200 = {
	data: ScoreBandsResponse;
	status: 200;
};

export type calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponseSuccess =
	calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse200 & {
		headers: Headers;
	};
export type calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponseError =
	calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse422 & {
		headers: Headers;
	};

export type calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse =
	| calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponseSuccess
	| calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponseError;

export const getCalculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostUrl = () => {
	return `http://localhost:8000/method/generic/score-bands-obj-data`;
};

export const calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPost = async (
	scoreBandsRequest: ScoreBandsRequest,
	options?: RequestInit
): Promise<calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse> => {
	return customFetch<calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse>(
		getCalculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(scoreBandsRequest)
		}
	);
};

/**
 * Request and receive the Utopia map corresponding to the decision variables sent.

Args:
    request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested
    for.
    user (Annotated[User, Depend(get_current_user)]) the current user
    session (Annotated[Session, Depends(get_session)]) the current database session
Raises:
    HTTPException:
Returns:
    UtopiaResponse: the map for the forest, to be rendered in frontend
 * @summary Get Utopia Data
 */
export type getUtopiaDataUtopiaPostResponse200 = {
	data: UtopiaResponse;
	status: 200;
};

export type getUtopiaDataUtopiaPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getUtopiaDataUtopiaPostResponseSuccess = getUtopiaDataUtopiaPostResponse200 & {
	headers: Headers;
};
export type getUtopiaDataUtopiaPostResponseError = getUtopiaDataUtopiaPostResponse422 & {
	headers: Headers;
};

export type getUtopiaDataUtopiaPostResponse =
	| getUtopiaDataUtopiaPostResponseSuccess
	| getUtopiaDataUtopiaPostResponseError;

export const getGetUtopiaDataUtopiaPostUrl = () => {
	return `http://localhost:8000/utopia/`;
};

export const getUtopiaDataUtopiaPost = async (
	utopiaRequest: UtopiaRequest,
	options?: RequestInit
): Promise<getUtopiaDataUtopiaPostResponse> => {
	return customFetch<getUtopiaDataUtopiaPostResponse>(getGetUtopiaDataUtopiaPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(utopiaRequest)
	});
};

/**
 * Create group.

Args:
    request (GroupCreateRequest): a request that holds information to be used in creation of the group.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Acknowledgement that the group was created

Raises:
    HTTPException
 * @summary Create Group
 */
export type createGroupGdmCreateGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type createGroupGdmCreateGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createGroupGdmCreateGroupPostResponseSuccess =
	createGroupGdmCreateGroupPostResponse200 & {
		headers: Headers;
	};
export type createGroupGdmCreateGroupPostResponseError =
	createGroupGdmCreateGroupPostResponse422 & {
		headers: Headers;
	};

export type createGroupGdmCreateGroupPostResponse =
	| createGroupGdmCreateGroupPostResponseSuccess
	| createGroupGdmCreateGroupPostResponseError;

export const getCreateGroupGdmCreateGroupPostUrl = () => {
	return `http://localhost:8000/gdm/create_group`;
};

export const createGroupGdmCreateGroupPost = async (
	groupCreateRequest: GroupCreateRequest,
	options?: RequestInit
): Promise<createGroupGdmCreateGroupPostResponse> => {
	return customFetch<createGroupGdmCreateGroupPostResponse>(getCreateGroupGdmCreateGroupPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(groupCreateRequest)
	});
};

/**
 * Delete the group with given ID.

Args:
    request (GroupInfoRequest): Contains the ID of the group to be deleted
    user (Annotated[User, Depends(get_current_user)]): The user (in this case must be owner for anything to happen)
    session (Annotated[Session, Depends(get_session)]): The database session

Returns:
    JSONResponse: Acknowledgement of the deletion

Raises:
    HTTPException: Insufficient authorization etc.
 * @summary Delete Group
 */
export type deleteGroupGdmDeleteGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type deleteGroupGdmDeleteGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type deleteGroupGdmDeleteGroupPostResponseSuccess =
	deleteGroupGdmDeleteGroupPostResponse200 & {
		headers: Headers;
	};
export type deleteGroupGdmDeleteGroupPostResponseError =
	deleteGroupGdmDeleteGroupPostResponse422 & {
		headers: Headers;
	};

export type deleteGroupGdmDeleteGroupPostResponse =
	| deleteGroupGdmDeleteGroupPostResponseSuccess
	| deleteGroupGdmDeleteGroupPostResponseError;

export const getDeleteGroupGdmDeleteGroupPostUrl = () => {
	return `http://localhost:8000/gdm/delete_group`;
};

export const deleteGroupGdmDeleteGroupPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<deleteGroupGdmDeleteGroupPostResponse> => {
	return customFetch<deleteGroupGdmDeleteGroupPostResponse>(getDeleteGroupGdmDeleteGroupPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(groupInfoRequest)
	});
};

/**
 * Add a user to a group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been added to the group

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Add To Group
 */
export type addToGroupGdmAddToGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type addToGroupGdmAddToGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addToGroupGdmAddToGroupPostResponseSuccess = addToGroupGdmAddToGroupPostResponse200 & {
	headers: Headers;
};
export type addToGroupGdmAddToGroupPostResponseError = addToGroupGdmAddToGroupPostResponse422 & {
	headers: Headers;
};

export type addToGroupGdmAddToGroupPostResponse =
	| addToGroupGdmAddToGroupPostResponseSuccess
	| addToGroupGdmAddToGroupPostResponseError;

export const getAddToGroupGdmAddToGroupPostUrl = () => {
	return `http://localhost:8000/gdm/add_to_group`;
};

export const addToGroupGdmAddToGroupPost = async (
	groupModifyRequest: GroupModifyRequest,
	options?: RequestInit
): Promise<addToGroupGdmAddToGroupPostResponse> => {
	return customFetch<addToGroupGdmAddToGroupPostResponse>(getAddToGroupGdmAddToGroupPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(groupModifyRequest)
	});
};

/**
 * Remove user from group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been removed from the group.

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Remove From Group
 */
export type removeFromGroupGdmRemoveFromGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type removeFromGroupGdmRemoveFromGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type removeFromGroupGdmRemoveFromGroupPostResponseSuccess =
	removeFromGroupGdmRemoveFromGroupPostResponse200 & {
		headers: Headers;
	};
export type removeFromGroupGdmRemoveFromGroupPostResponseError =
	removeFromGroupGdmRemoveFromGroupPostResponse422 & {
		headers: Headers;
	};

export type removeFromGroupGdmRemoveFromGroupPostResponse =
	| removeFromGroupGdmRemoveFromGroupPostResponseSuccess
	| removeFromGroupGdmRemoveFromGroupPostResponseError;

export const getRemoveFromGroupGdmRemoveFromGroupPostUrl = () => {
	return `http://localhost:8000/gdm/remove_from_group`;
};

export const removeFromGroupGdmRemoveFromGroupPost = async (
	groupModifyRequest: GroupModifyRequest,
	options?: RequestInit
): Promise<removeFromGroupGdmRemoveFromGroupPostResponse> => {
	return customFetch<removeFromGroupGdmRemoveFromGroupPostResponse>(
		getRemoveFromGroupGdmRemoveFromGroupPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupModifyRequest)
		}
	);
};

/**
 * Get information about the group.

Args:
    request (GroupInfoRequest): the id of the group for which we desire info on
    session (Annotated[Session, Depends(get_session)]): the database session

Returns:
    GroupPublic: public info of the group

Raises:
    HTTPException: If there's no group with the requests group id
 * @summary Get Group Info
 */
export type getGroupInfoGdmGetGroupInfoPostResponse200 = {
	data: GroupPublic;
	status: 200;
};

export type getGroupInfoGdmGetGroupInfoPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getGroupInfoGdmGetGroupInfoPostResponseSuccess =
	getGroupInfoGdmGetGroupInfoPostResponse200 & {
		headers: Headers;
	};
export type getGroupInfoGdmGetGroupInfoPostResponseError =
	getGroupInfoGdmGetGroupInfoPostResponse422 & {
		headers: Headers;
	};

export type getGroupInfoGdmGetGroupInfoPostResponse =
	| getGroupInfoGdmGetGroupInfoPostResponseSuccess
	| getGroupInfoGdmGetGroupInfoPostResponseError;

export const getGetGroupInfoGdmGetGroupInfoPostUrl = () => {
	return `http://localhost:8000/gdm/get_group_info`;
};

export const getGroupInfoGdmGetGroupInfoPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<getGroupInfoGdmGetGroupInfoPostResponse> => {
	return customFetch<getGroupInfoGdmGetGroupInfoPostResponse>(
		getGetGroupInfoGdmGetGroupInfoPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Initialize the problem for GNIMBUS.
 * @summary Gnimbus Initialize
 */
export type gnimbusInitializeGnimbusInitializePostResponse200 = {
	data: unknown;
	status: 200;
};

export type gnimbusInitializeGnimbusInitializePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type gnimbusInitializeGnimbusInitializePostResponseSuccess =
	gnimbusInitializeGnimbusInitializePostResponse200 & {
		headers: Headers;
	};
export type gnimbusInitializeGnimbusInitializePostResponseError =
	gnimbusInitializeGnimbusInitializePostResponse422 & {
		headers: Headers;
	};

export type gnimbusInitializeGnimbusInitializePostResponse =
	| gnimbusInitializeGnimbusInitializePostResponseSuccess
	| gnimbusInitializeGnimbusInitializePostResponseError;

export const getGnimbusInitializeGnimbusInitializePostUrl = () => {
	return `http://localhost:8000/gnimbus/initialize`;
};

export const gnimbusInitializeGnimbusInitializePost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<gnimbusInitializeGnimbusInitializePostResponse> => {
	return customFetch<gnimbusInitializeGnimbusInitializePostResponse>(
		getGnimbusInitializeGnimbusInitializePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Get the latest results from group iteration.

(OBSOLETE AND OUT OF DATE!)

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): Current user
    session (Annotated[Session, Depends(get_session)]): Database session.

Returns:
    GNIMBUSResultResponse: A GNIMBUSResultResponse response containing the latest gnimbus results

Raises:
    HTTPException: Validation errors or no results
 * @summary Get Latest Results
 */
export type getLatestResultsGnimbusGetLatestResultsPostResponse200 = {
	data: GNIMBUSResultResponse;
	status: 200;
};

export type getLatestResultsGnimbusGetLatestResultsPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getLatestResultsGnimbusGetLatestResultsPostResponseSuccess =
	getLatestResultsGnimbusGetLatestResultsPostResponse200 & {
		headers: Headers;
	};
export type getLatestResultsGnimbusGetLatestResultsPostResponseError =
	getLatestResultsGnimbusGetLatestResultsPostResponse422 & {
		headers: Headers;
	};

export type getLatestResultsGnimbusGetLatestResultsPostResponse =
	| getLatestResultsGnimbusGetLatestResultsPostResponseSuccess
	| getLatestResultsGnimbusGetLatestResultsPostResponseError;

export const getGetLatestResultsGnimbusGetLatestResultsPostUrl = () => {
	return `http://localhost:8000/gnimbus/get_latest_results`;
};

export const getLatestResultsGnimbusGetLatestResultsPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<getLatestResultsGnimbusGetLatestResultsPostResponse> => {
	return customFetch<getLatestResultsGnimbusGetLatestResultsPostResponse>(
		getGetLatestResultsGnimbusGetLatestResultsPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Get all results from all iterations of the group.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): current user
    session (Annotated[Session, Depends(get_session)]): current session

Returns:
    GNIMBUSAllIterationsResponse: A GNIMBUSAllIterationsResponse response
    containing all the results of the iterations. If last iteration was optimization,
    the first iteration is incomplete (i.e. the voting preferences and voting results are missing)

Raises:
    HTTPException: Validation errors or no results or no states and such.
 * @summary Full Iteration
 */
export type fullIterationGnimbusAllIterationsPostResponse200 = {
	data: GNIMBUSAllIterationsResponse;
	status: 200;
};

export type fullIterationGnimbusAllIterationsPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type fullIterationGnimbusAllIterationsPostResponseSuccess =
	fullIterationGnimbusAllIterationsPostResponse200 & {
		headers: Headers;
	};
export type fullIterationGnimbusAllIterationsPostResponseError =
	fullIterationGnimbusAllIterationsPostResponse422 & {
		headers: Headers;
	};

export type fullIterationGnimbusAllIterationsPostResponse =
	| fullIterationGnimbusAllIterationsPostResponseSuccess
	| fullIterationGnimbusAllIterationsPostResponseError;

export const getFullIterationGnimbusAllIterationsPostUrl = () => {
	return `http://localhost:8000/gnimbus/all_iterations`;
};

export const fullIterationGnimbusAllIterationsPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<fullIterationGnimbusAllIterationsPostResponse> => {
	return customFetch<fullIterationGnimbusAllIterationsPostResponse>(
		getFullIterationGnimbusAllIterationsPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Switch the phase from one to another. "learning", "crp", "decision" and "compromise" phases are allowed.
 * @summary Switch Phase
 */
export type switchPhaseGnimbusTogglePhasePostResponse200 = {
	data: GNIMBUSSwitchPhaseResponse;
	status: 200;
};

export type switchPhaseGnimbusTogglePhasePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type switchPhaseGnimbusTogglePhasePostResponseSuccess =
	switchPhaseGnimbusTogglePhasePostResponse200 & {
		headers: Headers;
	};
export type switchPhaseGnimbusTogglePhasePostResponseError =
	switchPhaseGnimbusTogglePhasePostResponse422 & {
		headers: Headers;
	};

export type switchPhaseGnimbusTogglePhasePostResponse =
	| switchPhaseGnimbusTogglePhasePostResponseSuccess
	| switchPhaseGnimbusTogglePhasePostResponseError;

export const getSwitchPhaseGnimbusTogglePhasePostUrl = () => {
	return `http://localhost:8000/gnimbus/toggle_phase`;
};

export const switchPhaseGnimbusTogglePhasePost = async (
	gNIMBUSSwitchPhaseRequest: GNIMBUSSwitchPhaseRequest,
	options?: RequestInit
): Promise<switchPhaseGnimbusTogglePhasePostResponse> => {
	return customFetch<switchPhaseGnimbusTogglePhasePostResponse>(
		getSwitchPhaseGnimbusTogglePhasePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(gNIMBUSSwitchPhaseRequest)
		}
	);
};

/**
 * Get the current phase of the group.
 * @summary Get Phase
 */
export type getPhaseGnimbusGetPhasePostResponse200 = {
	data: unknown;
	status: 200;
};

export type getPhaseGnimbusGetPhasePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getPhaseGnimbusGetPhasePostResponseSuccess = getPhaseGnimbusGetPhasePostResponse200 & {
	headers: Headers;
};
export type getPhaseGnimbusGetPhasePostResponseError = getPhaseGnimbusGetPhasePostResponse422 & {
	headers: Headers;
};

export type getPhaseGnimbusGetPhasePostResponse =
	| getPhaseGnimbusGetPhasePostResponseSuccess
	| getPhaseGnimbusGetPhasePostResponseError;

export const getGetPhaseGnimbusGetPhasePostUrl = () => {
	return `http://localhost:8000/gnimbus/get_phase`;
};

export const getPhaseGnimbusGetPhasePost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<getPhaseGnimbusGetPhasePostResponse> => {
	return customFetch<getPhaseGnimbusGetPhasePostResponse>(getGetPhaseGnimbusGetPhasePostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(groupInfoRequest)
	});
};

/**
 * Changes the starting solution of an iteration so in case of emergency the group owner can just change it.

Args:
    request (GNIMBUSChangeStartingSolutionRequest): The request containing necessary details to fulfill the change.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): The database session.

Raises:
    HTTPException

Returns:
    JSONResponse: Response that acknowledges the changes.
 * @summary Revert Iteration
 */
export type revertIterationGnimbusRevertIterationPostResponse200 = {
	data: unknown;
	status: 200;
};

export type revertIterationGnimbusRevertIterationPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type revertIterationGnimbusRevertIterationPostResponseSuccess =
	revertIterationGnimbusRevertIterationPostResponse200 & {
		headers: Headers;
	};
export type revertIterationGnimbusRevertIterationPostResponseError =
	revertIterationGnimbusRevertIterationPostResponse422 & {
		headers: Headers;
	};

export type revertIterationGnimbusRevertIterationPostResponse =
	| revertIterationGnimbusRevertIterationPostResponseSuccess
	| revertIterationGnimbusRevertIterationPostResponseError;

export const getRevertIterationGnimbusRevertIterationPostUrl = () => {
	return `http://localhost:8000/gnimbus/revert_iteration`;
};

export const revertIterationGnimbusRevertIterationPost = async (
	groupRevertRequest: GroupRevertRequest,
	options?: RequestInit
): Promise<revertIterationGnimbusRevertIterationPostResponse> => {
	return customFetch<revertIterationGnimbusRevertIterationPostResponse>(
		getRevertIterationGnimbusRevertIterationPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupRevertRequest)
		}
	);
};

/**
 * Steps the E-NAUTILUS method.
 * @summary Step
 */
export type stepMethodEnautilusStepPostResponse200 = {
	data: ENautilusStepResponse;
	status: 200;
};

export type stepMethodEnautilusStepPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type stepMethodEnautilusStepPostResponseSuccess = stepMethodEnautilusStepPostResponse200 & {
	headers: Headers;
};
export type stepMethodEnautilusStepPostResponseError = stepMethodEnautilusStepPostResponse422 & {
	headers: Headers;
};

export type stepMethodEnautilusStepPostResponse =
	| stepMethodEnautilusStepPostResponseSuccess
	| stepMethodEnautilusStepPostResponseError;

export const getStepMethodEnautilusStepPostUrl = () => {
	return `http://localhost:8000/method/enautilus/step`;
};

export const stepMethodEnautilusStepPost = async (
	eNautilusStepRequest: ENautilusStepRequest,
	options?: RequestInit
): Promise<stepMethodEnautilusStepPostResponse> => {
	return customFetch<stepMethodEnautilusStepPostResponse>(getStepMethodEnautilusStepPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(eNautilusStepRequest)
	});
};

/**
 * Fetch a previous state of the the E-NAUTILUS method.
 * @summary Get State
 */
export type getStateMethodEnautilusGetStateStateIdGetResponse200 = {
	data: ENautilusStateResponse;
	status: 200;
};

export type getStateMethodEnautilusGetStateStateIdGetResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getStateMethodEnautilusGetStateStateIdGetResponseSuccess =
	getStateMethodEnautilusGetStateStateIdGetResponse200 & {
		headers: Headers;
	};
export type getStateMethodEnautilusGetStateStateIdGetResponseError =
	getStateMethodEnautilusGetStateStateIdGetResponse422 & {
		headers: Headers;
	};

export type getStateMethodEnautilusGetStateStateIdGetResponse =
	| getStateMethodEnautilusGetStateStateIdGetResponseSuccess
	| getStateMethodEnautilusGetStateStateIdGetResponseError;

export const getGetStateMethodEnautilusGetStateStateIdGetUrl = (stateId: number) => {
	return `http://localhost:8000/method/enautilus/get_state/${stateId}`;
};

export const getStateMethodEnautilusGetStateStateIdGet = async (
	stateId: number,
	options?: RequestInit
): Promise<getStateMethodEnautilusGetStateStateIdGetResponse> => {
	return customFetch<getStateMethodEnautilusGetStateStateIdGetResponse>(
		getGetStateMethodEnautilusGetStateStateIdGetUrl(stateId),
		{
			...options,
			method: 'GET'
		}
	);
};

/**
 * Computes the representative solutions that are closest to the intermediate solutions computed by E-NAUTILUS.

This endpoint should be used to get the actual solution from the
non-dominated representation used in the E-NAUTILUS method's last iteration
(when number of iterations left is 0).

Args:
    state_id (int): id of the `StateDB` with information on the intermediate
        points for which the representative solutions should be computed.
    db_session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: 404 when a `StateDB`, `ProblemDB`, or
        `RepresentativeNonDominatedSolutions` instance cannot be found. 406 when
        the substate of the references `StateDB` is not an instance of
        `ENautilusState`.

Returns:
    ENautilusRepresentativeSolutionsResponse: the information on the representative solutions.
 * @summary Get Representative
 */
export type getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponse200 = {
	data: ENautilusRepresentativeSolutionsResponse;
	status: 200;
};

export type getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponseSuccess =
	getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponse200 & {
		headers: Headers;
	};
export type getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponseError =
	getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponse422 & {
		headers: Headers;
	};

export type getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponse =
	| getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponseSuccess
	| getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponseError;

export const getGetRepresentativeMethodEnautilusGetRepresentativeStateIdGetUrl = (
	stateId: number
) => {
	return `http://localhost:8000/method/enautilus/get_representative/${stateId}`;
};

export const getRepresentativeMethodEnautilusGetRepresentativeStateIdGet = async (
	stateId: number,
	options?: RequestInit
): Promise<getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponse> => {
	return customFetch<getRepresentativeMethodEnautilusGetRepresentativeStateIdGetResponse>(
		getGetRepresentativeMethodEnautilusGetRepresentativeStateIdGetUrl(stateId),
		{
			...options,
			method: 'GET'
		}
	);
};

/**
 * Vote for a band using this endpoint.

Args:
    request (GDMScoreBandsVoteRequest): A container for the group id and the vote.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): database session

Raises:
    HTTPException: If something goes wrong. It hopefully let's you know what went wrong.

Returns:
    JSONResponse: A quick confirmation that vote went through.
 * @summary Vote For A Band
 */
export type voteForABandGdmScoreBandsVotePostResponse200 = {
	data: unknown;
	status: 200;
};

export type voteForABandGdmScoreBandsVotePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type voteForABandGdmScoreBandsVotePostResponseSuccess =
	voteForABandGdmScoreBandsVotePostResponse200 & {
		headers: Headers;
	};
export type voteForABandGdmScoreBandsVotePostResponseError =
	voteForABandGdmScoreBandsVotePostResponse422 & {
		headers: Headers;
	};

export type voteForABandGdmScoreBandsVotePostResponse =
	| voteForABandGdmScoreBandsVotePostResponseSuccess
	| voteForABandGdmScoreBandsVotePostResponseError;

export const getVoteForABandGdmScoreBandsVotePostUrl = () => {
	return `http://localhost:8000/gdm-score-bands/vote`;
};

export const voteForABandGdmScoreBandsVotePost = async (
	gDMScoreBandsVoteRequest: GDMScoreBandsVoteRequest,
	options?: RequestInit
): Promise<voteForABandGdmScoreBandsVotePostResponse> => {
	return customFetch<voteForABandGdmScoreBandsVotePostResponse>(
		getVoteForABandGdmScoreBandsVotePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(gDMScoreBandsVoteRequest)
		}
	);
};

/**
 * Confim the vote. If all confirm, the clustering and new iteration begins.

Args:
    request (GroupInfoRequest): Simple request to get the group ID.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): Database session.

Raises:
    HTTPException: If something goes awry. It should let you know what went wrong, though.

Returns:
    JSONResponse: A simple confirmation that everything went ok and that vote went in.
 * @summary Confirm Vote
 */
export type confirmVoteGdmScoreBandsConfirmPostResponse200 = {
	data: unknown;
	status: 200;
};

export type confirmVoteGdmScoreBandsConfirmPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type confirmVoteGdmScoreBandsConfirmPostResponseSuccess =
	confirmVoteGdmScoreBandsConfirmPostResponse200 & {
		headers: Headers;
	};
export type confirmVoteGdmScoreBandsConfirmPostResponseError =
	confirmVoteGdmScoreBandsConfirmPostResponse422 & {
		headers: Headers;
	};

export type confirmVoteGdmScoreBandsConfirmPostResponse =
	| confirmVoteGdmScoreBandsConfirmPostResponseSuccess
	| confirmVoteGdmScoreBandsConfirmPostResponseError;

export const getConfirmVoteGdmScoreBandsConfirmPostUrl = () => {
	return `http://localhost:8000/gdm-score-bands/confirm`;
};

export const confirmVoteGdmScoreBandsConfirmPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<confirmVoteGdmScoreBandsConfirmPostResponse> => {
	return customFetch<confirmVoteGdmScoreBandsConfirmPostResponse>(
		getConfirmVoteGdmScoreBandsConfirmPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * An endpoint for two things: Initializing the GDM Score Bands things and Fetching results.

If a group hasn't been initialized, initialize and then return initial clustering information.
If it has been initialized, just fetch the latest iteration's information (clustering, etc.)

Args:
    request (GDMScoreBandsInitializationRequest): Request that contains necessary information for initialization.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): Database session.

Raises:
    HTTPException: It'll let you know.

Returns:
    GDMSCOREBandsResponse: A response containing Group id, group iter id and ScoreBandsResponse.
 * @summary Get Or Initialize
 */
export type getOrInitializeGdmScoreBandsGetOrInitializePostResponse200 = {
	data: GDMSCOREBandsHistoryResponse;
	status: 200;
};

export type getOrInitializeGdmScoreBandsGetOrInitializePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getOrInitializeGdmScoreBandsGetOrInitializePostResponseSuccess =
	getOrInitializeGdmScoreBandsGetOrInitializePostResponse200 & {
		headers: Headers;
	};
export type getOrInitializeGdmScoreBandsGetOrInitializePostResponseError =
	getOrInitializeGdmScoreBandsGetOrInitializePostResponse422 & {
		headers: Headers;
	};

export type getOrInitializeGdmScoreBandsGetOrInitializePostResponse =
	| getOrInitializeGdmScoreBandsGetOrInitializePostResponseSuccess
	| getOrInitializeGdmScoreBandsGetOrInitializePostResponseError;

export const getGetOrInitializeGdmScoreBandsGetOrInitializePostUrl = () => {
	return `http://localhost:8000/gdm-score-bands/get-or-initialize`;
};

export const getOrInitializeGdmScoreBandsGetOrInitializePost = async (
	gDMScoreBandsInitializationRequest: GDMScoreBandsInitializationRequest,
	options?: RequestInit
): Promise<getOrInitializeGdmScoreBandsGetOrInitializePostResponse> => {
	return customFetch<getOrInitializeGdmScoreBandsGetOrInitializePostResponse>(
		getGetOrInitializeGdmScoreBandsGetOrInitializePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(gDMScoreBandsInitializationRequest)
		}
	);
};

/**
 * Returns the current status of votes and confirmations in current iteration.

Args:
    request (GroupInfoRequest): The group we'd like the info on.
    user (Annotated[User, Depends): The user that requests the data.
    session (Annotated[Session, Depends): The database session.

Raises:
    HTTPException: If group doesn't exists etc errors.

Returns:
    JSONResponse: A response containing the votes and confirmations.
 * @summary Get Votes And Confirms
 */
export type getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse200 = {
	data: unknown;
	status: 200;
};

export type getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponseSuccess =
	getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse200 & {
		headers: Headers;
	};
export type getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponseError =
	getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse422 & {
		headers: Headers;
	};

export type getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse =
	| getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponseSuccess
	| getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponseError;

export const getGetVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostUrl = () => {
	return `http://localhost:8000/gdm-score-bands/get-votes-and-confirms`;
};

export const getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse> => {
	return customFetch<getVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse>(
		getGetVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Revert to a previous iteration. Usable only by the analyst.

This implies that we're gonna need to see ALL previous iterations I'd say.

Args:
    request (GDMSCOREBandsRevertRequest): The request containing group id and iteration number.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): The database session.

Returns:
    JSONResponse: Acknowledgement of the revert.
 * @summary Revert
 */
export type revertGdmScoreBandsRevertPostResponse200 = {
	data: unknown;
	status: 200;
};

export type revertGdmScoreBandsRevertPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type revertGdmScoreBandsRevertPostResponseSuccess =
	revertGdmScoreBandsRevertPostResponse200 & {
		headers: Headers;
	};
export type revertGdmScoreBandsRevertPostResponseError =
	revertGdmScoreBandsRevertPostResponse422 & {
		headers: Headers;
	};

export type revertGdmScoreBandsRevertPostResponse =
	| revertGdmScoreBandsRevertPostResponseSuccess
	| revertGdmScoreBandsRevertPostResponseError;

export const getRevertGdmScoreBandsRevertPostUrl = () => {
	return `http://localhost:8000/gdm-score-bands/revert`;
};

export const revertGdmScoreBandsRevertPost = async (
	gDMSCOREBandsRevertRequest: GDMSCOREBandsRevertRequest,
	options?: RequestInit
): Promise<revertGdmScoreBandsRevertPostResponse> => {
	return customFetch<revertGdmScoreBandsRevertPostResponse>(getRevertGdmScoreBandsRevertPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(gDMSCOREBandsRevertRequest)
	});
};

/**
 * Configure the SCORE Bands settings.

Args:
    config (SCOREBandsGDMConfig): The configuration object
    group_id (int): group id
    user (Annotated[User, Depends): The user doing the request
    session (Annotated[Session, Depends): The database session.

Returns:
    JSONResponse: Acknowledgement that yeah ok reconfigured.
 * @summary Configure Gdm
 */
export type configureGdmGdmScoreBandsConfigurePostResponse200 = {
	data: unknown;
	status: 200;
};

export type configureGdmGdmScoreBandsConfigurePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type configureGdmGdmScoreBandsConfigurePostResponseSuccess =
	configureGdmGdmScoreBandsConfigurePostResponse200 & {
		headers: Headers;
	};
export type configureGdmGdmScoreBandsConfigurePostResponseError =
	configureGdmGdmScoreBandsConfigurePostResponse422 & {
		headers: Headers;
	};

export type configureGdmGdmScoreBandsConfigurePostResponse =
	| configureGdmGdmScoreBandsConfigurePostResponseSuccess
	| configureGdmGdmScoreBandsConfigurePostResponseError;

export const getConfigureGdmGdmScoreBandsConfigurePostUrl = (
	params: ConfigureGdmGdmScoreBandsConfigurePostParams
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? 'null' : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `http://localhost:8000/gdm-score-bands/configure?${stringifiedParams}`
		: `http://localhost:8000/gdm-score-bands/configure`;
};

export const configureGdmGdmScoreBandsConfigurePost = async (
	sCOREBandsGDMConfig: SCOREBandsGDMConfig,
	params: ConfigureGdmGdmScoreBandsConfigurePostParams,
	options?: RequestInit
): Promise<configureGdmGdmScoreBandsConfigurePostResponse> => {
	return customFetch<configureGdmGdmScoreBandsConfigurePostResponse>(
		getConfigureGdmGdmScoreBandsConfigurePostUrl(params),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(sCOREBandsGDMConfig)
		}
	);
};
