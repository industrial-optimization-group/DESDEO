/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * DESDEO (fast)API
 * A rest API for the DESDEO framework.
 * OpenAPI spec version: 0.1.0
 */
import * as zod from 'zod';

/**
 * Return information about the current user.

Args:
    user (Annotated[User, Depends): user dependency, handled by `get_current_user`.

Returns:
    UserPublic: public information about the current user.
 * @summary Get Current User Info
 */
export const getCurrentUserInfoUserInfoGetResponse = zod
	.object({
		username: zod.string(),
		id: zod.number(),
		role: zod.enum(['guest', 'dm', 'analyst', 'admin']).describe('Possible user roles.'),
		group_ids: zod.union([zod.array(zod.number()), zod.null()])
	})
	.describe('The object to handle public user information.');

/**
 * Login to get an authentication token.

Return an access token in the response and a cookie storing a refresh token.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
        The form data to authenticate the user.
    session (Annotated[Session, Depends(get_db)]): The database session.
    cookie_max_age (int): the lifetime of the cookie storing the refresh token.
 * @summary Login
 */
export const loginLoginPostQueryCookieMaxAgeDefault = 30;

export const loginLoginPostQueryParams = zod.object({
	cookie_max_age: zod.number().default(loginLoginPostQueryCookieMaxAgeDefault)
});

export const loginLoginPostResponse = zod
	.object({
		access_token: zod.string(),
		refresh_token: zod.string(),
		token_type: zod.string()
	})
	.describe('A model for the authentication token.');

/**
 * Log the current user out. Deletes the refresh token that was set by logging in.

Args:
    None

Returns:
    JSONResponse: A response in which the cookies are deleted
 * @summary Logout
 */
export const logoutLogoutPostResponse = zod.unknown();

/**
 * Refresh the access token using the refresh token stored in the cookie.

Args:
    request (Request): The request containing the cookie.
    session (Annotated[Session, Depends(get_db)]): the database session.
    refresh_token (Annotated[Str | None, Cookie()]): the refresh
        token, which is fetched from a cookie included in the response.

Returns:
    dict: A dictionary containing the new access token.
 * @summary Refresh Access Token
 */
export const refreshAccessTokenRefreshPostResponse = zod.unknown();

/**
 * Add a new user of the role Decision Maker to the database. Requires no login.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if username is already in use or if saving to the database fails for some reason.
 * @summary Add New Dm
 */
export const addNewDmAddNewDmPostResponse = zod.unknown();

/**
 * Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin.

Args:
    user: Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
    form_data: (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session: (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if the logged in user is not an analyst or an admin or if
    username is already in use or if saving to the database fails for some reason.
 * @summary Add New Analyst
 */
export const addNewAnalystAddNewAnalystPostResponse = zod.unknown();

/**
 * Get information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfoSmall]: a list of information on all the problems.
 * @summary Get Problems
 */
export const getProblemsProblemAllGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const getProblemsProblemAllGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const getProblemsProblemAllGetResponseItem = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsProblemAllGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsProblemAllGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data, but smaller.');
export const getProblemsProblemAllGetResponse = zod.array(getProblemsProblemAllGetResponseItem);

/**
 * Get detailed information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfo]: a list of the detailed information on all the problems.
 * @summary Get Problems Info
 */
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemMaximizeDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsLinearDefault = true;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseDiscreteRepresentationNonDominatedDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const getProblemsInfoProblemAllInfoGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const getProblemsInfoProblemAllInfoGetResponseItem = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.optional()
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.optional()
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(getProblemsInfoProblemAllInfoGetResponseConstraintsItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod.boolean().optional(),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsInfoProblemAllInfoGetResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsInfoProblemAllInfoGetResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');
export const getProblemsInfoProblemAllInfoGetResponse = zod.array(
	getProblemsInfoProblemAllInfoGetResponseItem
);

/**
 * Get the model of a specific problem.

Args:
    request (ProblemGetRequest): the request containing the problem's id `problem_id`.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find a problem with the given id.

Returns:
    ProblemInfo: detailed information on the requested problem.
 * @summary Get Problem
 */
export const getProblemProblemGetPostBody = zod
	.object({
		problem_id: zod.number()
	})
	.describe('Model to deal with problem fetching requests.');

export const getProblemProblemGetPostResponseObjectivesItemMaximizeDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseConstraintsItemIsLinearDefault = true;
export const getProblemProblemGetPostResponseConstraintsItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseConstraintsItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseDiscreteRepresentationNonDominatedDefault = false;
export const getProblemProblemGetPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const getProblemProblemGetPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const getProblemProblemGetPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.optional()
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.optional()
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(getProblemProblemGetPostResponseConstraintsItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod.boolean().optional(),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemProblemGetPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemProblemGetPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Add a newly defined problem to the database.

Args:
    request (Problem): the JSON representation of the problem.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Note:
    Users with the role 'guest' may not add new problems.

Raises:
    HTTPException: when any issue with defining the problem arises.

Returns:
    ProblemInfo: the information about the problem added.
 * @summary Add Problem
 */
export const addProblemProblemAddPostResponseObjectivesItemMaximizeDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseConstraintsItemIsLinearDefault = true;
export const addProblemProblemAddPostResponseConstraintsItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseConstraintsItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseDiscreteRepresentationNonDominatedDefault = false;
export const addProblemProblemAddPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const addProblemProblemAddPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const addProblemProblemAddPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.optional()
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.optional()
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(addProblemProblemAddPostResponseConstraintsItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod.boolean().optional(),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemProblemAddPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemProblemAddPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Adds a problem to the database based on its JSON definition.

Args:
    json_file (UploadFile): a file in JSON format describing the problem.
    user (Annotated[User, Depends): the usr for which the problem is added.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: if the provided `json_file` is empty.
    HTTPException: if the content in the provided `json_file` is not in JSON format.__annotations__

Returns:
    ProblemInfo: a description of the added problem.
 * @summary Add Problem Json
 */
export const addProblemJsonProblemAddJsonPostBody = zod.object({
	json_file: zod.instanceof(File)
});

export const addProblemJsonProblemAddJsonPostResponseObjectivesItemMaximizeDefault = false;
export const addProblemJsonProblemAddJsonPostResponseObjectivesItemIsLinearDefault = false;
export const addProblemJsonProblemAddJsonPostResponseObjectivesItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseConstraintsItemIsLinearDefault = true;
export const addProblemJsonProblemAddJsonPostResponseConstraintsItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseConstraintsItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseScalarizationFuncsItemIsLinearDefault = false;
export const addProblemJsonProblemAddJsonPostResponseScalarizationFuncsItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseScalarizationFuncsItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseExtraFuncsItemIsLinearDefault = false;
export const addProblemJsonProblemAddJsonPostResponseExtraFuncsItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseExtraFuncsItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseDiscreteRepresentationNonDominatedDefault = false;
export const addProblemJsonProblemAddJsonPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault =
	'forest_problem_metadata';
export const addProblemJsonProblemAddJsonPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault =
	'representative_non_dominated_solutions';

export const addProblemJsonProblemAddJsonPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.optional()
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.optional()
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.optional()
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(addProblemJsonProblemAddJsonPostResponseConstraintsItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.optional()
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.optional()
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod.boolean().optional(),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemJsonProblemAddJsonPostResponseProblemMetadataForestMetadataItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemJsonProblemAddJsonPostResponseProblemMetadataRepresentativeNdMetadataItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Fetch specific metadata for a specific problem.

Fetch specific metadata for a specific problem. See all the possible
metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata
section.

Args:
    request (MetaDataGetRequest): the requested metadata type.
    user (Annotated[User, Depends]): the current user.
    session (Annotated[Session, Depends]): the database session.

Returns:
    list[ForestProblemMetadata | RepresentativeNonDominatedSolutions]: list containing all the metadata
        defined for the problem with the requested metadata type. If no match is found,
        returns an empty list.
 * @summary Get Metadata
 */
export const getMetadataProblemGetMetadataPostBody = zod
	.object({
		problem_id: zod.number(),
		metadata_type: zod.string()
	})
	.describe('Request model for getting specific type of metadata from a specific problem.');

export const getMetadataProblemGetMetadataPostResponseMetadataTypeDefault =
	'forest_problem_metadata';
export const getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultOne =
	'representative_non_dominated_solutions';
export const getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultTwo =
	'solver_selection_metadata';

export const getMetadataProblemGetMetadataPostResponseItem = zod.union([
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseMetadataTypeDefault),
			map_json: zod.string(),
			schedule_dict: zod.record(zod.string(), zod.unknown()),
			years: zod.array(zod.string()),
			stand_id_field: zod.string(),
			stand_descriptor: zod.union([zod.record(zod.string(), zod.unknown()), zod.null()]).optional(),
			compensation: zod.union([zod.number(), zod.null()]).optional()
		})
		.describe('A problem metadata class to hold UTOPIA forest problem specific information.'),
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultOne),
			name: zod.string().describe('The name of the representative set.'),
			description: zod
				.union([zod.string(), zod.null()])
				.optional()
				.describe('A description of the representative set. Optional.'),
			solution_data: zod
				.record(zod.string(), zod.array(zod.number()))
				.describe(
					'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
				),
			ideal: zod
				.record(zod.string(), zod.number())
				.describe('The ideal objective function values of the representative set.'),
			nadir: zod
				.record(zod.string(), zod.number())
				.describe('The nadir objective function values of the representative set.')
		})
		.describe(
			'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
		),
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseMetadataTypeDefaultTwo),
			solver_string_representation: zod
				.string()
				.describe('The string representation of the selected solver.')
		})
		.describe(
			'A problem metadata class to store the preferred solver of a problem.\n\nA problem metadata class to store the preferred solver of a problem.\nSee desdeo/tools/utils.py -> available_solvers for available solvers.'
		)
]);
export const getMetadataProblemGetMetadataPostResponse = zod.array(
	getMetadataProblemGetMetadataPostResponseItem
);

/**
 * Assign a specific solver for a problem.

request: ProblemSelectSolverRequest: The request containing problem id and string representation of the solver
user: Annotated[User, Depends(get_current_user): The user that is logged in.
session: Annotated[Session, Depends(get_session)]: The database session.

Raises:
    HTTPException: Unknown solver, unauthorized user

Returns:
    JSONResponse: A simple confirmation.
 * @summary Select Solver
 */
export const selectSolverProblemAssignSolverPostBody = zod
	.object({
		problem_id: zod.number(),
		solver_string_representation: zod.string()
	})
	.describe('Model to request a specific solver for a problem.');

export const selectSolverProblemAssignSolverPostResponse = zod.unknown();

/**
 * .
 * @summary Create New Session
 */
export const createNewSessionSessionNewPostBody = zod
	.object({
		info: zod.union([zod.string(), zod.null()]).optional()
	})
	.describe('Model of the request to create a new session.');

export const createNewSessionSessionNewPostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]),
		user_id: zod.union([zod.number(), zod.null()]),
		info: zod.union([zod.string(), zod.null()])
	})
	.describe('The base model for representing interactive sessions.');

/**
 * Return an interactive session with a given id for the current user.

Args:
    request (GetSessionRequest): a request containing the id of the session.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find an interactive session with the given id
        for the current user.

Returns:
    InteractiveSessionInfo: info on the requested interactive session.
 * @summary Get Session
 */
export const getSessionSessionGetPostBody = zod
	.object({
		session_id: zod.number()
	})
	.describe('Model of the request to get a specific session.');

export const getSessionSessionGetPostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]),
		user_id: zod.union([zod.number(), zod.null()]),
		info: zod.union([zod.string(), zod.null()])
	})
	.describe('The base model for representing interactive sessions.');

/**
 * Runs an iteration of the reference point method.

Args:
    request (RPMSolveRequest): a request with the needed information to run the method.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the current database session.

Returns:
    RPMState: a state with information on the results of iterating the reference point method
        once.
 * @summary Solve Solutions
 */
export const solveSolutionsMethodRpmSolvePostBodyPreferencePreferenceTypeDefault =
	'reference_point';

export const solveSolutionsMethodRpmSolvePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodRpmSolvePostBodyPreferencePreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.optional()
			.describe('Model for representing a reference point type of preference.')
	})
	.describe('Model of the request to the reference point method.');

export const solveSolutionsMethodRpmSolvePostResponsePreferencesPreferenceTypeDefault =
	'reference_point';

export const solveSolutionsMethodRpmSolvePostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]).optional(),
		preferences: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodRpmSolvePostResponsePreferencesPreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.describe('Model for representing a reference point type of preference.'),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver_results: zod.array(
			zod
				.object({
					optimal_variables: zod
						.record(zod.string(), zod.union([zod.number(), zod.number(), zod.array(zod.unknown())]))
						.describe('The optimal decision variables found.'),
					optimal_objectives: zod
						.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())]))
						.describe(
							'The objective function values corresponding to the optimal decision variables found.'
						),
					constraint_values: zod
						.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.array(zod.number()),
									zod.array(zod.unknown())
								])
							),
							zod.unknown(),
							zod.null()
						])
						.optional()
						.describe(
							'The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.'
						),
					extra_func_values: zod
						.union([
							zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
							zod.null()
						])
						.optional()
						.describe('The extra function values of the problem.'),
					scalarization_values: zod
						.union([
							zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
							zod.null()
						])
						.optional()
						.describe('The scalarization function values of the problem.'),
					success: zod
						.boolean()
						.describe('A boolean flag indicating whether the optimization was successful or not.'),
					message: zod.string().describe('Description of the cause of termination.')
				})
				.describe('Defines a schema for a dataclass to store the results of a solver.')
		)
	})
	.describe('Reference Point Method (k+1 candidates).');

/**
 * Solve the problem using the NIMBUS method.
 * @summary Solve Solutions
 */
export const solveSolutionsMethodNimbusSolvePostBodyPreferencePreferenceTypeDefault =
	'reference_point';
export const solveSolutionsMethodNimbusSolvePostBodyNumDesiredDefault = 1;

export const solveSolutionsMethodNimbusSolvePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodNimbusSolvePostBodyPreferencePreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.optional()
			.describe('Model for representing a reference point type of preference.'),
		current_objectives: zod
			.record(zod.string(), zod.number())
			.describe('The objectives used for iteration.'),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveSolutionsMethodNimbusSolvePostBodyNumDesiredDefault)
	})
	.describe('Model of the request to the nimbus method.');

export const solveSolutionsMethodNimbusSolvePostResponsePreviousPreferencePreferenceTypeDefault =
	'reference_point';

export const solveSolutionsMethodNimbusSolvePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		previous_preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(
						solveSolutionsMethodNimbusSolvePostResponsePreviousPreferencePreferenceTypeDefault
					),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.describe('Model for representing a reference point type of preference.'),
		previous_objectives: zod
			.record(zod.string(), zod.number())
			.describe('The previous solutions objectives used for iteration.'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current iteration of nimbus.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Initialize the problem for the NIMBUS method.
 * @summary Initialize
 */
export const initializeMethodNimbusInitializePostBodyStartingPointPreferenceTypeDefault =
	'reference_point';

export const initializeMethodNimbusInitializePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		starting_point: zod
			.union([
				zod
					.object({
						preference_type: zod
							.literal('reference_point')
							.default(initializeMethodNimbusInitializePostBodyStartingPointPreferenceTypeDefault),
						aspiration_levels: zod.record(zod.string(), zod.number())
					})
					.describe('Model for representing a reference point type of preference.'),
				zod
					.object({
						state_id: zod.number(),
						solution_index: zod.number(),
						name: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe('Name to be given to the solution. Optional.')
					})
					.describe(
						'Used when we wish to reference a solution in some `StateDB` stored in the database.'
					),
				zod.null()
			])
			.optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional()
	})
	.describe('Model of the request to the nimbus method.');

export const initializeMethodNimbusInitializePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current interation of nimbus.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Save solutions.
 * @summary Save
 */
export const saveMethodNimbusSavePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		solution_info: zod.array(
			zod
				.object({
					state_id: zod.number(),
					solution_index: zod.number(),
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Name to be given to the solution. Optional.')
				})
				.describe(
					'Used when we wish to reference a solution in some `StateDB` stored in the database.'
				)
		)
	})
	.describe("Request model for saving solutions from any method's state.");

export const saveMethodNimbusSavePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The id of the newest state')
	})
	.describe('The response from NIMBUS save endpoint.');

/**
 * Solve intermediate solutions by forwarding the request to generic intermediate endpoint with context nimbus.
 * @summary Solve Nimbus Intermediate
 */
export const solveNimbusIntermediateMethodNimbusIntermediatePostBodyNumDesiredDefault = 1;

export const solveNimbusIntermediateMethodNimbusIntermediatePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		context: zod.union([zod.string(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveNimbusIntermediateMethodNimbusIntermediatePostBodyNumDesiredDefault),
		reference_solution_1: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			),
		reference_solution_2: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('Model of the request to solve intermediate solutions between two solutions.');

export const solveNimbusIntermediateMethodNimbusIntermediatePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		reference_solution_1: zod
			.record(zod.string(), zod.number())
			.describe('The first solution used when computing intermediate points.'),
		reference_solution_2: zod
			.record(zod.string(), zod.number())
			.describe('The second solution used when computing intermediate points.'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current iteration of NIMBUS.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Get the latest NIMBUS state if it exists, or initialize a new one if it doesn't.
 * @summary Get Or Initialize
 */
export const getOrInitializeMethodNimbusGetOrInitializePostBodyStartingPointPreferenceTypeDefault =
	'reference_point';

export const getOrInitializeMethodNimbusGetOrInitializePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		starting_point: zod
			.union([
				zod
					.object({
						preference_type: zod
							.literal('reference_point')
							.default(
								getOrInitializeMethodNimbusGetOrInitializePostBodyStartingPointPreferenceTypeDefault
							),
						aspiration_levels: zod.record(zod.string(), zod.number())
					})
					.describe('Model for representing a reference point type of preference.'),
				zod
					.object({
						state_id: zod.number(),
						solution_index: zod.number(),
						name: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe('Name to be given to the solution. Optional.')
					})
					.describe(
						'Used when we wish to reference a solution in some `StateDB` stored in the database.'
					),
				zod.null()
			])
			.optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional()
	})
	.describe('Model of the request to the nimbus method.');

export const getOrInitializeMethodNimbusGetOrInitializePostResponsePreviousPreferencePreferenceTypeDefault =
	'reference_point';

export const getOrInitializeMethodNimbusGetOrInitializePostResponse = zod.union([
	zod
		.object({
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current interation of nimbus.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.'),
	zod
		.object({
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			previous_preference: zod
				.object({
					preference_type: zod
						.literal('reference_point')
						.default(
							getOrInitializeMethodNimbusGetOrInitializePostResponsePreviousPreferencePreferenceTypeDefault
						),
					aspiration_levels: zod.record(zod.string(), zod.number())
				})
				.describe('Model for representing a reference point type of preference.'),
			previous_objectives: zod
				.record(zod.string(), zod.number())
				.describe('The previous solutions objectives used for iteration.'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current iteration of nimbus.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.'),
	zod
		.object({
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			reference_solution_1: zod
				.record(zod.string(), zod.number())
				.describe('The first solution used when computing intermediate points.'),
			reference_solution_2: zod
				.record(zod.string(), zod.number())
				.describe('The second solution used when computing intermediate points.'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current iteration of NIMBUS.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.')
]);

/**
 * An endpoint for finishing up the nimbus process.

Args:
    request (NIMBUSFinalizeRequest): The request containing the final solution, etc.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): The database session.

Raises:
    HTTPException

Returns:
    NIMBUSFinalizeResponse: Response containing state id of the final solution.
 * @summary Finalize Nimbus
 */
export const finalizeNimbusMethodNimbusFinalizePostBodyPreferencesPreferenceTypeDefault =
	'reference_point';

export const finalizeNimbusMethodNimbusFinalizePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		solution_info: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			),
		preferences: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(finalizeNimbusMethodNimbusFinalizePostBodyPreferencesPreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.describe('Model for representing a reference point type of preference.')
	})
	.describe('Request model for finalizing the NIMBUS procedure.');

export const finalizeNimbusMethodNimbusFinalizePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The id of the newest state'),
		final_solution: zod
			.object({
				name: zod.union([zod.string(), zod.null()]),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			)
	})
	.describe('The response from NIMBUS finish endpoint.');

/**
 * Endpoint for deleting saved solutions.

Args:
    request (NIMBUSDeleteSaveRequest): request containing necessary information for deleting a save
    user (Annotated[User, Depends): the current  (logged in) user
    session (Annotated[Session, Depends): database session

Raises:
    HTTPException

Returns:
    NIMBUSDeleteSaveResponse: Response acknowledging the deletion of save and other useful info.
 * @summary Delete Save
 */
export const deleteSaveMethodNimbusDeleteSavePostBody = zod
	.object({
		state_id: zod.number().describe('The ID of the save state.'),
		solution_index: zod.number().describe('The ID of the solution within the above state.')
	})
	.describe('Request model for deletion of a saved solution.');

export const deleteSaveMethodNimbusDeleteSavePostResponse = zod
	.object({
		message: zod.union([zod.string(), zod.null()])
	})
	.describe('Response of NIMBUS save deletion.');

/**
 * Starts the EMO method.

Args:
    request (EMOSolveRequest): The request object containing parameters for the EMO method.
    user (Annotated[User, Depends]): The current user.
    session (Annotated[Session, Depends]): The database session.

Raises:
    HTTPException: If the request is invalid or the EMO method fails.

Returns:
    IterateResponse: A response object containing a list of IDs to be used for websocket communication.
        Also contains the StateDB id where the results will be stored.
 * @summary Iterate
 */
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefault =
	'SimulatedBinaryCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefault = 0.5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMin = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMax = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverDistributionDefault = 30;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOne =
	'SinglePointBinaryCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultTwo =
	'UniformIntegerCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultThree =
	'UniformMixedIntegerCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultFour =
	'BlendAlphaCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaDefault = 0.5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaMin = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultOne = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinOne = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxOne = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultFive =
	'SingleArithmeticCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultTwo = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinTwo = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxTwo = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultSix =
	'LocalCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultThree = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinThree = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxThree = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultSeven =
	'BoundedExponentialCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultFour = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinFour = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxFour = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverLambdaDefault = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefault =
	'BoundedPolynomialMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOne = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOne = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationDistributionIndexDefault = 20;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOne =
	'BinaryFlipMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFour = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFour = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultTwo =
	'IntegerRandomMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinSeven = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxSeven = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultThree =
	'MixedIntegerRandomMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnezero = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnezero = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultFour =
	'MPTMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnethree = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnethree = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentDefault = 2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentMin = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultFive =
	'NonUniformMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnesix = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnesix = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBDefault = 5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBMin = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultSix =
	'SelfAdaptiveGaussianMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnenine = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnenine = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultSeven =
	'PowerMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinTwotwo = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxTwotwo = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPDefault = 1.5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPMin = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefault =
	'RVEASelector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationFrequencyDefault = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefault =
	'simplex';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefault =
	'spherical';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefault = 200;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefault = 0.2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionAlphaDefault = 2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultOne =
	'NSGA2Selector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultTwo =
	'NSGA3Selector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationFrequencyDefaultOne = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefaultOne =
	'simplex';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefaultOne =
	'spherical';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefaultOne = 200;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefaultOne = 0.2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionInvertReferenceVectorsDefault = false;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultThree =
	'IBEASelector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionKappaDefault = 0.05;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionBinaryIndicatorDefault =
	'eps';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefault =
	'MaxGenerationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxGenerationsDefault = 100;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultOne =
	'MaxEvaluationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxEvaluationsDefault = 10000;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultTwo =
	'MaxTimeTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxTimeDefault = 30;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultThree =
	'ExternalCheckTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultFour =
	'CompositeTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefault =
	'MaxEvaluationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxEvaluationsDefault = 10000;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultOne =
	'MaxGenerationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxGenerationsDefault = 100;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultTwo =
	'MaxTimeTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxTimeDefault = 30;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultThree =
	'ExternalCheckTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationModeDefault = 'any';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefault =
	'LHSGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultOne =
	'RandomBinaryGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultTwo =
	'RandomGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultThree =
	'RandomIntegerGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultFour =
	'RandomMixedIntegerGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefault = 'ClipRepair';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefaultOne = 'NoRepair';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairDefault = { name: 'NoRepair' };
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemUseArchiveDefault = true;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSeedDefault = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemVerbosityDefault = 2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemNameDefault = 'Template1';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultEight =
	'SimulatedBinaryCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultFive = 0.5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinFive = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxFive = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverDistributionDefaultOne = 30;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultNine =
	'SinglePointBinaryCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnezero =
	'UniformIntegerCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOneone =
	'UniformMixedIntegerCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnetwo =
	'BlendAlphaCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaDefaultOne = 0.5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaMinOne = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultSix = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinSix = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxSix = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnethree =
	'SingleArithmeticCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultSeven = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinSeven = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxSeven = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnefour =
	'LocalCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultEight = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinEight = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxEight = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnefive =
	'BoundedExponentialCrossover';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultNine = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinNine = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxNine = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverLambdaDefaultOne = 1;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultEight =
	'BoundedPolynomialMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinTwofive = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxTwofive = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationDistributionIndexDefaultOne = 20;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultNine =
	'BinaryFlipMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinTwoeight = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxTwoeight = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnezero =
	'IntegerRandomMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinThreeone = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxThreeone = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOneone =
	'MixedIntegerRandomMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinThreefour = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxThreefour = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnetwo =
	'MPTMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinThreeseven = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxThreeseven = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentDefaultOne = 2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentMinOne = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnethree =
	'NonUniformMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFourzero = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFourzero = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBDefaultOne = 5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBMinOne = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnefour =
	'SelfAdaptiveGaussianMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFourthree = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFourthree = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnefive =
	'PowerMutation';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFoursix = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFoursix = 1;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPDefaultOne = 1.5;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPMinOne = 0;

export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultFour =
	'RVEASelector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationFrequencyDefaultTwo = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefaultTwo =
	'simplex';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefaultTwo =
	'spherical';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefaultTwo = 200;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefaultTwo = 0.2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionAlphaDefaultOne = 2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultFive =
	'NSGA2Selector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultSix =
	'NSGA3Selector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationFrequencyDefaultThree = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefaultThree =
	'simplex';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefaultThree =
	'spherical';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefaultThree = 200;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefaultThree = 0.2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionInvertReferenceVectorsDefaultOne = false;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultSeven =
	'IBEASelector';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionKappaDefaultOne = 0.05;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionBinaryIndicatorDefaultOne =
	'eps';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultFive =
	'MaxGenerationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxGenerationsDefaultOne = 100;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultSix =
	'MaxEvaluationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxEvaluationsDefaultOne = 10000;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultSeven =
	'MaxTimeTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxTimeDefaultOne = 30;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultEight =
	'ExternalCheckTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultNine =
	'CompositeTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultFour =
	'MaxEvaluationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxEvaluationsDefaultOne = 10000;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultFive =
	'MaxGenerationsTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxGenerationsDefaultOne = 100;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultSix =
	'MaxTimeTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxTimeDefaultOne = 30;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultSeven =
	'ExternalCheckTerminator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationModeDefaultOne = 'any';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultFive =
	'LHSGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultSix =
	'RandomBinaryGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultSeven =
	'RandomGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultEight =
	'RandomIntegerGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultNine =
	'RandomMixedIntegerGenerator';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefaultTwo = 'ClipRepair';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefaultThree = 'NoRepair';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairDefaultThree = {
	name: 'NoRepair'
};
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemUseArchiveDefaultOne = true;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemSeedDefaultOne = 0;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemVerbosityDefaultOne = 2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemNameDefaultOne = 'Template2';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionNameDefault =
	'TournamentSelection';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionTournamentSizeDefault = 2;
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionNameDefaultOne =
	'RouletteWheelSelection';
export const iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionTournamentSizeDefaultOne = 2;
export const iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefault = 'reference_point';
export const iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefault = 'Hakanen';
export const iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefaultOne = 'preferred_ranges';
export const iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefaultOne = 'Hakanen';
export const iterateMethodEmoIteratePostBodyPreferenceOptionsDesirabilityLevelsDefault = [0.9, 0.1];
export const iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefaultTwo = 'preferred_solutions';
export const iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefaultTwo = 'Hakanen';
export const iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefaultThree =
	'non_preferred_solutions';
export const iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefaultThree = 'Hakanen';

export const iterateMethodEmoIteratePostBody = zod
	.object({
		problem_id: zod.number().describe('Database ID of the problem to solve.'),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod
			.union([zod.number(), zod.null()])
			.optional()
			.describe(
				'State ID of the parent state, if any. Should be None if this is the first state in a session.'
			),
		template_options: zod
			.union([
				zod.array(
					zod.union([
						zod
							.object({
								crossover: zod
									.union([
										zod
											.object({
												name: zod
													.literal('SimulatedBinaryCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefault
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMin
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMax
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefault
													)
													.describe('The SBX crossover probability.'),
												xover_distribution: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverDistributionDefault
													)
													.describe('The SBX distribution index.')
											})
											.describe('Options for Simulated Binary Crossover (SBX).'),
										zod
											.object({
												name: zod
													.literal('SinglePointBinaryCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOne
													)
													.describe('The name of the crossover operator.')
											})
											.describe('Options for Single Point Binary Crossover.'),
										zod
											.object({
												name: zod
													.literal('UniformIntegerCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultTwo
													)
													.describe('The name of the crossover operator.')
											})
											.describe('Options for Uniform Integer Crossover.'),
										zod
											.object({
												name: zod
													.literal('UniformMixedIntegerCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultThree
													)
													.describe('The name of the crossover operator.')
											})
											.describe('Options for Uniform Mixed Integer Crossover.'),
										zod
											.object({
												name: zod
													.literal('BlendAlphaCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultFour
													)
													.describe('The name of the crossover operator.'),
												alpha: zod
													.number()
													.min(iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaMin)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaDefault
													)
													.describe(
														"Non-negative blending factor 'alpha' that controls the extent to which offspring may be sampled outside the interval defined by each pair of parent genes. alpha = 0 restricts children strictly within the parents range, larger alpha allows some outliers."
													),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinOne
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxOne
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultOne
													)
											})
											.describe('Options for Blend Alpha Crossover.'),
										zod
											.object({
												name: zod
													.literal('SingleArithmeticCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultFive
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinTwo
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxTwo
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultTwo
													)
													.describe('The crossover probability.')
											})
											.describe('Options for Single Arithmetic Crossover.'),
										zod
											.object({
												name: zod
													.literal('LocalCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultSix
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinThree
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxThree
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultThree
													)
													.describe('The crossover probability.')
											})
											.describe('Options for Local Crossover.'),
										zod
											.object({
												name: zod
													.literal('BoundedExponentialCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultSeven
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinFour
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxFour
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultFour
													)
													.describe('The crossover probability.'),
												lambda_: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverLambdaDefault
													)
													.describe('Positive scale Œª for the exponential distribution.')
											})
											.describe('Options for Bounded Exponential Crossover.')
									])
									.describe('The crossover operator options.'),
								mutation: zod
									.union([
										zod
											.object({
												name: zod
													.literal('BoundedPolynomialMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefault
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOne
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOne
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to\n1/<number of decision variables>.'
													),
												distribution_index: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationDistributionIndexDefault
													)
													.describe('The distribution index.')
											})
											.describe('Options for Bounded Polynomial Mutation.'),
										zod
											.object({
												name: zod
													.literal('BinaryFlipMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOne
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFour
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFour
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Binary Flip Mutation.'),
										zod
											.object({
												name: zod
													.literal('IntegerRandomMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultTwo
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinSeven
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxSeven
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Integer Random Mutation.'),
										zod
											.object({
												name: zod
													.literal('MixedIntegerRandomMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultThree
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnezero
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnezero
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Mixed Integer Random Mutation.'),
										zod
											.object({
												name: zod
													.literal('MPTMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultFour
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnethree
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnethree
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													),
												mutation_exponent: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentMin
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentDefault
													)
													.describe(
														'Controls strength of small mutation (larger means smaller mutations).'
													)
											})
											.describe('Options for MPT Mutation.'),
										zod
											.object({
												name: zod
													.literal('NonUniformMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultFive
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnesix
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnesix
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													),
												max_generations: zod
													.number()
													.describe(
														'Maximum number of generations in the evolutionary run. Used to scale mutation decay.'
													),
												b: zod
													.number()
													.min(iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBMin)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBDefault
													)
													.describe(
														'Non-uniform mutation decay parameter. Higher values causefaster reduction in mutation strength over generations.'
													)
											})
											.describe('Options for Non-Uniform Mutation.'),
										zod
											.object({
												name: zod
													.literal('SelfAdaptiveGaussianMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultSix
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinOnenine
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxOnenine
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Self-Adaptive Gaussian Mutation.'),
										zod
											.object({
												name: zod
													.literal('PowerMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultSeven
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinTwotwo
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxTwotwo
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													),
												p: zod
													.number()
													.min(iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPMin)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPDefault
													)
													.describe(
														'Power distribution parameter. Controls the perturbation magnitude.'
													)
											})
											.describe('Options for Power Mutation.')
									])
									.describe('The mutation operator options.'),
								selection: zod
									.union([
										zod
											.object({
												name: zod
													.literal('RVEASelector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefault
													)
													.describe('The name of the selection operator.'),
												reference_vector_options: zod
													.object({
														adaptation_frequency: zod
															.number()
															.optional()
															.describe(
																'Number of generations between reference vector adaptation. If set to 0, no adaptation occurs. Defaults to 0.\nOnly used if no preference is provided.'
															),
														creation_type: zod
															.enum(['simplex', 's_energy'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefault
															)
															.describe(
																'The method for creating reference vectors. Defaults to \"simplex\".\nCurrently only \"simplex\" is implemented. Future versions will include \"s_energy\".\n\nIf set to \"simplex\", the reference vectors are created using the simplex lattice design method.\nThis method is generates distributions with specific numbers of reference vectors.\nCheck: https://www.itl.nist.gov/div898/handbook/pri/section5/pri542.htm for more information.\nIf set to \"s_energy\", the reference vectors are created using the Riesz s-energy criterion. This method is used to\ndistribute an arbitrary number of reference vectors in the objective space while minimizing the s-energy.\nCurrently not implemented.'
															),
														vector_type: zod
															.enum(['spherical', 'planar'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefault
															)
															.describe(
																'The method for normalizing the reference vectors. Defaults to \"spherical\".'
															),
														lattice_resolution: zod
															.union([zod.number(), zod.null()])
															.optional()
															.describe(
																'Number of divisions along an axis when creating the simplex lattice. This is not required/used for the \"s_energy\"\nmethod. If not specified, the lattice resolution is calculated based on the `number_of_vectors`. If \"spherical\" is \nselected as the `vector_type`, this value overrides the `number_of_vectors`.'
															),
														number_of_vectors: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefault
															)
															.describe(
																'Number of reference vectors to be created. If \"simplex\" is selected as the `creation_type`, then the closest\n`lattice_resolution` is calculated based on this value. If \"s_energy\" is selected, then this value is used directly.\nNote that if neither `lattice_resolution` nor `number_of_vectors` is specified, the number of vectors defaults to\n200. Overridden if \"spherical\" is selected as the `vector_type` and `lattice_resolution` is provided.'
															),
														adaptation_distance: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefault
															)
															.describe(
																'Distance parameter for the interactive adaptation methods. Defaults to 0.2.'
															),
														reference_point: zod
															.union([zod.record(zod.string(), zod.number()), zod.null()])
															.optional()
															.describe('The reference point for interactive adaptation.'),
														preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred solutions for interactive adaptation.'),
														non_preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The non-preferred solutions for interactive adaptation.'),
														preferred_ranges: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred ranges for interactive adaptation.')
													})
													.optional()
													.describe('Pydantic model for Reference Vector arguments.'),
												parameter_adaptation_strategy: zod
													.enum(['GENERATION_BASED', 'FUNCTION_EVALUATION_BASED', 'OTHER'])
													.optional()
													.describe('The parameter adaptation strategies for the RVEA selector.'),
												alpha: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionAlphaDefault
													)
													.describe('The alpha parameter in the angle penalized distance.')
											})
											.describe('Options for RVEA Selection.'),
										zod
											.object({
												name: zod
													.literal('NSGA2Selector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultOne
													)
													.describe('The name of the selection operator.'),
												population_size: zod.number().describe('The population size.')
											})
											.describe('Options for NSGA-II Selection.'),
										zod
											.object({
												name: zod
													.literal('NSGA3Selector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultTwo
													)
													.describe('The name of the selection operator.'),
												reference_vector_options: zod
													.object({
														adaptation_frequency: zod
															.number()
															.optional()
															.describe(
																'Number of generations between reference vector adaptation. If set to 0, no adaptation occurs. Defaults to 0.\nOnly used if no preference is provided.'
															),
														creation_type: zod
															.enum(['simplex', 's_energy'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefaultOne
															)
															.describe(
																'The method for creating reference vectors. Defaults to \"simplex\".\nCurrently only \"simplex\" is implemented. Future versions will include \"s_energy\".\n\nIf set to \"simplex\", the reference vectors are created using the simplex lattice design method.\nThis method is generates distributions with specific numbers of reference vectors.\nCheck: https://www.itl.nist.gov/div898/handbook/pri/section5/pri542.htm for more information.\nIf set to \"s_energy\", the reference vectors are created using the Riesz s-energy criterion. This method is used to\ndistribute an arbitrary number of reference vectors in the objective space while minimizing the s-energy.\nCurrently not implemented.'
															),
														vector_type: zod
															.enum(['spherical', 'planar'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefaultOne
															)
															.describe(
																'The method for normalizing the reference vectors. Defaults to \"spherical\".'
															),
														lattice_resolution: zod
															.union([zod.number(), zod.null()])
															.optional()
															.describe(
																'Number of divisions along an axis when creating the simplex lattice. This is not required/used for the \"s_energy\"\nmethod. If not specified, the lattice resolution is calculated based on the `number_of_vectors`. If \"spherical\" is \nselected as the `vector_type`, this value overrides the `number_of_vectors`.'
															),
														number_of_vectors: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefaultOne
															)
															.describe(
																'Number of reference vectors to be created. If \"simplex\" is selected as the `creation_type`, then the closest\n`lattice_resolution` is calculated based on this value. If \"s_energy\" is selected, then this value is used directly.\nNote that if neither `lattice_resolution` nor `number_of_vectors` is specified, the number of vectors defaults to\n200. Overridden if \"spherical\" is selected as the `vector_type` and `lattice_resolution` is provided.'
															),
														adaptation_distance: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefaultOne
															)
															.describe(
																'Distance parameter for the interactive adaptation methods. Defaults to 0.2.'
															),
														reference_point: zod
															.union([zod.record(zod.string(), zod.number()), zod.null()])
															.optional()
															.describe('The reference point for interactive adaptation.'),
														preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred solutions for interactive adaptation.'),
														non_preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The non-preferred solutions for interactive adaptation.'),
														preferred_ranges: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred ranges for interactive adaptation.')
													})
													.optional()
													.describe('Pydantic model for Reference Vector arguments.'),
												invert_reference_vectors: zod
													.boolean()
													.optional()
													.describe('Whether to invert the reference vectors (inverted triangle).')
											})
											.describe('Options for NSGA-III Selection.'),
										zod
											.object({
												name: zod
													.literal('IBEASelector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultThree
													)
													.describe('The name of the selection operator.'),
												population_size: zod.number().describe('The population size.'),
												kappa: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionKappaDefault
													)
													.describe('The kappa parameter for IBEA.'),
												binary_indicator: zod
													.enum(['eps', 'hv'])
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionBinaryIndicatorDefault
													)
													.describe('The binary indicator for IBEA.')
											})
											.describe('Options for IBEA Selection.')
									])
									.describe('The selection operator options.'),
								termination: zod
									.union([
										zod
											.object({
												name: zod
													.literal('MaxGenerationsTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefault
													)
													.describe('The name of the termination operator.'),
												max_generations: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxGenerationsDefault
													)
													.describe('The maximum number of generations allowed.')
											})
											.describe('Options for max generations terminator operator.'),
										zod
											.object({
												name: zod
													.literal('MaxEvaluationsTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultOne
													)
													.describe('The name of the termination operator.'),
												max_evaluations: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxEvaluationsDefault
													)
													.describe('The maximum number of evaluations allowed.')
											})
											.describe('Options for max evaluations terminator operator.'),
										zod
											.object({
												name: zod
													.literal('MaxTimeTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultTwo
													)
													.describe('The name of the termination operator.'),
												max_time: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxTimeDefault
													)
													.describe('The maximum time allowed (in seconds).')
											})
											.describe('Options for max time terminator operator.'),
										zod
											.object({
												name: zod
													.literal('ExternalCheckTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultThree
													)
													.describe('The name of the termination operator.')
											})
											.describe(
												'Options for external check terminator operator. Note that the check function must be provided separately.'
											),
										zod
											.object({
												name: zod
													.literal('CompositeTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultFour
													)
													.describe('The name of the termination operator.'),
												terminators: zod
													.array(
														zod.union([
															zod
																.object({
																	name: zod
																		.literal('MaxEvaluationsTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefault
																		)
																		.describe('The name of the termination operator.'),
																	max_evaluations: zod
																		.number()
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxEvaluationsDefault
																		)
																		.describe('The maximum number of evaluations allowed.')
																})
																.describe('Options for max evaluations terminator operator.'),
															zod
																.object({
																	name: zod
																		.literal('MaxGenerationsTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultOne
																		)
																		.describe('The name of the termination operator.'),
																	max_generations: zod
																		.number()
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxGenerationsDefault
																		)
																		.describe('The maximum number of generations allowed.')
																})
																.describe('Options for max generations terminator operator.'),
															zod
																.object({
																	name: zod
																		.literal('MaxTimeTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultTwo
																		)
																		.describe('The name of the termination operator.'),
																	max_time: zod
																		.number()
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxTimeDefault
																		)
																		.describe('The maximum time allowed (in seconds).')
																})
																.describe('Options for max time terminator operator.'),
															zod
																.object({
																	name: zod
																		.literal('ExternalCheckTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultThree
																		)
																		.describe('The name of the termination operator.')
																})
																.describe(
																	'Options for external check terminator operator. Note that the check function must be provided separately.'
																)
														])
													)
													.optional()
													.describe('List of terminators.'),
												mode: zod
													.enum(['all', 'any'])
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationModeDefault
													)
													.describe('Whether to use logical AND or OR.')
											})
											.describe('Options for composite terminator operator.')
									])
									.describe('The termination operator options.'),
								generator: zod
									.union([
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('LHSGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefault
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Latin Hypercube Sampling (LHS) generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomBinaryGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultOne
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random Binary generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultTwo
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomIntegerGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultThree
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random Integer generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomMixedIntegerGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultFour
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random Mixed Integer generator.')
									])
									.describe('The population generator options.'),
								repair: zod
									.union([
										zod
											.object({
												name: zod
													.literal('ClipRepair')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefault
													)
													.describe('Clip the solutions to be within the variable bounds.'),
												lower_bounds: zod
													.union([zod.record(zod.string(), zod.number()), zod.null()])
													.optional()
													.describe(
														'Lower bounds for the decision variables. If none, the lower bounds from the problem will be used.'
													),
												upper_bounds: zod
													.union([zod.record(zod.string(), zod.number()), zod.null()])
													.optional()
													.describe(
														'Upper bounds for the decision variables. If none, the upper bounds from the problem will be used.'
													)
											})
											.describe('Options for Clip Repair.'),
										zod
											.object({
												name: zod
													.literal('NoRepair')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefaultOne
													)
													.describe('Do not apply any repair to the solutions.')
											})
											.describe('Options for No Repair.')
									])
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairDefault)
									.describe('The repair operator options.'),
								use_archive: zod
									.boolean()
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemUseArchiveDefault)
									.describe('Whether to use an archive.'),
								seed: zod.number().optional().describe('The seed for random number generation.'),
								verbosity: zod
									.number()
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemVerbosityDefault)
									.describe('The verbosity level of the operators.'),
								algorithm_name: zod.string().describe('The unique name of the algorithm.'),
								name: zod
									.literal('Template1')
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemNameDefault)
									.describe('The name of the template.')
							})
							.describe(
								'Options for template 1.\n\nTemplate 1 is used by methods such as NSGA-III and RVEA. See\n[template1][desdeo.emo.methods.templates.template1] for\nmore details.'
							),
						zod
							.object({
								crossover: zod
									.union([
										zod
											.object({
												name: zod
													.literal('SimulatedBinaryCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultEight
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinFive
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxFive
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultFive
													)
													.describe('The SBX crossover probability.'),
												xover_distribution: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverDistributionDefaultOne
													)
													.describe('The SBX distribution index.')
											})
											.describe('Options for Simulated Binary Crossover (SBX).'),
										zod
											.object({
												name: zod
													.literal('SinglePointBinaryCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultNine
													)
													.describe('The name of the crossover operator.')
											})
											.describe('Options for Single Point Binary Crossover.'),
										zod
											.object({
												name: zod
													.literal('UniformIntegerCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnezero
													)
													.describe('The name of the crossover operator.')
											})
											.describe('Options for Uniform Integer Crossover.'),
										zod
											.object({
												name: zod
													.literal('UniformMixedIntegerCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOneone
													)
													.describe('The name of the crossover operator.')
											})
											.describe('Options for Uniform Mixed Integer Crossover.'),
										zod
											.object({
												name: zod
													.literal('BlendAlphaCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnetwo
													)
													.describe('The name of the crossover operator.'),
												alpha: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaMinOne
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverAlphaDefaultOne
													)
													.describe(
														"Non-negative blending factor 'alpha' that controls the extent to which offspring may be sampled outside the interval defined by each pair of parent genes. alpha = 0 restricts children strictly within the parents range, larger alpha allows some outliers."
													),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinSix
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxSix
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultSix
													)
											})
											.describe('Options for Blend Alpha Crossover.'),
										zod
											.object({
												name: zod
													.literal('SingleArithmeticCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnethree
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinSeven
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxSeven
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultSeven
													)
													.describe('The crossover probability.')
											})
											.describe('Options for Single Arithmetic Crossover.'),
										zod
											.object({
												name: zod
													.literal('LocalCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnefour
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinEight
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxEight
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultEight
													)
													.describe('The crossover probability.')
											})
											.describe('Options for Local Crossover.'),
										zod
											.object({
												name: zod
													.literal('BoundedExponentialCrossover')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverNameDefaultOnefive
													)
													.describe('The name of the crossover operator.'),
												xover_probability: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMinNine
													)
													.max(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityMaxNine
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverXoverProbabilityDefaultNine
													)
													.describe('The crossover probability.'),
												lambda_: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemCrossoverLambdaDefaultOne
													)
													.describe('Positive scale Œª for the exponential distribution.')
											})
											.describe('Options for Bounded Exponential Crossover.')
									])
									.describe('The crossover operator options.'),
								mutation: zod
									.union([
										zod
											.object({
												name: zod
													.literal('BoundedPolynomialMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultEight
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinTwofive
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxTwofive
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to\n1/<number of decision variables>.'
													),
												distribution_index: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationDistributionIndexDefaultOne
													)
													.describe('The distribution index.')
											})
											.describe('Options for Bounded Polynomial Mutation.'),
										zod
											.object({
												name: zod
													.literal('BinaryFlipMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultNine
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinTwoeight
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxTwoeight
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Binary Flip Mutation.'),
										zod
											.object({
												name: zod
													.literal('IntegerRandomMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnezero
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinThreeone
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxThreeone
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Integer Random Mutation.'),
										zod
											.object({
												name: zod
													.literal('MixedIntegerRandomMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOneone
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinThreefour
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxThreefour
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Mixed Integer Random Mutation.'),
										zod
											.object({
												name: zod
													.literal('MPTMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnetwo
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinThreeseven
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxThreeseven
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													),
												mutation_exponent: zod
													.number()
													.min(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentMinOne
													)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationExponentDefaultOne
													)
													.describe(
														'Controls strength of small mutation (larger means smaller mutations).'
													)
											})
											.describe('Options for MPT Mutation.'),
										zod
											.object({
												name: zod
													.literal('NonUniformMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnethree
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFourzero
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFourzero
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													),
												max_generations: zod
													.number()
													.describe(
														'Maximum number of generations in the evolutionary run. Used to scale mutation decay.'
													),
												b: zod
													.number()
													.min(iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBMinOne)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationBDefaultOne
													)
													.describe(
														'Non-uniform mutation decay parameter. Higher values causefaster reduction in mutation strength over generations.'
													)
											})
											.describe('Options for Non-Uniform Mutation.'),
										zod
											.object({
												name: zod
													.literal('SelfAdaptiveGaussianMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnefour
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFourthree
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFourthree
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													)
											})
											.describe('Options for Self-Adaptive Gaussian Mutation.'),
										zod
											.object({
												name: zod
													.literal('PowerMutation')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationNameDefaultOnefive
													)
													.describe('The name of the mutation operator.'),
												mutation_probability: zod
													.union([
														zod
															.number()
															.min(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMinFoursix
															)
															.max(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationMutationProbabilityMaxFoursix
															),
														zod.null()
													])
													.optional()
													.describe(
														'The probability of mutation. Defaults to None, which sets the mutation probability to 1/<number of decision variables>.'
													),
												p: zod
													.number()
													.min(iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPMinOne)
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMutationPDefaultOne
													)
													.describe(
														'Power distribution parameter. Controls the perturbation magnitude.'
													)
											})
											.describe('Options for Power Mutation.')
									])
									.describe('The mutation operator options.'),
								selection: zod
									.union([
										zod
											.object({
												name: zod
													.literal('RVEASelector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultFour
													)
													.describe('The name of the selection operator.'),
												reference_vector_options: zod
													.object({
														adaptation_frequency: zod
															.number()
															.optional()
															.describe(
																'Number of generations between reference vector adaptation. If set to 0, no adaptation occurs. Defaults to 0.\nOnly used if no preference is provided.'
															),
														creation_type: zod
															.enum(['simplex', 's_energy'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefaultTwo
															)
															.describe(
																'The method for creating reference vectors. Defaults to \"simplex\".\nCurrently only \"simplex\" is implemented. Future versions will include \"s_energy\".\n\nIf set to \"simplex\", the reference vectors are created using the simplex lattice design method.\nThis method is generates distributions with specific numbers of reference vectors.\nCheck: https://www.itl.nist.gov/div898/handbook/pri/section5/pri542.htm for more information.\nIf set to \"s_energy\", the reference vectors are created using the Riesz s-energy criterion. This method is used to\ndistribute an arbitrary number of reference vectors in the objective space while minimizing the s-energy.\nCurrently not implemented.'
															),
														vector_type: zod
															.enum(['spherical', 'planar'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefaultTwo
															)
															.describe(
																'The method for normalizing the reference vectors. Defaults to \"spherical\".'
															),
														lattice_resolution: zod
															.union([zod.number(), zod.null()])
															.optional()
															.describe(
																'Number of divisions along an axis when creating the simplex lattice. This is not required/used for the \"s_energy\"\nmethod. If not specified, the lattice resolution is calculated based on the `number_of_vectors`. If \"spherical\" is \nselected as the `vector_type`, this value overrides the `number_of_vectors`.'
															),
														number_of_vectors: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefaultTwo
															)
															.describe(
																'Number of reference vectors to be created. If \"simplex\" is selected as the `creation_type`, then the closest\n`lattice_resolution` is calculated based on this value. If \"s_energy\" is selected, then this value is used directly.\nNote that if neither `lattice_resolution` nor `number_of_vectors` is specified, the number of vectors defaults to\n200. Overridden if \"spherical\" is selected as the `vector_type` and `lattice_resolution` is provided.'
															),
														adaptation_distance: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefaultTwo
															)
															.describe(
																'Distance parameter for the interactive adaptation methods. Defaults to 0.2.'
															),
														reference_point: zod
															.union([zod.record(zod.string(), zod.number()), zod.null()])
															.optional()
															.describe('The reference point for interactive adaptation.'),
														preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred solutions for interactive adaptation.'),
														non_preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The non-preferred solutions for interactive adaptation.'),
														preferred_ranges: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred ranges for interactive adaptation.')
													})
													.optional()
													.describe('Pydantic model for Reference Vector arguments.'),
												parameter_adaptation_strategy: zod
													.enum(['GENERATION_BASED', 'FUNCTION_EVALUATION_BASED', 'OTHER'])
													.optional()
													.describe('The parameter adaptation strategies for the RVEA selector.'),
												alpha: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionAlphaDefaultOne
													)
													.describe('The alpha parameter in the angle penalized distance.')
											})
											.describe('Options for RVEA Selection.'),
										zod
											.object({
												name: zod
													.literal('NSGA2Selector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultFive
													)
													.describe('The name of the selection operator.'),
												population_size: zod.number().describe('The population size.')
											})
											.describe('Options for NSGA-II Selection.'),
										zod
											.object({
												name: zod
													.literal('NSGA3Selector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultSix
													)
													.describe('The name of the selection operator.'),
												reference_vector_options: zod
													.object({
														adaptation_frequency: zod
															.number()
															.optional()
															.describe(
																'Number of generations between reference vector adaptation. If set to 0, no adaptation occurs. Defaults to 0.\nOnly used if no preference is provided.'
															),
														creation_type: zod
															.enum(['simplex', 's_energy'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsCreationTypeDefaultThree
															)
															.describe(
																'The method for creating reference vectors. Defaults to \"simplex\".\nCurrently only \"simplex\" is implemented. Future versions will include \"s_energy\".\n\nIf set to \"simplex\", the reference vectors are created using the simplex lattice design method.\nThis method is generates distributions with specific numbers of reference vectors.\nCheck: https://www.itl.nist.gov/div898/handbook/pri/section5/pri542.htm for more information.\nIf set to \"s_energy\", the reference vectors are created using the Riesz s-energy criterion. This method is used to\ndistribute an arbitrary number of reference vectors in the objective space while minimizing the s-energy.\nCurrently not implemented.'
															),
														vector_type: zod
															.enum(['spherical', 'planar'])
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsVectorTypeDefaultThree
															)
															.describe(
																'The method for normalizing the reference vectors. Defaults to \"spherical\".'
															),
														lattice_resolution: zod
															.union([zod.number(), zod.null()])
															.optional()
															.describe(
																'Number of divisions along an axis when creating the simplex lattice. This is not required/used for the \"s_energy\"\nmethod. If not specified, the lattice resolution is calculated based on the `number_of_vectors`. If \"spherical\" is \nselected as the `vector_type`, this value overrides the `number_of_vectors`.'
															),
														number_of_vectors: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsNumberOfVectorsDefaultThree
															)
															.describe(
																'Number of reference vectors to be created. If \"simplex\" is selected as the `creation_type`, then the closest\n`lattice_resolution` is calculated based on this value. If \"s_energy\" is selected, then this value is used directly.\nNote that if neither `lattice_resolution` nor `number_of_vectors` is specified, the number of vectors defaults to\n200. Overridden if \"spherical\" is selected as the `vector_type` and `lattice_resolution` is provided.'
															),
														adaptation_distance: zod
															.number()
															.default(
																iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionReferenceVectorOptionsAdaptationDistanceDefaultThree
															)
															.describe(
																'Distance parameter for the interactive adaptation methods. Defaults to 0.2.'
															),
														reference_point: zod
															.union([zod.record(zod.string(), zod.number()), zod.null()])
															.optional()
															.describe('The reference point for interactive adaptation.'),
														preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred solutions for interactive adaptation.'),
														non_preferred_solutions: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The non-preferred solutions for interactive adaptation.'),
														preferred_ranges: zod
															.union([
																zod.record(zod.string(), zod.array(zod.number())),
																zod.null()
															])
															.optional()
															.describe('The preferred ranges for interactive adaptation.')
													})
													.optional()
													.describe('Pydantic model for Reference Vector arguments.'),
												invert_reference_vectors: zod
													.boolean()
													.optional()
													.describe('Whether to invert the reference vectors (inverted triangle).')
											})
											.describe('Options for NSGA-III Selection.'),
										zod
											.object({
												name: zod
													.literal('IBEASelector')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionNameDefaultSeven
													)
													.describe('The name of the selection operator.'),
												population_size: zod.number().describe('The population size.'),
												kappa: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionKappaDefaultOne
													)
													.describe('The kappa parameter for IBEA.'),
												binary_indicator: zod
													.enum(['eps', 'hv'])
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemSelectionBinaryIndicatorDefaultOne
													)
													.describe('The binary indicator for IBEA.')
											})
											.describe('Options for IBEA Selection.')
									])
									.describe('The selection operator options.'),
								termination: zod
									.union([
										zod
											.object({
												name: zod
													.literal('MaxGenerationsTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultFive
													)
													.describe('The name of the termination operator.'),
												max_generations: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxGenerationsDefaultOne
													)
													.describe('The maximum number of generations allowed.')
											})
											.describe('Options for max generations terminator operator.'),
										zod
											.object({
												name: zod
													.literal('MaxEvaluationsTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultSix
													)
													.describe('The name of the termination operator.'),
												max_evaluations: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxEvaluationsDefaultOne
													)
													.describe('The maximum number of evaluations allowed.')
											})
											.describe('Options for max evaluations terminator operator.'),
										zod
											.object({
												name: zod
													.literal('MaxTimeTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultSeven
													)
													.describe('The name of the termination operator.'),
												max_time: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationMaxTimeDefaultOne
													)
													.describe('The maximum time allowed (in seconds).')
											})
											.describe('Options for max time terminator operator.'),
										zod
											.object({
												name: zod
													.literal('ExternalCheckTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultEight
													)
													.describe('The name of the termination operator.')
											})
											.describe(
												'Options for external check terminator operator. Note that the check function must be provided separately.'
											),
										zod
											.object({
												name: zod
													.literal('CompositeTerminator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationNameDefaultNine
													)
													.describe('The name of the termination operator.'),
												terminators: zod
													.array(
														zod.union([
															zod
																.object({
																	name: zod
																		.literal('MaxEvaluationsTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultFour
																		)
																		.describe('The name of the termination operator.'),
																	max_evaluations: zod
																		.number()
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxEvaluationsDefaultOne
																		)
																		.describe('The maximum number of evaluations allowed.')
																})
																.describe('Options for max evaluations terminator operator.'),
															zod
																.object({
																	name: zod
																		.literal('MaxGenerationsTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultFive
																		)
																		.describe('The name of the termination operator.'),
																	max_generations: zod
																		.number()
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxGenerationsDefaultOne
																		)
																		.describe('The maximum number of generations allowed.')
																})
																.describe('Options for max generations terminator operator.'),
															zod
																.object({
																	name: zod
																		.literal('MaxTimeTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultSix
																		)
																		.describe('The name of the termination operator.'),
																	max_time: zod
																		.number()
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemMaxTimeDefaultOne
																		)
																		.describe('The maximum time allowed (in seconds).')
																})
																.describe('Options for max time terminator operator.'),
															zod
																.object({
																	name: zod
																		.literal('ExternalCheckTerminator')
																		.default(
																			iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationTerminatorsItemNameDefaultSeven
																		)
																		.describe('The name of the termination operator.')
																})
																.describe(
																	'Options for external check terminator operator. Note that the check function must be provided separately.'
																)
														])
													)
													.optional()
													.describe('List of terminators.'),
												mode: zod
													.enum(['all', 'any'])
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemTerminationModeDefaultOne
													)
													.describe('Whether to use logical AND or OR.')
											})
											.describe('Options for composite terminator operator.')
									])
									.describe('The termination operator options.'),
								generator: zod
									.union([
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('LHSGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultFive
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Latin Hypercube Sampling (LHS) generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomBinaryGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultSix
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random Binary generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultSeven
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomIntegerGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultEight
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random Integer generator.'),
										zod
											.object({
												n_points: zod
													.number()
													.describe('The number of points to generate for the initial population.'),
												name: zod
													.literal('RandomMixedIntegerGenerator')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemGeneratorNameDefaultNine
													)
													.describe('The name of the generator.')
											})
											.describe('Options for Random Mixed Integer generator.')
									])
									.describe('The population generator options.'),
								repair: zod
									.union([
										zod
											.object({
												name: zod
													.literal('ClipRepair')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefaultTwo
													)
													.describe('Clip the solutions to be within the variable bounds.'),
												lower_bounds: zod
													.union([zod.record(zod.string(), zod.number()), zod.null()])
													.optional()
													.describe(
														'Lower bounds for the decision variables. If none, the lower bounds from the problem will be used.'
													),
												upper_bounds: zod
													.union([zod.record(zod.string(), zod.number()), zod.null()])
													.optional()
													.describe(
														'Upper bounds for the decision variables. If none, the upper bounds from the problem will be used.'
													)
											})
											.describe('Options for Clip Repair.'),
										zod
											.object({
												name: zod
													.literal('NoRepair')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairNameDefaultThree
													)
													.describe('Do not apply any repair to the solutions.')
											})
											.describe('Options for No Repair.')
									])
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemRepairDefaultThree)
									.describe('The repair operator options.'),
								use_archive: zod
									.boolean()
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemUseArchiveDefaultOne)
									.describe('Whether to use an archive.'),
								seed: zod.number().optional().describe('The seed for random number generation.'),
								verbosity: zod
									.number()
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemVerbosityDefaultOne)
									.describe('The verbosity level of the operators.'),
								algorithm_name: zod.string().describe('The unique name of the algorithm.'),
								name: zod
									.literal('Template2')
									.default(iterateMethodEmoIteratePostBodyTemplateOptionsItemNameDefaultOne)
									.describe('The name of the template.'),
								mate_selection: zod
									.union([
										zod
											.object({
												name: zod
													.literal('TournamentSelection')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionNameDefault
													)
													.describe('The name of the scalar selection operator.'),
												tournament_size: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionTournamentSizeDefault
													)
													.describe('The number of individuals participating in the tournament.'),
												winner_size: zod
													.number()
													.describe(
														'The number of winners to select (equivalent to population size).'
													)
											})
											.describe('Options for tournament selection operator.'),
										zod
											.object({
												name: zod
													.literal('RouletteWheelSelection')
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionNameDefaultOne
													)
													.describe('The name of the scalar selection operator.'),
												tournament_size: zod
													.number()
													.default(
														iterateMethodEmoIteratePostBodyTemplateOptionsItemMateSelectionTournamentSizeDefaultOne
													)
													.describe('The number of individuals participating in the tournament.'),
												winner_size: zod
													.number()
													.describe(
														'The number of winners to select (equivalent to population size).'
													)
											})
											.describe('Options for roulette wheel selection operator.')
									])
									.describe('The mate selection operator options.')
							})
							.describe(
								'Options for template 2.\n\nTemplate 2 is used by methods such as IBEA. See\n[template2][desdeo.emo.methods.templates.template2] for\nmore details.'
							)
					])
				),
				zod.null()
			])
			.optional()
			.describe(
				'Options for the template to use. A list of options can be given if multiple templates are used in parallel.'
			),
		preference_options: zod
			.union([
				zod
					.object({
						name: zod
							.literal('reference_point')
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefault)
							.describe('The name of the reference point option.'),
						preference: zod
							.record(zod.string(), zod.number())
							.describe(
								'The reference point as a dictionary with objective function symbols as the keys.'
							),
						method: zod
							.enum(['Hakanen', 'IOPIS'])
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefault)
							.describe('The method for handling the reference point.')
					})
					.describe('Options for providing a reference point for an EA.'),
				zod
					.object({
						name: zod
							.literal('preferred_ranges')
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefaultOne)
							.describe('The name of the preferred ranges option.'),
						aspiration_levels: zod
							.record(zod.string(), zod.number())
							.describe(
								'The aspiration levels as a dictionary with objective function symbols as the keys.'
							),
						reservation_levels: zod
							.record(zod.string(), zod.number())
							.describe(
								'The reservation levels as a dictionary with objective function symbols as the keys.'
							),
						method: zod
							.enum(['Hakanen', 'DF transformation'])
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefaultOne)
							.describe('The method for handling the desirable ranges.'),
						desirability_levels: zod
							.tuple([zod.number(), zod.number()])
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsDesirabilityLevelsDefault)
							.describe(
								'The desirability levels as a tuple (high, low). Used if method is DF transformation. If None, default levels (0.9, 0.1) are used.'
							)
					})
					.describe('Options for providing desirable ranges for an EA.'),
				zod
					.object({
						name: zod
							.literal('preferred_solutions')
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefaultTwo)
							.describe('The name of the preferred solutions option.'),
						preference: zod
							.record(zod.string(), zod.array(zod.number()))
							.describe(
								'The preferred solutions as a dictionary with objective function symbols as the keys.'
							),
						method: zod
							.literal('Hakanen')
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefaultTwo)
							.describe('The method for handling the preferred solutions.')
					})
					.describe('Options for providing preferred solutions for an EA.'),
				zod
					.object({
						name: zod
							.literal('non_preferred_solutions')
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsNameDefaultThree)
							.describe('The name of the non-preferred solutions option.'),
						preference: zod
							.record(zod.string(), zod.array(zod.number()))
							.describe(
								'The non-preferred solutions as a dictionary with objective function symbols as the keys.'
							),
						method: zod
							.literal('Hakanen')
							.default(iterateMethodEmoIteratePostBodyPreferenceOptionsMethodDefaultThree)
							.describe('The method for handling the non-preferred solutions.')
					})
					.describe('Options for providing non-preferred solutions for an EA.'),
				zod.null()
			])
			.optional()
			.describe('Options for the preference handling.')
	})
	.describe('Model of the request to iterate an EMO method.');

export const iterateMethodEmoIteratePostResponse = zod
	.object({
		method_ids: zod
			.array(zod.string())
			.describe('IDs of the EMO methods using websockets to get/send updates.'),
		client_id: zod.string().describe('Client ID to use when connecting to the websockets.'),
		state_id: zod.number().describe('The state ID of the newly created state.')
	})
	.describe('Model of the response to an EMO iterate request.');

/**
 * Fetches results from a completed EMO method.

Args:
    request (EMOFetchRequest): The request object containing parameters for fetching results.
    user (Annotated[User, Depends]): The current user.
    session (Annotated[Session, Depends]): The database session.

Raises:
    HTTPException: If the request is invalid or the EMO method has not completed.

Returns:
    StreamingResponse: A streaming response containing the results of the EMO method.
 * @summary Fetch Results
 */
export const fetchResultsMethodEmoFetchPostBodyNumSolutionsDefault = 0;

export const fetchResultsMethodEmoFetchPostBody = zod
	.object({
		problem_id: zod.number().describe('Database ID of the problem to solve.'),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod
			.union([zod.number(), zod.null()])
			.optional()
			.describe(
				'State ID of the parent state, if any. Should be None if this is the first state in a session.'
			),
		num_solutions: zod
			.number()
			.optional()
			.describe('Number of solutions to fetch. If 0, fetch all solutions.')
	})
	.describe('Model of the request to fetch solutions from an EMO method.');

export const fetchResultsMethodEmoFetchPostResponse = zod.unknown();

/**
 * Fetches results from a completed EMO method.

Args:
    request (EMOFetchRequest): The request object containing parameters for fetching results and of the SCORE bands
        visualization.
    user (Annotated[User, Depends]): The current user.
    session (Annotated[Session, Depends]): The database session.

Raises:
    HTTPException: If the request is invalid or the EMO method has not completed.

Returns:
    SCOREBandsResult: The results of the SCORE bands visualization.
 * @summary Fetch Score Bands
 */
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefault = 'GMM';
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmScoringMethodDefault =
	'silhouette';
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultOne =
	'DBSCAN';
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultTwo =
	'KMeans';
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNClustersDefault = 5;
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultThree =
	'DimensionCluster';
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNClustersDefaultOne = 5;
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmKindDefault =
	'EqualWidth';
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultFour =
	'Custom';
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmDefault = {
	name: 'DBSCAN'
};
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigDistanceParameterDefault = 0.05;
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigUseAbsoluteCorrelationsDefault = false;
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigIncludeSolutionsDefault = false;
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigIncludeMediansDefault = false;
export const fetchScoreBandsMethodEmoFetchScorePostBodyConfigIntervalSizeDefault = 0.95;

export const fetchScoreBandsMethodEmoFetchScorePostBody = zod
	.object({
		problem_id: zod.number().describe('Database ID of the problem to solve.'),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod
			.union([zod.number(), zod.null()])
			.optional()
			.describe('State ID of the parent state, if any.'),
		config: zod
			.union([
				zod
					.object({
						dimensions: zod
							.union([zod.array(zod.string()), zod.null()])
							.optional()
							.describe(
								'List of variable/objective names (i.e., column names in the data) to include in the visualization.\nIf None, all columns in the data are used. Defaults to None.'
							),
						axis_positions: zod
							.union([zod.record(zod.string(), zod.number()), zod.null()])
							.optional()
							.describe(
								'Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first\nobjective is at position 0.0, and the last objective is at position 1.0. Use this option if you want to\nmanually set the axis positions. If None, the axis positions are calculated automatically based on correlations.\nDefaults to None.'
							),
						clustering_algorithm: zod
							.union([
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefault
											)
											.describe('Gaussian Mixture Model clustering algorithm.'),
										scoring_method: zod
											.enum(['BIC', 'silhouette'])
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmScoringMethodDefault
											)
											.describe(
												'Scoring method to use for GMM. Either \"BIC\" or \"silhouette\". Defaults to \"silhouette\".\nThis option determines how the number of clusters is chosen.'
											)
									})
									.describe('Options for Gaussian Mixture Model clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultOne
											)
											.describe('DBSCAN clustering algorithm.')
									})
									.describe('Options for DBSCAN clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultTwo
											)
											.describe('KMeans clustering algorithm.'),
										n_clusters: zod
											.number()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNClustersDefault
											)
											.describe('Number of clusters to use. Defaults to 5.')
									})
									.describe('Options for KMeans clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultThree
											)
											.describe('Clustering by one of the dimensions.'),
										dimension_name: zod.string().describe('Dimension to use for clustering.'),
										n_clusters: zod
											.number()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNClustersDefaultOne
											)
											.describe('Number of clusters to use. Defaults to 5.'),
										kind: zod
											.enum(['EqualWidth', 'EqualFrequency'])
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmKindDefault
											)
											.describe(
												'Kind of clustering to use. Either \"EqualWidth\", which divides the dimension range into equal width intervals,\nor \"EqualFrequency\", which divides the dimension values into intervals with equal number of solutions.\nDefaults to \"EqualWidth\".'
											)
									})
									.describe('Options for clustering by one of the objectives/decision variables.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmNameDefaultFour
											)
											.describe('Custom user-provided clusters.'),
										clusters: zod
											.array(zod.number())
											.describe(
												'List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.'
											)
									})
									.describe('Options for custom clustering provided by the user.')
							])
							.default(fetchScoreBandsMethodEmoFetchScorePostBodyConfigClusteringAlgorithmDefault)
							.describe(
								'Clustering algorithm to use. Currently supported options: \"GMM\", \"DBSCAN\",\n    and \"KMeans\". Defaults to \"DBSCAN\".'
							),
						distance_formula: zod
							.union([zod.literal(1), zod.literal(2)])
							.optional()
							.describe('Distance formulas supported by SCORE bands. See the paper for details.'),
						distance_parameter: zod
							.number()
							.default(fetchScoreBandsMethodEmoFetchScorePostBodyConfigDistanceParameterDefault)
							.describe(
								'Change the relative distances between the objective axes. Increase this value if objectives are placed too close\ntogether. Decrease this value if the objectives are equidistant in a problem with objective clusters. Defaults\nto 0.05.'
							),
						use_absolute_correlations: zod
							.boolean()
							.optional()
							.describe(
								'Whether to use absolute value of the correlation to calculate the placement of axes. Defaults to False.'
							),
						include_solutions: zod
							.boolean()
							.optional()
							.describe(
								'Whether to include individual solutions. Defaults to False. If True, the size of the resulting figure may be\nvery large for datasets with many solutions. Moreover, the individual traces are hidden by default, but can be\nviewed interactively in the figure.'
							),
						include_medians: zod
							.boolean()
							.optional()
							.describe(
								'Whether to include cluster medians. Defaults to False. If True, the median traces are hidden by default, but\ncan be viewed interactively in the figure.'
							),
						interval_size: zod
							.number()
							.default(fetchScoreBandsMethodEmoFetchScorePostBodyConfigIntervalSizeDefault)
							.describe(
								'The size (as a fraction) of the interval to use for the bands. Defaults to 0.95, meaning that 95% of the\nmiddle solutions in a cluster will be included in the band. The rest will be considered outliers.'
							),
						scales: zod
							.union([
								zod.record(zod.string(), zod.tuple([zod.number(), zod.number()])),
								zod.null()
							])
							.optional()
							.describe(
								'Optional dictionary specifying the min and max values for each objective. The keys should be the\nobjective names (i.e., column names in the data), and the values should be tuples of (min, max).\nIf not provided, the min and max will be calculated from the data.'
							)
					})
					.describe('Configuration options for SCORE bands visualization.'),
				zod.null()
			])
			.optional()
			.describe('Configuration for the SCORE bands visualization.'),
		solution_ids: zod.array(zod.number()).describe('List of solution IDs to score.')
	})
	.describe('Request model for getting SCORE bands visualization data from state.');

export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefault =
	'GMM';
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmScoringMethodDefault =
	'silhouette';
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultOne =
	'DBSCAN';
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultTwo =
	'KMeans';
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNClustersDefault = 5;
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultThree =
	'DimensionCluster';
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNClustersDefaultOne = 5;
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmKindDefault =
	'EqualWidth';
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultFour =
	'Custom';
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmDefault =
	{ name: 'DBSCAN' };
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsDistanceParameterDefault = 0.05;
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsUseAbsoluteCorrelationsDefault = false;
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsIncludeSolutionsDefault = false;
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsIncludeMediansDefault = false;
export const fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsIntervalSizeDefault = 0.95;

export const fetchScoreBandsMethodEmoFetchScorePostResponse = zod
	.object({
		state_id: zod
			.union([zod.number(), zod.null()])
			.optional()
			.describe('The state ID of the newly created state.'),
		result: zod
			.object({
				options: zod
					.object({
						dimensions: zod
							.union([zod.array(zod.string()), zod.null()])
							.optional()
							.describe(
								'List of variable/objective names (i.e., column names in the data) to include in the visualization.\nIf None, all columns in the data are used. Defaults to None.'
							),
						axis_positions: zod
							.union([zod.record(zod.string(), zod.number()), zod.null()])
							.optional()
							.describe(
								'Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first\nobjective is at position 0.0, and the last objective is at position 1.0. Use this option if you want to\nmanually set the axis positions. If None, the axis positions are calculated automatically based on correlations.\nDefaults to None.'
							),
						clustering_algorithm: zod
							.union([
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefault
											)
											.describe('Gaussian Mixture Model clustering algorithm.'),
										scoring_method: zod
											.enum(['BIC', 'silhouette'])
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmScoringMethodDefault
											)
											.describe(
												'Scoring method to use for GMM. Either \"BIC\" or \"silhouette\". Defaults to \"silhouette\".\nThis option determines how the number of clusters is chosen.'
											)
									})
									.describe('Options for Gaussian Mixture Model clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultOne
											)
											.describe('DBSCAN clustering algorithm.')
									})
									.describe('Options for DBSCAN clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultTwo
											)
											.describe('KMeans clustering algorithm.'),
										n_clusters: zod
											.number()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNClustersDefault
											)
											.describe('Number of clusters to use. Defaults to 5.')
									})
									.describe('Options for KMeans clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultThree
											)
											.describe('Clustering by one of the dimensions.'),
										dimension_name: zod.string().describe('Dimension to use for clustering.'),
										n_clusters: zod
											.number()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNClustersDefaultOne
											)
											.describe('Number of clusters to use. Defaults to 5.'),
										kind: zod
											.enum(['EqualWidth', 'EqualFrequency'])
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmKindDefault
											)
											.describe(
												'Kind of clustering to use. Either \"EqualWidth\", which divides the dimension range into equal width intervals,\nor \"EqualFrequency\", which divides the dimension values into intervals with equal number of solutions.\nDefaults to \"EqualWidth\".'
											)
									})
									.describe('Options for clustering by one of the objectives/decision variables.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmNameDefaultFour
											)
											.describe('Custom user-provided clusters.'),
										clusters: zod
											.array(zod.number())
											.describe(
												'List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.'
											)
									})
									.describe('Options for custom clustering provided by the user.')
							])
							.default(
								fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsClusteringAlgorithmDefault
							)
							.describe(
								'Clustering algorithm to use. Currently supported options: \"GMM\", \"DBSCAN\",\n    and \"KMeans\". Defaults to \"DBSCAN\".'
							),
						distance_formula: zod
							.union([zod.literal(1), zod.literal(2)])
							.optional()
							.describe('Distance formulas supported by SCORE bands. See the paper for details.'),
						distance_parameter: zod
							.number()
							.default(
								fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsDistanceParameterDefault
							)
							.describe(
								'Change the relative distances between the objective axes. Increase this value if objectives are placed too close\ntogether. Decrease this value if the objectives are equidistant in a problem with objective clusters. Defaults\nto 0.05.'
							),
						use_absolute_correlations: zod
							.boolean()
							.optional()
							.describe(
								'Whether to use absolute value of the correlation to calculate the placement of axes. Defaults to False.'
							),
						include_solutions: zod
							.boolean()
							.optional()
							.describe(
								'Whether to include individual solutions. Defaults to False. If True, the size of the resulting figure may be\nvery large for datasets with many solutions. Moreover, the individual traces are hidden by default, but can be\nviewed interactively in the figure.'
							),
						include_medians: zod
							.boolean()
							.optional()
							.describe(
								'Whether to include cluster medians. Defaults to False. If True, the median traces are hidden by default, but\ncan be viewed interactively in the figure.'
							),
						interval_size: zod
							.number()
							.default(
								fetchScoreBandsMethodEmoFetchScorePostResponseResultOptionsIntervalSizeDefault
							)
							.describe(
								'The size (as a fraction) of the interval to use for the bands. Defaults to 0.95, meaning that 95% of the\nmiddle solutions in a cluster will be included in the band. The rest will be considered outliers.'
							),
						scales: zod
							.union([
								zod.record(zod.string(), zod.tuple([zod.number(), zod.number()])),
								zod.null()
							])
							.optional()
							.describe(
								'Optional dictionary specifying the min and max values for each objective. The keys should be the\nobjective names (i.e., column names in the data), and the values should be tuples of (min, max).\nIf not provided, the min and max will be calculated from the data.'
							)
					})
					.describe('Configuration options for SCORE bands visualization.'),
				ordered_dimensions: zod
					.array(zod.string())
					.describe(
						'List of variable/objective names (i.e., column names in the data).\nOrdered according to their placement in the SCORE bands visualization.'
					),
				clusters: zod
					.array(zod.number())
					.describe(
						'List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.'
					),
				axis_positions: zod
					.record(zod.string(), zod.number())
					.describe(
						'Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first\nobjective is at position 0.0, and the last objective is at position 1.0.'
					),
				bands: zod
					.record(zod.string(), zod.record(zod.string(), zod.tuple([zod.number(), zod.number()])))
					.describe(
						'Dictionary mapping cluster IDs to dictionaries of objective names and their corresponding band\nextremes (min, max).'
					),
				medians: zod
					.record(zod.string(), zod.record(zod.string(), zod.number()))
					.describe(
						'Dictionary mapping cluster IDs to dictionaries of objective names and their corresponding median values.'
					),
				cardinalities: zod
					.record(zod.string(), zod.number())
					.describe('Dictionary mapping cluster IDs to the number of solutions in each cluster.')
			})
			.describe('Pydantic/JSON model for representing SCORE Bands.')
	})
	.describe('Model of the response to an EMO score request.');

/**
 * Solve intermediate solutions between given two solutions.
 * @summary Solve Intermediate
 */
export const solveIntermediateMethodGenericIntermediatePostBodyNumDesiredDefault = 1;

export const solveIntermediateMethodGenericIntermediatePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		context: zod.union([zod.string(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveIntermediateMethodGenericIntermediatePostBodyNumDesiredDefault),
		reference_solution_1: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			),
		reference_solution_2: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('Model of the request to solve intermediate solutions between two solutions.');

export const solveIntermediateMethodGenericIntermediatePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		reference_solution_1: zod
			.object({
				name: zod.union([zod.string(), zod.null()]),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			),
		reference_solution_2: zod
			.object({
				name: zod.union([zod.string(), zod.null()]),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			),
		intermediate_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The intermediate solutions computed.')
	})
	.describe('The response from computing intermediate values.');

/**
 * Calculate SCORE bands parameters from objective data.
 * @summary Calculate Score Bands
 */
export const calculateScoreBandsMethodGenericScoreBandsPostBodyDistParameterDefault = 0.05;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyUseAbsoluteCorrDefault = false;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyDistanceFormulaDefault = 1;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyFlipAxesDefault = true;
export const calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringAlgorithmDefault =
	'DBSCAN';
export const calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringScoreDefault = 'silhoutte';

export const calculateScoreBandsMethodGenericScoreBandsPostBody = zod
	.object({
		data: zod.array(zod.array(zod.number())).describe('Matrix of objective values'),
		objs: zod.array(zod.string()).describe('Array of objective names for each column'),
		dist_parameter: zod
			.number()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyDistParameterDefault)
			.describe('Distance parameter for axis positioning'),
		use_absolute_corr: zod.boolean().optional().describe('Use absolute correlation values'),
		distance_formula: zod
			.number()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyDistanceFormulaDefault)
			.describe('Distance formula (1 or 2)'),
		flip_axes: zod
			.boolean()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyFlipAxesDefault)
			.describe('Whether to flip axes based on correlation signs'),
		clustering_algorithm: zod
			.string()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringAlgorithmDefault)
			.describe('Clustering algorithm (DBSCAN or GMM)'),
		clustering_score: zod
			.string()
			.default(calculateScoreBandsMethodGenericScoreBandsPostBodyClusteringScoreDefault)
			.describe('Clustering score metric')
	})
	.describe('Model of the request to calculate SCORE bands parameters.');

export const calculateScoreBandsMethodGenericScoreBandsPostResponse = zod
	.object({
		groups: zod.array(zod.number()).describe('Cluster group assignments for each data point'),
		axis_dist: zod.array(zod.number()).describe('Normalized axis positions'),
		axis_signs: zod
			.union([zod.array(zod.number()), zod.null()])
			.describe('Axis direction signs (1 or -1)'),
		obj_order: zod.array(zod.number()).describe('Optimal order of objectives')
	})
	.describe('Model of the response containing SCORE bands parameters.');

/**
 * Request and receive the Utopia map corresponding to the decision variables sent.

Args:
    request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested
    for.
    user (Annotated[User, Depend(get_current_user)]) the current user
    session (Annotated[Session, Depends(get_session)]) the current database session
Raises:
    HTTPException:
Returns:
    UtopiaResponse: the map for the forest, to be rendered in frontend
 * @summary Get Utopia Data
 */
export const getUtopiaDataUtopiaPostBody = zod
	.object({
		problem_id: zod.number().describe('Problem for which the map is generated'),
		solution: zod
			.object({
				state_id: zod.number(),
				solution_index: zod.number(),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('The request for an Utopia map.');

export const getUtopiaDataUtopiaPostResponse = zod
	.object({
		is_utopia: zod.boolean().describe('True if map exists for this problem.'),
		map_name: zod.string().describe('Name of the map.'),
		map_json: zod
			.record(zod.string(), zod.unknown())
			.describe('MapJSON representation of the geography.'),
		options: zod
			.record(zod.string(), zod.unknown())
			.describe('A dict with given years as keys containing options for each year.'),
		description: zod.string().describe('Description shown above the map.'),
		years: zod
			.array(zod.string())
			.describe('A list of years for which the maps have been generated.')
	})
	.describe('The response to an UtopiaRequest.');

/**
 * Create group.

Args:
    request (GroupCreateRequest): a request that holds information to be used in creation of the group.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledgement that the gourp was created

Raises:
    HTTPException
 * @summary Create Group
 */
export const createGroupGdmCreateGroupPostBody = zod
	.object({
		group_name: zod.string(),
		problem_id: zod.number()
	})
	.describe('Used for requesting a group to be created.');

export const createGroupGdmCreateGroupPostResponse = zod.unknown();

/**
 * Delete the group with given ID.

Args:
    request (GroupInfoRequest): Contains the ID of the group to be deleted
    user (Annotated[User, Depends(get_current_user)]): The user (in this case must be owner for anything to happen)
    session (Annotated[Session, Depends(get_session)]): The database session

Returns:
    JSONResponse: Aknowledgement of the deletion

Raises:
    HTTPException: Insufficient authorization etc.
 * @summary Delete Group
 */
export const deleteGroupGdmDeleteGroupPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const deleteGroupGdmDeleteGroupPostResponse = zod.unknown();

/**
 * Add a user to a group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been added to the group

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Add To Group
 */
export const addToGroupGdmAddToGroupPostBody = zod
	.object({
		group_id: zod.number(),
		user_id: zod.number()
	})
	.describe('Used for adding a user into group and removing a user from group.');

export const addToGroupGdmAddToGroupPostResponse = zod.unknown();

/**
 * Remove user from group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been removed from the group.

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Remove From Group
 */
export const removeFromGroupGdmRemoveFromGroupPostBody = zod
	.object({
		group_id: zod.number(),
		user_id: zod.number()
	})
	.describe('Used for adding a user into group and removing a user from group.');

export const removeFromGroupGdmRemoveFromGroupPostResponse = zod.unknown();

/**
 * Get information about the group.

Args:
    request (GroupInfoRequest): the id of the group for which we desire info on
    session (Annotated[Session, Depends(get_session)]): the database session

Returns:
    GroupPublic: public info of the group

Raises:
    HTTPException: If there's no group with the requests group id
 * @summary Get Group Info
 */
export const getGroupInfoGdmGetGroupInfoPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const getGroupInfoGdmGetGroupInfoPostResponse = zod
	.object({
		id: zod.number(),
		name: zod.string(),
		owner_id: zod.number(),
		user_ids: zod.array(zod.number()),
		problem_id: zod.number()
	})
	.describe('Response model for Group.');

/**
 * Initialize the problem for GNIMBUS.
 * @summary Gnimbus Initialize
 */
export const gnimbusInitializeGnimbusInitializePostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const gnimbusInitializeGnimbusInitializePostResponse = zod.unknown();

/**
 * Get the latest results from group iteration.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): Current user
    session (Annotated[Session, Depends(get_session)]): Database session.

Returns:
    GNIMBUSResultResponse: A GNIMBUSResultResponse response containing the latest gnimbus results

Raises:
    HTTPException: Validation errors or no results
 * @summary Get Latest Results
 */
export const getLatestResultsGnimbusGetLatestResultsPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefault = 'voting';
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefaultOne =
	'optimization';
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesPhaseDefault =
	'learning';
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesSetPreferencesPreferenceTypeDefault =
	'reference_point';

export const getLatestResultsGnimbusGetLatestResultsPostResponse = zod
	.object({
		method: zod.string(),
		phase: zod.string(),
		preferences: zod.union([
			zod
				.object({
					method: zod
						.string()
						.default(getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefault),
					set_preferences: zod.record(zod.string(), zod.number())
				})
				.describe('Voting preferences.'),
			zod
				.object({
					method: zod
						.string()
						.default(
							getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesMethodDefaultOne
						),
					phase: zod
						.string()
						.default(getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesPhaseDefault),
					set_preferences: zod.record(
						zod.string(),
						zod
							.object({
								preference_type: zod
									.literal('reference_point')
									.default(
										getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesSetPreferencesPreferenceTypeDefault
									),
								aspiration_levels: zod.record(zod.string(), zod.number())
							})
							.describe('Model for representing a reference point type of preference.')
					)
				})
				.describe(
					'An optimization preference class. As for the method and phase, see GNIMBUS for details.'
				)
		]),
		common_results: zod.array(
			zod
				.object({
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Optional name to help identify the solution if, e.g., saved.'),
					solution_index: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe(
							'The index of the referenced solution, if multiple solutions exist in the reference state.'
						),
					state: zod
						.object({
							id: zod.union([zod.number(), zod.null()]).optional(),
							problem_id: zod.union([zod.number(), zod.null()]).optional(),
							session_id: zod.union([zod.number(), zod.null()]).optional(),
							parent_id: zod.union([zod.number(), zod.null()]).optional(),
							state_id: zod.union([zod.number(), zod.null()]).optional()
						})
						.describe('State holder with a single relationship to the base State.'),
					objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
					variable_values_all: zod.array(
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.unknown()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						)
					),
					objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
					variable_values: zod.union([
						zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
						zod.null()
					]),
					state_id: zod.number(),
					num_solutions: zod.number()
				})
				.describe(
					'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
				)
		),
		user_results: zod.array(
			zod
				.object({
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Optional name to help identify the solution if, e.g., saved.'),
					solution_index: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe(
							'The index of the referenced solution, if multiple solutions exist in the reference state.'
						),
					state: zod
						.object({
							id: zod.union([zod.number(), zod.null()]).optional(),
							problem_id: zod.union([zod.number(), zod.null()]).optional(),
							session_id: zod.union([zod.number(), zod.null()]).optional(),
							parent_id: zod.union([zod.number(), zod.null()]).optional(),
							state_id: zod.union([zod.number(), zod.null()]).optional()
						})
						.describe('State holder with a single relationship to the base State.'),
					objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
					variable_values_all: zod.array(
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.unknown()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						)
					),
					objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
					variable_values: zod.union([
						zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
						zod.null()
					]),
					state_id: zod.number(),
					num_solutions: zod.number()
				})
				.describe(
					'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
				)
		),
		personal_result_index: zod.union([zod.number(), zod.null()])
	})
	.describe('The response for getting GNIMBUS results.');

/**
 * Get all results from all iterations of the group.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): current user
    session (Annotated[Session, Depends(get_session)]): current session

Returns:
    GNIMBUSAllIterationsResponse: A GNIMBUSAllIterationsResponse response
    containing all the results of the iterations. If last iteration was optimization,
    the first iteration is incomplete (i.e. the voting preferences and voting results are missing)

Raises:
    HTTPException: Validation errors or no results or no states and such.
 * @summary Full Iteration
 */
export const fullIterationGnimbusAllIterationsPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesMethodDefault =
	'optimization';
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesPhaseDefault =
	'learning';
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesSetPreferencesPreferenceTypeDefault =
	'reference_point';
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesMethodDefault =
	'voting';
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesMethodDefaultOne =
	'end';

export const fullIterationGnimbusAllIterationsPostResponse = zod
	.object({
		all_full_iterations: zod.array(
			zod
				.object({
					phase: zod.string(),
					optimization_preferences: zod.union([
						zod
							.object({
								method: zod
									.string()
									.default(
										fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesMethodDefault
									),
								phase: zod
									.string()
									.default(
										fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesPhaseDefault
									),
								set_preferences: zod.record(
									zod.string(),
									zod
										.object({
											preference_type: zod
												.literal('reference_point')
												.default(
													fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesSetPreferencesPreferenceTypeDefault
												),
											aspiration_levels: zod.record(zod.string(), zod.number())
										})
										.describe('Model for representing a reference point type of preference.')
								)
							})
							.describe(
								'An optimization preference class. As for the method and phase, see GNIMBUS for details.'
							),
						zod.null()
					]),
					voting_preferences: zod.union([
						zod
							.object({
								method: zod
									.string()
									.default(
										fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesMethodDefault
									),
								set_preferences: zod.record(zod.string(), zod.number())
							})
							.describe('Voting preferences.'),
						zod
							.object({
								method: zod
									.string()
									.default(
										fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesMethodDefaultOne
									),
								success: zod.union([zod.boolean(), zod.null()]),
								set_preferences: zod.record(zod.string(), zod.boolean())
							})
							.describe(
								'A model for determining if everyone is happy with current solution so we can end the process.'
							),
						zod.null()
					]),
					starting_result: zod.union([
						zod
							.object({
								name: zod
									.union([zod.string(), zod.null()])
									.optional()
									.describe('Optional name to help identify the solution if, e.g., saved.'),
								solution_index: zod
									.union([zod.number(), zod.null()])
									.optional()
									.describe(
										'The index of the referenced solution, if multiple solutions exist in the reference state.'
									),
								state: zod
									.object({
										id: zod.union([zod.number(), zod.null()]).optional(),
										problem_id: zod.union([zod.number(), zod.null()]).optional(),
										session_id: zod.union([zod.number(), zod.null()]).optional(),
										parent_id: zod.union([zod.number(), zod.null()]).optional(),
										state_id: zod.union([zod.number(), zod.null()]).optional()
									})
									.describe('State holder with a single relationship to the base State.'),
								objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
								variable_values_all: zod.array(
									zod.record(
										zod.string(),
										zod.union([
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.union([
												zod.array(zod.unknown()),
												zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
												zod.number(),
												zod.number(),
												zod.boolean(),
												zod.literal('List'),
												zod.null()
											])
										])
									)
								),
								objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
								variable_values: zod.union([
									zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.null()
								]),
								state_id: zod.number(),
								num_solutions: zod.number()
							})
							.describe(
								'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
							),
						zod.null()
					]),
					common_results: zod.array(
						zod
							.object({
								name: zod
									.union([zod.string(), zod.null()])
									.optional()
									.describe('Optional name to help identify the solution if, e.g., saved.'),
								solution_index: zod
									.union([zod.number(), zod.null()])
									.optional()
									.describe(
										'The index of the referenced solution, if multiple solutions exist in the reference state.'
									),
								state: zod
									.object({
										id: zod.union([zod.number(), zod.null()]).optional(),
										problem_id: zod.union([zod.number(), zod.null()]).optional(),
										session_id: zod.union([zod.number(), zod.null()]).optional(),
										parent_id: zod.union([zod.number(), zod.null()]).optional(),
										state_id: zod.union([zod.number(), zod.null()]).optional()
									})
									.describe('State holder with a single relationship to the base State.'),
								objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
								variable_values_all: zod.array(
									zod.record(
										zod.string(),
										zod.union([
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.union([
												zod.array(zod.unknown()),
												zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
												zod.number(),
												zod.number(),
												zod.boolean(),
												zod.literal('List'),
												zod.null()
											])
										])
									)
								),
								objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
								variable_values: zod.union([
									zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.null()
								]),
								state_id: zod.number(),
								num_solutions: zod.number()
							})
							.describe(
								'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
							)
					),
					user_results: zod.array(
						zod
							.object({
								name: zod
									.union([zod.string(), zod.null()])
									.optional()
									.describe('Optional name to help identify the solution if, e.g., saved.'),
								solution_index: zod
									.union([zod.number(), zod.null()])
									.optional()
									.describe(
										'The index of the referenced solution, if multiple solutions exist in the reference state.'
									),
								state: zod
									.object({
										id: zod.union([zod.number(), zod.null()]).optional(),
										problem_id: zod.union([zod.number(), zod.null()]).optional(),
										session_id: zod.union([zod.number(), zod.null()]).optional(),
										parent_id: zod.union([zod.number(), zod.null()]).optional(),
										state_id: zod.union([zod.number(), zod.null()]).optional()
									})
									.describe('State holder with a single relationship to the base State.'),
								objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
								variable_values_all: zod.array(
									zod.record(
										zod.string(),
										zod.union([
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.union([
												zod.array(zod.unknown()),
												zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
												zod.number(),
												zod.number(),
												zod.boolean(),
												zod.literal('List'),
												zod.null()
											])
										])
									)
								),
								objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
								variable_values: zod.union([
									zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.null()
								]),
								state_id: zod.number(),
								num_solutions: zod.number()
							})
							.describe(
								'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
							)
					),
					personal_result_index: zod.union([zod.number(), zod.null()]),
					final_result: zod.union([
						zod
							.object({
								name: zod
									.union([zod.string(), zod.null()])
									.optional()
									.describe('Optional name to help identify the solution if, e.g., saved.'),
								solution_index: zod
									.union([zod.number(), zod.null()])
									.optional()
									.describe(
										'The index of the referenced solution, if multiple solutions exist in the reference state.'
									),
								state: zod
									.object({
										id: zod.union([zod.number(), zod.null()]).optional(),
										problem_id: zod.union([zod.number(), zod.null()]).optional(),
										session_id: zod.union([zod.number(), zod.null()]).optional(),
										parent_id: zod.union([zod.number(), zod.null()]).optional(),
										state_id: zod.union([zod.number(), zod.null()]).optional()
									})
									.describe('State holder with a single relationship to the base State.'),
								objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
								variable_values_all: zod.array(
									zod.record(
										zod.string(),
										zod.union([
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.union([
												zod.array(zod.unknown()),
												zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
												zod.number(),
												zod.number(),
												zod.boolean(),
												zod.literal('List'),
												zod.null()
											])
										])
									)
								),
								objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
								variable_values: zod.union([
									zod.record(zod.string(), zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.null()
								]),
								state_id: zod.number(),
								num_solutions: zod.number()
							})
							.describe(
								'A model that functions as a reference to solutions existing in the database.\n\nReferenced solutions are not necessarily solutions that the user has saved explicitly. For\nreferencing those, see `SavedSolutionReference`.'
							),
						zod.null()
					])
				})
				.describe(
					'A full iteration item containing results from a complete or incomplete iteration.'
				)
		)
	})
	.describe('The response model for getting all found solutions among others.');

/**
 * Switch the phase from one to another. "learning", "crp", "decision" and "compromise" phases are allowed.
 * @summary Switch Phase
 */
export const switchPhaseGnimbusTogglePhasePostBody = zod
	.object({
		group_id: zod.number(),
		new_phase: zod.string()
	})
	.describe('A request for a certain phase. Comes from the group owner/analyst.');

export const switchPhaseGnimbusTogglePhasePostResponse = zod
	.object({
		old_phase: zod.string(),
		new_phase: zod.string()
	})
	.describe('A response for the above request.');

/**
 * Get the current phase of the group.
 * @summary Get Phase
 */
export const getPhaseGnimbusGetPhasePostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const getPhaseGnimbusGetPhasePostResponse = zod.unknown();

/**
 * Steps the E-NAUTILUS method.
 * @summary Step
 */
export const stepMethodEnautilusStepPostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		representative_solutions_id: zod.union([zod.number(), zod.null()]).optional(),
		current_iteration: zod.number().describe('The number of the current iteration.'),
		iterations_left: zod.number().describe('The number of iterations left.'),
		selected_point: zod
			.union([zod.record(zod.string(), zod.number()), zod.null()])
			.describe(
				'The selected intermediate point. If first iteration, set this to be the (approximated) nadir point. If not set, then the point is assumed to be the nadir point of the current approximating set.'
			),
		reachable_point_indices: zod
			.array(zod.number())
			.describe(
				'The indices indicating the point on the non-dominated set that are reachable from the currently selected point.'
			),
		number_of_intermediate_points: zod
			.number()
			.describe('The number of intermediate points to be generated.')
	})
	.describe('Model of the request to the E-NAUTILUS method.');

export const stepMethodEnautilusStepPostResponse = zod
	.object({
		state_id: zod
			.union([zod.number(), zod.null()])
			.describe('The id of the state created by the request that generated this response'),
		representative_solutions_id: zod
			.number()
			.describe("The id of the 'RepresentativeNonDominatedSolutions' used."),
		current_iteration: zod.number().describe('Number of the current iteration.'),
		iterations_left: zod.number().describe('Number of iterations left.'),
		intermediate_points: zod
			.array(zod.record(zod.string(), zod.number()))
			.describe('New intermediate points'),
		reachable_best_bounds: zod
			.array(zod.record(zod.string(), zod.number()))
			.describe(
				'Best bounds of the objective function values reachable from each intermediate point.'
			),
		reachable_worst_bounds: zod
			.array(zod.record(zod.string(), zod.number()))
			.describe(
				'Worst bounds of the objective function values reachable from each intermediate point.'
			),
		closeness_measures: zod
			.array(zod.number())
			.describe('Closeness measures of each intermediate point.'),
		reachable_point_indices: zod
			.array(zod.array(zod.number()))
			.describe('Indices of the reachable points from each intermediate point.')
	})
	.describe('The response from E-NAUTILUS step endpoint.');
