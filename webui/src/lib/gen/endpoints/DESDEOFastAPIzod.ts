/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * DESDEO (fast)API
 * A rest API for the DESDEO framework.
 * OpenAPI spec version: 0.1.0
 */
import * as zod from 'zod';

/**
 * Return information about the current user.

Args:
    user (Annotated[User, Depends): user dependency, handled by `get_current_user`.

Returns:
    UserPublic: public information about the current user.
 * @summary Get Current User Info
 */
export const GetCurrentUserInfoUserInfoGetResponse = zod
	.object({
		username: zod.string(),
		id: zod.number(),
		role: zod.enum(['guest', 'dm', 'analyst', 'admin']).describe('Possible user roles.'),
		group_ids: zod.union([zod.array(zod.number()), zod.null()])
	})
	.describe('The object to handle public user information.');

/**
 * Login to get an authentication token.

Return an access token in the response and a cookie storing a refresh token.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
        The form data to authenticate the user.
    session (Annotated[Session, Depends(get_db)]): The database session.
    cookie_max_age (int): the lifetime of the cookie storing the refresh token.
 * @summary Login
 */
export const loginLoginPostQueryCookieMaxAgeDefault = 30;

export const LoginLoginPostQueryParams = zod.object({
	cookie_max_age: zod.number().default(loginLoginPostQueryCookieMaxAgeDefault)
});

export const LoginLoginPostResponse = zod
	.object({
		access_token: zod.string(),
		refresh_token: zod.string(),
		token_type: zod.string()
	})
	.describe('A model for the authentication token.');

/**
 * Log the current user out. Deletes the refresh token that was set by logging in.

Args:
    None

Returns:
    JSONResponse: A response in which the cookies are deleted
 * @summary Logout
 */
export const LogoutLogoutPostResponse = zod.unknown();

/**
 * Refresh the access token using the refresh token stored in the cookie.

Args:
    request (Request): The request containing the cookie.
    session (Annotated[Session, Depends(get_db)]): the database session.
    refresh_token (Annotated[Str | None, Cookie()]): the refresh
        token, which is fetched from a cookie included in the response.

Returns:
    dict: A dictionary containing the new access token.
 * @summary Refresh Access Token
 */
export const RefreshAccessTokenRefreshPostResponse = zod.unknown();

/**
 * Add a new user of the role Decision Maker to the database. Requires no login.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if username is already in use or if saving to the database fails for some reason.
 * @summary Add New Dm
 */
export const AddNewDmAddNewDmPostResponse = zod.unknown();

/**
 * Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin.

Args:
    user: Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
    form_data: (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session: (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if the logged in user is not an analyst or an admin or if
    username is already in use or if saving to the database fails for some reason.
 * @summary Add New Analyst
 */
export const AddNewAnalystAddNewAnalystPostResponse = zod.unknown();

/**
 * Get information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfoSmall]: a list of information on all the problems.
 * @summary Get Problems
 */
export const getProblemsProblemAllGetResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault = `forest_problem_metadata`;
export const getProblemsProblemAllGetResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault = `representative_non_dominated_solutions`;

export const GetProblemsProblemAllGetResponseItem = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsProblemAllGetResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsProblemAllGetResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data, but smaller.');
export const GetProblemsProblemAllGetResponse = zod.array(GetProblemsProblemAllGetResponseItem);

/**
 * Get detailed information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfo]: a list of the detailed information on all the problems.
 * @summary Get Problems Info
 */
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemMaximizeDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsOneItemIsLinearDefault = true;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsOneItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseConstraintsOneItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsOneItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsOneItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsOneItemIsLinearDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsOneItemIsConvexDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseExtraFuncsOneItemIsTwiceDifferentiableDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseDiscreteRepresentationOneNonDominatedDefault = false;
export const getProblemsInfoProblemAllInfoGetResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault = `forest_problem_metadata`;
export const getProblemsInfoProblemAllInfoGetResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault = `representative_non_dominated_solutions`;

export const GetProblemsInfoProblemAllInfoGetResponseItem = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.default(getProblemsInfoProblemAllInfoGetResponseObjectivesItemMaximizeDefault)
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.default(getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsLinearDefault)
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.default(getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsConvexDefault)
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.default(
							getProblemsInfoProblemAllInfoGetResponseObjectivesItemIsTwiceDifferentiableDefault
						)
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(getProblemsInfoProblemAllInfoGetResponseConstraintsOneItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.default(getProblemsInfoProblemAllInfoGetResponseConstraintsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								getProblemsInfoProblemAllInfoGetResponseConstraintsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.default(
								getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsOneItemIsLinearDefault
							)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(
								getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsOneItemIsConvexDefault
							)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								getProblemsInfoProblemAllInfoGetResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.default(getProblemsInfoProblemAllInfoGetResponseExtraFuncsOneItemIsLinearDefault)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(getProblemsInfoProblemAllInfoGetResponseExtraFuncsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								getProblemsInfoProblemAllInfoGetResponseExtraFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod
						.boolean()
						.default(
							getProblemsInfoProblemAllInfoGetResponseDiscreteRepresentationOneNonDominatedDefault
						),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsInfoProblemAllInfoGetResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemsInfoProblemAllInfoGetResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');
export const GetProblemsInfoProblemAllInfoGetResponse = zod.array(
	GetProblemsInfoProblemAllInfoGetResponseItem
);

/**
 * Get the model of a specific problem.

Args:
    request (ProblemGetRequest): the request containing the problem's id `problem_id`.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find a problem with the given id.

Returns:
    ProblemInfo: detailed information on the requested problem.
 * @summary Get Problem
 */
export const GetProblemProblemGetPostBody = zod
	.object({
		problem_id: zod.number()
	})
	.describe('Model to deal with problem fetching requests.');

export const getProblemProblemGetPostResponseObjectivesItemMaximizeDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseConstraintsOneItemIsLinearDefault = true;
export const getProblemProblemGetPostResponseConstraintsOneItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseConstraintsOneItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsOneItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsOneItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsOneItemIsLinearDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsOneItemIsConvexDefault = false;
export const getProblemProblemGetPostResponseExtraFuncsOneItemIsTwiceDifferentiableDefault = false;
export const getProblemProblemGetPostResponseDiscreteRepresentationOneNonDominatedDefault = false;
export const getProblemProblemGetPostResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault = `forest_problem_metadata`;
export const getProblemProblemGetPostResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault = `representative_non_dominated_solutions`;

export const GetProblemProblemGetPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.default(getProblemProblemGetPostResponseObjectivesItemMaximizeDefault)
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.default(getProblemProblemGetPostResponseObjectivesItemIsLinearDefault)
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.default(getProblemProblemGetPostResponseObjectivesItemIsConvexDefault)
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.default(getProblemProblemGetPostResponseObjectivesItemIsTwiceDifferentiableDefault)
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(getProblemProblemGetPostResponseConstraintsOneItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.default(getProblemProblemGetPostResponseConstraintsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								getProblemProblemGetPostResponseConstraintsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.default(getProblemProblemGetPostResponseScalarizationFuncsOneItemIsLinearDefault)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(getProblemProblemGetPostResponseScalarizationFuncsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								getProblemProblemGetPostResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.default(getProblemProblemGetPostResponseExtraFuncsOneItemIsLinearDefault)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(getProblemProblemGetPostResponseExtraFuncsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								getProblemProblemGetPostResponseExtraFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod
						.boolean()
						.default(getProblemProblemGetPostResponseDiscreteRepresentationOneNonDominatedDefault),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemProblemGetPostResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											getProblemProblemGetPostResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Add a newly defined problem to the database.

Args:
    request (Problem): the JSON representation of the problem.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Note:
    Users with the role 'guest' may not add new problems.

Raises:
    HTTPException: when any issue with defining the problem arises.

Returns:
    ProblemInfo: the information about the problem added.
 * @summary Add Problem
 */
export const addProblemProblemAddPostResponseObjectivesItemMaximizeDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseConstraintsOneItemIsLinearDefault = true;
export const addProblemProblemAddPostResponseConstraintsOneItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseConstraintsOneItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsOneItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsOneItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsOneItemIsLinearDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsOneItemIsConvexDefault = false;
export const addProblemProblemAddPostResponseExtraFuncsOneItemIsTwiceDifferentiableDefault = false;
export const addProblemProblemAddPostResponseDiscreteRepresentationOneNonDominatedDefault = false;
export const addProblemProblemAddPostResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault = `forest_problem_metadata`;
export const addProblemProblemAddPostResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault = `representative_non_dominated_solutions`;

export const AddProblemProblemAddPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.default(addProblemProblemAddPostResponseObjectivesItemMaximizeDefault)
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.default(addProblemProblemAddPostResponseObjectivesItemIsLinearDefault)
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.default(addProblemProblemAddPostResponseObjectivesItemIsConvexDefault)
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.default(addProblemProblemAddPostResponseObjectivesItemIsTwiceDifferentiableDefault)
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(addProblemProblemAddPostResponseConstraintsOneItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.default(addProblemProblemAddPostResponseConstraintsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								addProblemProblemAddPostResponseConstraintsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.default(addProblemProblemAddPostResponseScalarizationFuncsOneItemIsLinearDefault)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(addProblemProblemAddPostResponseScalarizationFuncsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								addProblemProblemAddPostResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.default(addProblemProblemAddPostResponseExtraFuncsOneItemIsLinearDefault)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(addProblemProblemAddPostResponseExtraFuncsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								addProblemProblemAddPostResponseExtraFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod
						.boolean()
						.default(addProblemProblemAddPostResponseDiscreteRepresentationOneNonDominatedDefault),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemProblemAddPostResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemProblemAddPostResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Adds a problem to the database based on its JSON definition.

Args:
    json_file (UploadFile): a file in JSON format describing the problem.
    user (Annotated[User, Depends): the usr for which the problem is added.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: if the provided `json_file` is empty.
    HTTPException: if the content in the provided `json_file` is not in JSON format.__annotations__

Returns:
    ProblemInfo: a description of the added problem.
 * @summary Add Problem Json
 */
export const AddProblemJsonProblemAddJsonPostBody = zod.object({
	json_file: zod.instanceof(File)
});

export const addProblemJsonProblemAddJsonPostResponseObjectivesItemMaximizeDefault = false;
export const addProblemJsonProblemAddJsonPostResponseObjectivesItemIsLinearDefault = false;
export const addProblemJsonProblemAddJsonPostResponseObjectivesItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseObjectivesItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseConstraintsOneItemIsLinearDefault = true;
export const addProblemJsonProblemAddJsonPostResponseConstraintsOneItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseConstraintsOneItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseScalarizationFuncsOneItemIsLinearDefault = false;
export const addProblemJsonProblemAddJsonPostResponseScalarizationFuncsOneItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseExtraFuncsOneItemIsLinearDefault = false;
export const addProblemJsonProblemAddJsonPostResponseExtraFuncsOneItemIsConvexDefault = false;
export const addProblemJsonProblemAddJsonPostResponseExtraFuncsOneItemIsTwiceDifferentiableDefault = false;
export const addProblemJsonProblemAddJsonPostResponseDiscreteRepresentationOneNonDominatedDefault = false;
export const addProblemJsonProblemAddJsonPostResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault = `forest_problem_metadata`;
export const addProblemJsonProblemAddJsonPostResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault = `representative_non_dominated_solutions`;

export const AddProblemJsonProblemAddJsonPostResponse = zod
	.object({
		name: zod.string(),
		description: zod.string(),
		is_convex: zod.union([zod.boolean(), zod.null()]),
		is_linear: zod.union([zod.boolean(), zod.null()]),
		is_twice_differentiable: zod.union([zod.boolean(), zod.null()]),
		scenario_keys: zod.union([zod.array(zod.string()), zod.null()]),
		variable_domain: zod
			.enum(['continuous', 'binary', 'integer', 'mixed'])
			.describe('An enumerator for the possible variable type domains of a problem.'),
		id: zod.number(),
		user_id: zod.number(),
		constants: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the constant. This can be used in UI and visualizations. Example: 'maximum cost'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'c_1'."
							),
						value: zod.number().describe('The value of the constant.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constant`.')
			),
			zod.null()
		]),
		tensor_constants: zod.union([
			zod.array(
				zod
					.object({
						values: zod.union([
							zod.array(zod.unknown()),
							zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.literal('List'),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the tensor representing the values. E.g., 'distances'"
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constant. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorConstant`.')
			),
			zod.null()
		]),
		variables: zod.union([
			zod.array(
				zod
					.object({
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'v_1'."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						lowerbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Lower bound of the variable.'),
						upperbound: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Upper bound of the variable.'),
						initial_value: zod
							.union([zod.number(), zod.null()])
							.optional()
							.describe('Initial value of the variable. This is optional.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Variable`.')
			),
			zod.null()
		]),
		tensor_variables: zod.union([
			zod.array(
				zod
					.object({
						initial_values: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						lowerbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						upperbounds: zod.union([
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							]),
							zod.null()
						]),
						shape: zod.array(zod.number()),
						name: zod
							.string()
							.describe(
								"Descriptive name of the variable. This can be used in UI and visualizations. Example: 'velocity'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the variable. This will be used in the rest of the problem definition. Notice that the elements of the tensor will be represented with the symbol followed by indices. E.g., the first element of the third element of a 2-dimensional tensor, is represented by 'x_1_3', where 'x' is the symbol given to the TensorVariable. Note that indexing starts from 1."
							),
						variable_type: zod
							.enum(['real', 'integer', 'binary'])
							.describe('An enumerator for possible variable types.'),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `TensorVariable`.')
			),
			zod.null()
		]),
		objectives: zod.array(
			zod
				.object({
					func: zod.union([zod.array(zod.unknown()), zod.null()]),
					scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
					simulator_path: zod
						.union([
							zod.string(),
							zod
								.object({
									url: zod
										.string()
										.describe(
											'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
										),
									auth: zod
										.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
										.optional()
										.describe(
											'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
										)
								})
								.describe('Model for a URL.'),
							zod.null()
						])
						.optional(),
					description: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							'A longer description of the objective function. This can be used in UI and visualizations.             Meant to have longer text than what name should have.'
						),
					name: zod
						.string()
						.describe(
							"Descriptive name of the objective function. This can be used in UI and visualizations. Example: 'time'."
						),
					symbol: zod
						.string()
						.describe(
							"Symbol to represent the objective function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'f_1'."
						),
					unit: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe(
							"The unit of the objective function. This is optional. Used in UIs and visualizations. Example: 'seconds' or 'millions of hectares'."
						),
					maximize: zod
						.boolean()
						.default(addProblemJsonProblemAddJsonPostResponseObjectivesItemMaximizeDefault)
						.describe('Whether the objective function is to be maximized or minimized.'),
					ideal: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Ideal value of the objective. This is optional.'),
					nadir: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe('Nadir value of the objective. This is optional.'),
					objective_type: zod
						.enum(['analytical', 'data_based', 'simulator', 'surrogate'])
						.optional()
						.describe('An enumerator for supported objective function types.'),
					is_linear: zod
						.boolean()
						.default(addProblemJsonProblemAddJsonPostResponseObjectivesItemIsLinearDefault)
						.describe('Whether the function expression is linear or not. Defaults to `False`.'),
					is_convex: zod
						.boolean()
						.default(addProblemJsonProblemAddJsonPostResponseObjectivesItemIsConvexDefault)
						.describe(
							'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
						),
					is_twice_differentiable: zod
						.boolean()
						.default(
							addProblemJsonProblemAddJsonPostResponseObjectivesItemIsTwiceDifferentiableDefault
						)
						.describe(
							'Whether the function expression is twice differentiable or not. Defaults to `False`'
						),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `Objective`.')
		),
		constraints: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe(
								"Descriptive name of the constraint. This can be used in UI and visualizations. Example: 'maximum length'."
							),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the constraint. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'g_1'."
							),
						cons_type: zod
							.enum(['=', '<='])
							.describe('An enumerator for supported constraint expression types.'),
						is_linear: zod
							.boolean()
							.default(addProblemJsonProblemAddJsonPostResponseConstraintsOneItemIsLinearDefault)
							.describe(
								'Whether the constraint is linear or not. Defaults to True, e.g., a linear constraint is assumed.'
							),
						is_convex: zod
							.boolean()
							.default(addProblemJsonProblemAddJsonPostResponseConstraintsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								addProblemJsonProblemAddJsonPostResponseConstraintsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Constraint`.')
			),
			zod.null()
		]),
		scalarization_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.array(zod.string()),
						name: zod.string().describe('Name of the scalarization function.'),
						symbol: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe(
								'Optional symbol to represent the scalarization function. This may be used in UIs and visualizations.'
							),
						is_linear: zod
							.boolean()
							.default(
								addProblemJsonProblemAddJsonPostResponseScalarizationFuncsOneItemIsLinearDefault
							)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(
								addProblemJsonProblemAddJsonPostResponseScalarizationFuncsOneItemIsConvexDefault
							)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								addProblemJsonProblemAddJsonPostResponseScalarizationFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ScalarizationFunction`.')
			),
			zod.null()
		]),
		extra_funcs: zod.union([
			zod.array(
				zod
					.object({
						func: zod.array(zod.unknown()),
						scenario_keys: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						surrogates: zod.union([zod.array(zod.string()), zod.null()]).optional(),
						simulator_path: zod
							.union([
								zod.string(),
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						name: zod
							.string()
							.describe("Descriptive name of the function. Example: 'normalization'."),
						symbol: zod
							.string()
							.describe(
								"Symbol to represent the function. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations. Example: 'avg'."
							),
						is_linear: zod
							.boolean()
							.default(addProblemJsonProblemAddJsonPostResponseExtraFuncsOneItemIsLinearDefault)
							.describe('Whether the function expression is linear or not. Defaults to `False`.'),
						is_convex: zod
							.boolean()
							.default(addProblemJsonProblemAddJsonPostResponseExtraFuncsOneItemIsConvexDefault)
							.describe(
								'Whether the function expression is convex or not (non-convex). Defaults to `False`.'
							),
						is_twice_differentiable: zod
							.boolean()
							.default(
								addProblemJsonProblemAddJsonPostResponseExtraFuncsOneItemIsTwiceDifferentiableDefault
							)
							.describe(
								'Whether the function expression is twice differentiable or not. Defaults to `False`'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `ExtraFunction`.')
			),
			zod.null()
		]),
		discrete_representation: zod.union([
			zod
				.object({
					non_dominated: zod
						.boolean()
						.default(
							addProblemJsonProblemAddJsonPostResponseDiscreteRepresentationOneNonDominatedDefault
						),
					variable_values: zod.record(
						zod.string(),
						zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
					),
					objective_values: zod.record(zod.string(), zod.array(zod.number())),
					id: zod.union([zod.number(), zod.null()]).optional(),
					problem_id: zod.union([zod.number(), zod.null()]).optional()
				})
				.describe('The SQLModel equivalent to `DiscreteRepresentation`.'),
			zod.null()
		]),
		simulators: zod.union([
			zod.array(
				zod
					.object({
						file: zod.union([zod.string(), zod.null()]).optional(),
						url: zod
							.union([
								zod
									.object({
										url: zod
											.string()
											.describe(
												'A URL to the simulator. A GET request to this URL should be used to evaluate solutions in batches.'
											),
										auth: zod
											.union([zod.tuple([zod.string(), zod.string()]), zod.null()])
											.optional()
											.describe(
												'Optional. A tuple of username and password to be used for authentication when making requests to the URL.'
											)
									})
									.describe('Model for a URL.'),
								zod.null()
							])
							.optional(),
						parameter_options: zod
							.union([zod.record(zod.string(), zod.unknown()), zod.null()])
							.optional(),
						name: zod
							.string()
							.describe(
								'Descriptive name of the simulator. This can be used in UI and visualizations.'
							),
						symbol: zod
							.string()
							.describe(
								'Symbol to represent the simulator. This will be used in the rest of the problem definition. It may also be used in UIs and visualizations.'
							),
						id: zod.union([zod.number(), zod.null()]).optional(),
						problem_id: zod.union([zod.number(), zod.null()]).optional()
					})
					.describe('The SQLModel equivalent to `Simulator`.')
			),
			zod.null()
		]),
		problem_metadata: zod.union([
			zod
				.object({
					problem_id: zod.number(),
					forest_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemJsonProblemAddJsonPostResponseProblemMetadataOneForestMetadataOneItemMetadataTypeDefault
										),
									map_json: zod.string(),
									schedule_dict: zod.record(zod.string(), zod.unknown()),
									years: zod.array(zod.string()),
									stand_id_field: zod.string(),
									stand_descriptor: zod
										.union([zod.record(zod.string(), zod.unknown()), zod.null()])
										.optional(),
									compensation: zod.union([zod.number(), zod.null()]).optional()
								})
								.describe(
									'A problem metadata class to hold UTOPIA forest problem specific information.'
								)
						),
						zod.null()
					]),
					representative_nd_metadata: zod.union([
						zod.array(
							zod
								.object({
									id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_id: zod.union([zod.number(), zod.null()]).optional(),
									metadata_type: zod
										.string()
										.default(
											addProblemJsonProblemAddJsonPostResponseProblemMetadataOneRepresentativeNdMetadataOneItemMetadataTypeDefault
										),
									name: zod.string().describe('The name of the representative set.'),
									description: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('A description of the representative set. Optional.'),
									solution_data: zod
										.record(zod.string(), zod.array(zod.number()))
										.describe(
											'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
										),
									ideal: zod
										.record(zod.string(), zod.number())
										.describe('The ideal objective function values of the representative set.'),
									nadir: zod
										.record(zod.string(), zod.number())
										.describe('The nadir objective function values of the representative set.')
								})
								.describe(
									'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
								)
						),
						zod.null()
					])
				})
				.describe('Response model for ProblemMetaData.'),
			zod.null()
		])
	})
	.describe('Problem info request return data.');

/**
 * Fetch specific metadata for a specific problem.

Fetch specific metadata for a specific problem. See all the possible
metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata
section.

Args:
    request (MetaDataGetRequest): the requested metadata type.
    user (Annotated[User, Depends]): the current user.
    session (Annotated[Session, Depends]): the database session.

Returns:
    list[ForestProblemMetadata | RepresentativeNonDominatedSolutions]: list containing all the metadata
        defined for the problem with the requested metadata type. If no match is found,
        returns an empty list.
 * @summary Get Metadata
 */
export const GetMetadataProblemGetMetadataPostBody = zod
	.object({
		problem_id: zod.number(),
		metadata_type: zod.string()
	})
	.describe('Request model for getting specific type of metadata from a specific problem.');

export const getMetadataProblemGetMetadataPostResponseOneMetadataTypeDefault = `forest_problem_metadata`;
export const getMetadataProblemGetMetadataPostResponseTwoMetadataTypeDefault = `representative_non_dominated_solutions`;
export const getMetadataProblemGetMetadataPostResponseThreeMetadataTypeDefault = `solver_selection_metadata`;

export const GetMetadataProblemGetMetadataPostResponseItem = zod.union([
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseOneMetadataTypeDefault),
			map_json: zod.string(),
			schedule_dict: zod.record(zod.string(), zod.unknown()),
			years: zod.array(zod.string()),
			stand_id_field: zod.string(),
			stand_descriptor: zod.union([zod.record(zod.string(), zod.unknown()), zod.null()]).optional(),
			compensation: zod.union([zod.number(), zod.null()]).optional()
		})
		.describe('A problem metadata class to hold UTOPIA forest problem specific information.'),
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseTwoMetadataTypeDefault),
			name: zod.string().describe('The name of the representative set.'),
			description: zod
				.union([zod.string(), zod.null()])
				.optional()
				.describe('A description of the representative set. Optional.'),
			solution_data: zod
				.record(zod.string(), zod.array(zod.number()))
				.describe(
					'The non-dominated solutions. It is assumed that columns exist for each variable and objective function. For functions, the `_min` variant should be present, and any tensor variables should be unrolled.'
				),
			ideal: zod
				.record(zod.string(), zod.number())
				.describe('The ideal objective function values of the representative set.'),
			nadir: zod
				.record(zod.string(), zod.number())
				.describe('The nadir objective function values of the representative set.')
		})
		.describe(
			'A problem metadata class to store representative solutions sets, i.e., non-dominated sets...\n\nA problem metadata class to store representative solutions sets, i.e., non-dominated sets that\nrepresent/approximate the Pareto optimal solution set of the problem.\n\nNote:\n    It is assumed that the solution set is non-dominated.'
		),
	zod
		.object({
			id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_id: zod.union([zod.number(), zod.null()]).optional(),
			metadata_type: zod
				.string()
				.default(getMetadataProblemGetMetadataPostResponseThreeMetadataTypeDefault),
			solver_string_representation: zod
				.string()
				.describe('The string representation of the selected solver.')
		})
		.describe(
			'A problem metadata class to store the preferred solver of a problem.\n\nA problem metadata class to store the preferred solver of a problem.\nSee desdeo/tools/utils.py -> available_solvers for available solvers.'
		)
]);
export const GetMetadataProblemGetMetadataPostResponse = zod.array(
	GetMetadataProblemGetMetadataPostResponseItem
);

/**
 * Return the list of available solver names.
 * @summary Get Available Solvers
 */
export const GetAvailableSolversProblemAssignSolverGetResponseItem = zod.string();
export const GetAvailableSolversProblemAssignSolverGetResponse = zod.array(
	GetAvailableSolversProblemAssignSolverGetResponseItem
);

/**
 * Assign a specific solver for a problem.

request: ProblemSelectSolverRequest: The request containing problem id and string representation of the solver
user: Annotated[User, Depends(get_current_user): The user that is logged in.
session: Annotated[Session, Depends(get_session)]: The database session.

Raises:
    HTTPException: Unknown solver, unauthorized user

Returns:
    JSONResponse: A simple confirmation.
 * @summary Select Solver
 */
export const SelectSolverProblemAssignSolverPostBody = zod
	.object({
		problem_id: zod.number().describe('ID of the problem that the solver is assigned to.'),
		solver_string_representation: zod
			.string()
			.describe(
				"One of the following: ['scipy_minimize', 'scipy_de', 'proximal', 'nevergrad', 'pyomo_bonmin', 'pyomo_cbc', 'pyomo_ipopt', 'pyomo_gurobi', 'gurobipy', 'gurobipy_persistent']"
			)
	})
	.describe('Model to request a specific solver for a problem.');

export const SelectSolverProblemAssignSolverPostResponse = zod.unknown();

/**
 * .
 * @summary Create New Session
 */
export const CreateNewSessionSessionNewPostBody = zod
	.object({
		info: zod.union([zod.string(), zod.null()]).optional()
	})
	.describe('Model of the request to create a new session.');

export const CreateNewSessionSessionNewPostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]),
		user_id: zod.union([zod.number(), zod.null()]),
		info: zod.union([zod.string(), zod.null()])
	})
	.describe('The base model for representing interactive sessions.');

/**
 * Return an interactive session with a current user.
 * @summary Get Session
 */
export const GetSessionSessionGetSessionIdGetParams = zod.object({
	session_id: zod.number()
});

export const GetSessionSessionGetSessionIdGetResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]),
		user_id: zod.union([zod.number(), zod.null()]),
		info: zod.union([zod.string(), zod.null()])
	})
	.describe('The base model for representing interactive sessions.');

/**
 * Return all interactive sessions of the current user.
 * @summary Get All Sessions
 */
export const GetAllSessionsSessionGetAllGetResponseItem = zod
	.object({
		id: zod.union([zod.number(), zod.null()]),
		user_id: zod.union([zod.number(), zod.null()]),
		info: zod.union([zod.string(), zod.null()])
	})
	.describe('The base model for representing interactive sessions.');
export const GetAllSessionsSessionGetAllGetResponse = zod.array(
	GetAllSessionsSessionGetAllGetResponseItem
);

/**
 * Delete an interactive session and all its related states.
 * @summary Delete Session
 */
export const DeleteSessionSessionSessionIdDeleteParams = zod.object({
	session_id: zod.number()
});

/**
 * Runs an iteration of the reference point method.

Args:
    request (RPMSolveRequest): a request with the needed information to run the method.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the current database session.

Returns:
    RPMState: a state with information on the results of iterating the reference point method
        once.
 * @summary Solve Solutions
 */
export const solveSolutionsMethodRpmSolvePostBodyPreferencePreferenceTypeDefault = `reference_point`;

export const SolveSolutionsMethodRpmSolvePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodRpmSolvePostBodyPreferencePreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.optional()
			.describe('Model for representing a reference point type of preference.')
	})
	.describe('Model of the request to the reference point method.');

export const solveSolutionsMethodRpmSolvePostResponsePreferencesPreferenceTypeDefault = `reference_point`;

export const SolveSolutionsMethodRpmSolvePostResponse = zod
	.object({
		id: zod.union([zod.number(), zod.null()]).optional(),
		preferences: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodRpmSolvePostResponsePreferencesPreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.describe('Model for representing a reference point type of preference.'),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver_results: zod.array(
			zod
				.object({
					optimal_variables: zod
						.record(zod.string(), zod.union([zod.number(), zod.number(), zod.array(zod.unknown())]))
						.describe('The optimal decision variables found.'),
					optimal_objectives: zod
						.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())]))
						.describe(
							'The objective function values corresponding to the optimal decision variables found.'
						),
					constraint_values: zod
						.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.array(zod.number()),
									zod.array(zod.unknown())
								])
							),
							zod.unknown(),
							zod.null()
						])
						.optional()
						.describe(
							'The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.'
						),
					extra_func_values: zod
						.union([
							zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
							zod.null()
						])
						.optional()
						.describe('The extra function values of the problem.'),
					scalarization_values: zod
						.union([
							zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
							zod.null()
						])
						.optional()
						.describe('The scalarization function values of the problem.'),
					success: zod
						.boolean()
						.describe('A boolean flag indicating whether the optimization was successful or not.'),
					message: zod.string().describe('Description of the cause of termination.')
				})
				.describe('Defines a schema for a dataclass to store the results of a solver.')
		)
	})
	.describe('Reference Point Method (k+1 candidates).');

/**
 * Solve the problem using the NIMBUS method.
 * @summary Solve Solutions
 */
export const solveSolutionsMethodNimbusSolvePostBodyPreferencePreferenceTypeDefault = `reference_point`;
export const solveSolutionsMethodNimbusSolvePostBodyNumDesiredDefault = 1;

export const SolveSolutionsMethodNimbusSolvePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(solveSolutionsMethodNimbusSolvePostBodyPreferencePreferenceTypeDefault),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.optional()
			.describe('Model for representing a reference point type of preference.'),
		current_objectives: zod
			.record(zod.string(), zod.number())
			.describe('The objectives used for iteration.'),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveSolutionsMethodNimbusSolvePostBodyNumDesiredDefault)
	})
	.describe('Model of the request to the nimbus method.');

export const solveSolutionsMethodNimbusSolvePostResponseResponseTypeDefault = `nimbus.classification`;
export const solveSolutionsMethodNimbusSolvePostResponsePreviousPreferencePreferenceTypeDefault = `reference_point`;

export const SolveSolutionsMethodNimbusSolvePostResponse = zod
	.object({
		response_type: zod
			.literal('nimbus.classification')
			.default(solveSolutionsMethodNimbusSolvePostResponseResponseTypeDefault),
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		previous_preference: zod
			.object({
				preference_type: zod
					.literal('reference_point')
					.default(
						solveSolutionsMethodNimbusSolvePostResponsePreviousPreferencePreferenceTypeDefault
					),
				aspiration_levels: zod.record(zod.string(), zod.number())
			})
			.describe('Model for representing a reference point type of preference.'),
		previous_objectives: zod
			.record(zod.string(), zod.number())
			.describe('The previous solutions objectives used for iteration.'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current iteration of nimbus.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Initialize the problem for the NIMBUS method.
 * @summary Initialize
 */
export const initializeMethodNimbusInitializePostBodyStartingPointOnePreferenceTypeDefault = `reference_point`;

export const InitializeMethodNimbusInitializePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		starting_point: zod
			.union([
				zod
					.object({
						preference_type: zod
							.literal('reference_point')
							.default(
								initializeMethodNimbusInitializePostBodyStartingPointOnePreferenceTypeDefault
							),
						aspiration_levels: zod.record(zod.string(), zod.number())
					})
					.describe('Model for representing a reference point type of preference.'),
				zod
					.object({
						state_id: zod.number().describe('State of the desired solution.'),
						solution_index: zod.number().describe('Index of the desired solution.'),
						name: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe('Name to be given to the solution. Optional.')
					})
					.describe(
						'Used when we wish to reference a solution in some `StateDB` stored in the database.'
					),
				zod.null()
			])
			.optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional()
	})
	.describe('Model of the request to the nimbus method.');

export const initializeMethodNimbusInitializePostResponseResponseTypeDefault = `nimbus.initialization`;

export const InitializeMethodNimbusInitializePostResponse = zod
	.object({
		response_type: zod
			.literal('nimbus.initialization')
			.default(initializeMethodNimbusInitializePostResponseResponseTypeDefault),
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current interation of nimbus.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Save solutions.
 * @summary Save
 */
export const SaveMethodNimbusSavePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		solution_info: zod.array(
			zod
				.object({
					state_id: zod.number().describe('State of the desired solution.'),
					solution_index: zod.number().describe('Index of the desired solution.'),
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Name to be given to the solution. Optional.')
				})
				.describe(
					'Used when we wish to reference a solution in some `StateDB` stored in the database.'
				)
		)
	})
	.describe("Request model for saving solutions from any method's state.");

export const saveMethodNimbusSavePostResponseResponseTypeDefault = `nimbus.save`;

export const SaveMethodNimbusSavePostResponse = zod
	.object({
		response_type: zod
			.literal('nimbus.save')
			.default(saveMethodNimbusSavePostResponseResponseTypeDefault),
		state_id: zod.union([zod.number(), zod.null()]).describe('The id of the newest state')
	})
	.describe('The response from NIMBUS save endpoint.');

/**
 * Solve intermediate solutions by forwarding the request to generic intermediate endpoint with context nimbus.
 * @summary Solve Nimbus Intermediate
 */
export const solveNimbusIntermediateMethodNimbusIntermediatePostBodyNumDesiredDefault = 1;

export const SolveNimbusIntermediateMethodNimbusIntermediatePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		context: zod.union([zod.string(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveNimbusIntermediateMethodNimbusIntermediatePostBodyNumDesiredDefault),
		reference_solution_1: zod
			.object({
				state_id: zod.number().describe('State of the desired solution.'),
				solution_index: zod.number().describe('Index of the desired solution.'),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			),
		reference_solution_2: zod
			.object({
				state_id: zod.number().describe('State of the desired solution.'),
				solution_index: zod.number().describe('Index of the desired solution.'),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('Model of the request to solve intermediate solutions between two solutions.');

export const solveNimbusIntermediateMethodNimbusIntermediatePostResponseResponseTypeDefault = `nimbus.intermediate`;

export const SolveNimbusIntermediateMethodNimbusIntermediatePostResponse = zod
	.object({
		response_type: zod
			.literal('nimbus.intermediate')
			.default(solveNimbusIntermediateMethodNimbusIntermediatePostResponseResponseTypeDefault),
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		reference_solution_1: zod
			.record(zod.string(), zod.number())
			.describe('The first solution used when computing intermediate points.'),
		reference_solution_2: zod
			.record(zod.string(), zod.number())
			.describe('The second solution used when computing intermediate points.'),
		current_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The solutions from the current iteration of NIMBUS.'),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS classification endpoint.');

/**
 * Get the latest NIMBUS state if it exists, or initialize a new one if it doesn't.
 * @summary Get Or Initialize
 */
export const getOrInitializeMethodNimbusGetOrInitializePostBodyStartingPointOnePreferenceTypeDefault = `reference_point`;

export const GetOrInitializeMethodNimbusGetOrInitializePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		starting_point: zod
			.union([
				zod
					.object({
						preference_type: zod
							.literal('reference_point')
							.default(
								getOrInitializeMethodNimbusGetOrInitializePostBodyStartingPointOnePreferenceTypeDefault
							),
						aspiration_levels: zod.record(zod.string(), zod.number())
					})
					.describe('Model for representing a reference point type of preference.'),
				zod
					.object({
						state_id: zod.number().describe('State of the desired solution.'),
						solution_index: zod.number().describe('Index of the desired solution.'),
						name: zod
							.union([zod.string(), zod.null()])
							.optional()
							.describe('Name to be given to the solution. Optional.')
					})
					.describe(
						'Used when we wish to reference a solution in some `StateDB` stored in the database.'
					),
				zod.null()
			])
			.optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional()
	})
	.describe('Model of the request to the nimbus method.');

export const getOrInitializeMethodNimbusGetOrInitializePostResponseOneResponseTypeDefault = `nimbus.initialization`;
export const getOrInitializeMethodNimbusGetOrInitializePostResponseTwoResponseTypeDefault = `nimbus.classification`;
export const getOrInitializeMethodNimbusGetOrInitializePostResponseTwoPreviousPreferencePreferenceTypeDefault = `reference_point`;
export const getOrInitializeMethodNimbusGetOrInitializePostResponseThreeResponseTypeDefault = `nimbus.intermediate`;
export const getOrInitializeMethodNimbusGetOrInitializePostResponseFourResponseTypeDefault = `nimbus.finalize`;

export const GetOrInitializeMethodNimbusGetOrInitializePostResponse = zod.union([
	zod
		.object({
			response_type: zod
				.literal('nimbus.initialization')
				.default(getOrInitializeMethodNimbusGetOrInitializePostResponseOneResponseTypeDefault),
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current interation of nimbus.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.'),
	zod
		.object({
			response_type: zod
				.literal('nimbus.classification')
				.default(getOrInitializeMethodNimbusGetOrInitializePostResponseTwoResponseTypeDefault),
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			previous_preference: zod
				.object({
					preference_type: zod
						.literal('reference_point')
						.default(
							getOrInitializeMethodNimbusGetOrInitializePostResponseTwoPreviousPreferencePreferenceTypeDefault
						),
					aspiration_levels: zod.record(zod.string(), zod.number())
				})
				.describe('Model for representing a reference point type of preference.'),
			previous_objectives: zod
				.record(zod.string(), zod.number())
				.describe('The previous solutions objectives used for iteration.'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current iteration of nimbus.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.'),
	zod
		.object({
			response_type: zod
				.literal('nimbus.intermediate')
				.default(getOrInitializeMethodNimbusGetOrInitializePostResponseThreeResponseTypeDefault),
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			reference_solution_1: zod
				.record(zod.string(), zod.number())
				.describe('The first solution used when computing intermediate points.'),
			reference_solution_2: zod
				.record(zod.string(), zod.number())
				.describe('The second solution used when computing intermediate points.'),
			current_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The solutions from the current iteration of NIMBUS.'),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS classification endpoint.'),
	zod
		.object({
			response_type: zod
				.literal('nimbus.finalize')
				.default(getOrInitializeMethodNimbusGetOrInitializePostResponseFourResponseTypeDefault),
			state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
			final_solution: zod
				.object({
					name: zod.union([zod.string(), zod.null()]).optional(),
					solution_index: zod.union([zod.number(), zod.null()]),
					state_id: zod.number(),
					objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
					variable_values: zod.union([
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.unknown()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						),
						zod.null()
					])
				})
				.describe(
					'The response information provided when `SolutionReference` object are returned from the client.'
				),
			saved_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('The best candidate solutions saved by the decision maker.'),
			all_solutions: zod
				.array(
					zod
						.object({
							name: zod.union([zod.string(), zod.null()]).optional(),
							solution_index: zod.union([zod.number(), zod.null()]),
							state_id: zod.number(),
							objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
							variable_values: zod.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.union([
											zod.array(zod.unknown()),
											zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
											zod.number(),
											zod.number(),
											zod.boolean(),
											zod.literal('List'),
											zod.null()
										])
									])
								),
								zod.null()
							])
						})
						.describe(
							'The response information provided when `SolutionReference` object are returned from the client.'
						)
				)
				.describe('All solutions generated by NIMBUS in all iterations.')
		})
		.describe('The response from NIMBUS finish endpoint.')
]);

/**
 * An endpoint for finishing up the nimbus process.

Args:
    request (NIMBUSFinalizeRequest): The request containing the final solution, etc.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): The database session.

Raises:
    HTTPException

Returns:
    NIMBUSFinalizeResponse: Response containing info on the final solution.
 * @summary Finalize Nimbus
 */
export const FinalizeNimbusMethodNimbusFinalizePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		solution_info: zod
			.object({
				state_id: zod.number().describe('State of the desired solution.'),
				solution_index: zod.number().describe('Index of the desired solution.'),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('Request model for finalizing the NIMBUS procedure.');

export const finalizeNimbusMethodNimbusFinalizePostResponseResponseTypeDefault = `nimbus.finalize`;

export const FinalizeNimbusMethodNimbusFinalizePostResponse = zod
	.object({
		response_type: zod
			.literal('nimbus.finalize')
			.default(finalizeNimbusMethodNimbusFinalizePostResponseResponseTypeDefault),
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		final_solution: zod
			.object({
				name: zod.union([zod.string(), zod.null()]).optional(),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			),
		saved_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The best candidate solutions saved by the decision maker.'),
		all_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('All solutions generated by NIMBUS in all iterations.')
	})
	.describe('The response from NIMBUS finish endpoint.');

/**
 * Endpoint for deleting saved solutions.

Args:
    request (NIMBUSDeleteSaveRequest): request containing necessary information for deleting a save
    user (Annotated[User, Depends): the current  (logged in) user
    session (Annotated[Session, Depends): database session

Raises:
    HTTPException

Returns:
    NIMBUSDeleteSaveResponse: Response acknowledging the deletion of save and other useful info.
 * @summary Delete Save
 */
export const DeleteSaveMethodNimbusDeleteSavePostBody = zod
	.object({
		state_id: zod.number().describe('The ID of the save state.'),
		solution_index: zod.number().describe('The ID of the solution within the above state.')
	})
	.describe('Request model for deletion of a saved solution.');

export const deleteSaveMethodNimbusDeleteSavePostResponseResponseTypeDefault = `nimbus.delete_save`;

export const DeleteSaveMethodNimbusDeleteSavePostResponse = zod
	.object({
		response_type: zod
			.string()
			.default(deleteSaveMethodNimbusDeleteSavePostResponseResponseTypeDefault),
		message: zod.union([zod.string(), zod.null()])
	})
	.describe('Response of NIMBUS save deletion.');

/**
 * Solve intermediate solutions between given two solutions.
 * @summary Solve Intermediate
 */
export const solveIntermediateMethodGenericIntermediatePostBodyNumDesiredDefault = 1;

export const SolveIntermediateMethodGenericIntermediatePostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		context: zod.union([zod.string(), zod.null()]).optional(),
		scalarization_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		solver: zod.union([zod.string(), zod.null()]).optional(),
		solver_options: zod
			.union([
				zod.record(zod.string(), zod.union([zod.number(), zod.string(), zod.boolean()])),
				zod.null()
			])
			.optional(),
		num_desired: zod
			.union([zod.number(), zod.null()])
			.default(solveIntermediateMethodGenericIntermediatePostBodyNumDesiredDefault),
		reference_solution_1: zod
			.object({
				state_id: zod.number().describe('State of the desired solution.'),
				solution_index: zod.number().describe('Index of the desired solution.'),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			),
		reference_solution_2: zod
			.object({
				state_id: zod.number().describe('State of the desired solution.'),
				solution_index: zod.number().describe('Index of the desired solution.'),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('Model of the request to solve intermediate solutions between two solutions.');

export const SolveIntermediateMethodGenericIntermediatePostResponse = zod
	.object({
		state_id: zod.union([zod.number(), zod.null()]).describe('The newly created state id'),
		reference_solution_1: zod
			.object({
				name: zod.union([zod.string(), zod.null()]).optional(),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			),
		reference_solution_2: zod
			.object({
				name: zod.union([zod.string(), zod.null()]).optional(),
				solution_index: zod.union([zod.number(), zod.null()]),
				state_id: zod.number(),
				objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
				variable_values: zod.union([
					zod.record(
						zod.string(),
						zod.union([
							zod.number(),
							zod.number(),
							zod.boolean(),
							zod.union([
								zod.array(zod.unknown()),
								zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.literal('List'),
								zod.null()
							])
						])
					),
					zod.null()
				])
			})
			.describe(
				'The response information provided when `SolutionReference` object are returned from the client.'
			),
		intermediate_solutions: zod
			.array(
				zod
					.object({
						name: zod.union([zod.string(), zod.null()]).optional(),
						solution_index: zod.union([zod.number(), zod.null()]),
						state_id: zod.number(),
						objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
						variable_values: zod.union([
							zod.record(
								zod.string(),
								zod.union([
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.union([
										zod.array(zod.unknown()),
										zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
										zod.number(),
										zod.number(),
										zod.boolean(),
										zod.literal('List'),
										zod.null()
									])
								])
							),
							zod.null()
						])
					})
					.describe(
						'The response information provided when `SolutionReference` object are returned from the client.'
					)
			)
			.describe('The intermediate solutions computed.')
	})
	.describe('The response from computing intermediate values.');

/**
 * Calculate SCORE bands parameters from objective data.
 * @summary Calculate Score Bands From Objective Data
 */
export const calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyDistParameterDefault = 0.05;
export const calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyUseAbsoluteCorrDefault = false;
export const calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyDistanceFormulaDefault = 1;
export const calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyFlipAxesDefault = true;
export const calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyClusteringAlgorithmDefault = `DBSCAN`;
export const calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyClusteringScoreDefault = `silhoutte`;

export const CalculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBody = zod
	.object({
		data: zod.array(zod.array(zod.number())).describe('Matrix of objective values'),
		objs: zod.array(zod.string()).describe('Array of objective names for each column'),
		dist_parameter: zod
			.number()
			.default(
				calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyDistParameterDefault
			)
			.describe('Distance parameter for axis positioning'),
		use_absolute_corr: zod
			.boolean()
			.default(
				calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyUseAbsoluteCorrDefault
			)
			.describe('Use absolute correlation values'),
		distance_formula: zod
			.number()
			.default(
				calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyDistanceFormulaDefault
			)
			.describe('Distance formula (1 or 2)'),
		flip_axes: zod
			.boolean()
			.default(
				calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyFlipAxesDefault
			)
			.describe('Whether to flip axes based on correlation signs'),
		clustering_algorithm: zod
			.string()
			.default(
				calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyClusteringAlgorithmDefault
			)
			.describe('Clustering algorithm (DBSCAN or GMM)'),
		clustering_score: zod
			.string()
			.default(
				calculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostBodyClusteringScoreDefault
			)
			.describe('Clustering score metric')
	})
	.describe('Model of the request to calculate SCORE bands parameters.');

export const CalculateScoreBandsFromObjectiveDataMethodGenericScoreBandsObjDataPostResponse = zod
	.object({
		groups: zod.array(zod.number()).describe('Cluster group assignments for each data point'),
		axis_dist: zod.array(zod.number()).describe('Normalized axis positions'),
		axis_signs: zod
			.union([zod.array(zod.number()), zod.null()])
			.describe('Axis direction signs (1 or -1)'),
		obj_order: zod.array(zod.number()).describe('Optimal order of objectives')
	})
	.describe('Model of the response containing SCORE bands parameters.');

/**
 * Request and receive the Utopia map corresponding to the decision variables sent.

Args:
    request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested
    for.
    user (Annotated[User, Depend(get_current_user)]) the current user
    session (Annotated[Session, Depends(get_session)]) the current database session
Raises:
    HTTPException:
Returns:
    UtopiaResponse: the map for the forest, to be rendered in frontend
 * @summary Get Utopia Data
 */
export const GetUtopiaDataUtopiaPostBody = zod
	.object({
		problem_id: zod.number().describe('Problem for which the map is generated'),
		solution: zod
			.object({
				state_id: zod.number().describe('State of the desired solution.'),
				solution_index: zod.number().describe('Index of the desired solution.'),
				name: zod
					.union([zod.string(), zod.null()])
					.optional()
					.describe('Name to be given to the solution. Optional.')
			})
			.describe(
				'Used when we wish to reference a solution in some `StateDB` stored in the database.'
			)
	})
	.describe('The request for an Utopia map.');

export const GetUtopiaDataUtopiaPostResponse = zod
	.object({
		is_utopia: zod.boolean().describe('True if map exists for this problem.'),
		map_name: zod.string().describe('Name of the map.'),
		map_json: zod
			.record(zod.string(), zod.unknown())
			.describe('MapJSON representation of the geography.'),
		options: zod
			.record(zod.string(), zod.unknown())
			.describe('A dict with given years as keys containing options for each year.'),
		description: zod.string().describe('Description shown above the map.'),
		years: zod
			.array(zod.string())
			.describe('A list of years for which the maps have been generated.')
	})
	.describe('The response to an UtopiaRequest.');

/**
 * Create group.

Args:
    request (GroupCreateRequest): a request that holds information to be used in creation of the group.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Acknowledgement that the group was created

Raises:
    HTTPException
 * @summary Create Group
 */
export const CreateGroupGdmCreateGroupPostBody = zod
	.object({
		group_name: zod.string(),
		problem_id: zod.number()
	})
	.describe('Used for requesting a group to be created.');

export const CreateGroupGdmCreateGroupPostResponse = zod.unknown();

/**
 * Delete the group with given ID.

Args:
    request (GroupInfoRequest): Contains the ID of the group to be deleted
    user (Annotated[User, Depends(get_current_user)]): The user (in this case must be owner for anything to happen)
    session (Annotated[Session, Depends(get_session)]): The database session

Returns:
    JSONResponse: Acknowledgement of the deletion

Raises:
    HTTPException: Insufficient authorization etc.
 * @summary Delete Group
 */
export const DeleteGroupGdmDeleteGroupPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const DeleteGroupGdmDeleteGroupPostResponse = zod.unknown();

/**
 * Add a user to a group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been added to the group

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Add To Group
 */
export const AddToGroupGdmAddToGroupPostBody = zod
	.object({
		group_id: zod.number(),
		user_id: zod.number()
	})
	.describe('Used for adding a user into group and removing a user from group.');

export const AddToGroupGdmAddToGroupPostResponse = zod.unknown();

/**
 * Remove user from group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been removed from the group.

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Remove From Group
 */
export const RemoveFromGroupGdmRemoveFromGroupPostBody = zod
	.object({
		group_id: zod.number(),
		user_id: zod.number()
	})
	.describe('Used for adding a user into group and removing a user from group.');

export const RemoveFromGroupGdmRemoveFromGroupPostResponse = zod.unknown();

/**
 * Get information about the group.

Args:
    request (GroupInfoRequest): the id of the group for which we desire info on
    session (Annotated[Session, Depends(get_session)]): the database session

Returns:
    GroupPublic: public info of the group

Raises:
    HTTPException: If there's no group with the requests group id
 * @summary Get Group Info
 */
export const GetGroupInfoGdmGetGroupInfoPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const GetGroupInfoGdmGetGroupInfoPostResponse = zod
	.object({
		id: zod.number(),
		name: zod.string(),
		owner_id: zod.number(),
		user_ids: zod.array(zod.number()),
		problem_id: zod.number()
	})
	.describe('Response model for Group.');

/**
 * Initialize the problem for GNIMBUS.
 * @summary Gnimbus Initialize
 */
export const GnimbusInitializeGnimbusInitializePostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const GnimbusInitializeGnimbusInitializePostResponse = zod.unknown();

/**
 * Get the latest results from group iteration.

(OBSOLETE AND OUT OF DATE!)

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): Current user
    session (Annotated[Session, Depends(get_session)]): Database session.

Returns:
    GNIMBUSResultResponse: A GNIMBUSResultResponse response containing the latest gnimbus results

Raises:
    HTTPException: Validation errors or no results
 * @summary Get Latest Results
 */
export const GetLatestResultsGnimbusGetLatestResultsPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesOneMethodDefault = `voting`;
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesTwoMethodDefault = `optimization`;
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesTwoPhaseDefault = `learning`;
export const getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesTwoSetPreferencesPreferenceTypeDefault = `reference_point`;

export const GetLatestResultsGnimbusGetLatestResultsPostResponse = zod
	.object({
		method: zod.string(),
		phase: zod.string(),
		preferences: zod.union([
			zod
				.object({
					method: zod
						.string()
						.default(
							getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesOneMethodDefault
						),
					set_preferences: zod.record(zod.string(), zod.number())
				})
				.describe('A structure for storing voting preferences.'),
			zod
				.object({
					method: zod
						.string()
						.default(
							getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesTwoMethodDefault
						),
					phase: zod
						.string()
						.default(getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesTwoPhaseDefault),
					set_preferences: zod.record(
						zod.string(),
						zod
							.object({
								preference_type: zod
									.literal('reference_point')
									.default(
										getLatestResultsGnimbusGetLatestResultsPostResponsePreferencesTwoSetPreferencesPreferenceTypeDefault
									),
								aspiration_levels: zod.record(zod.string(), zod.number())
							})
							.describe('Model for representing a reference point type of preference.')
					)
				})
				.describe('A structure for storing optimization preferences. See GNIMBUS for details.')
		]),
		common_results: zod.array(
			zod
				.object({
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Optional name to help identify the solution if, e.g., saved.'),
					solution_index: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe(
							'The index of the referenced solution, if multiple solutions exist in the reference state.'
						),
					state: zod
						.object({
							id: zod.union([zod.number(), zod.null()]).optional(),
							problem_id: zod.union([zod.number(), zod.null()]).optional(),
							session_id: zod.union([zod.number(), zod.null()]).optional(),
							parent_id: zod.union([zod.number(), zod.null()]).optional(),
							state_id: zod.union([zod.number(), zod.null()]).optional()
						})
						.describe('State holder with a single relationship to the base State.'),
					state_id: zod.number(),
					num_solutions: zod.number(),
					objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
					variable_values_all: zod.array(
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.unknown()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						)
					),
					objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
					variable_values: zod.union([
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.unknown()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						),
						zod.null()
					])
				})
				.describe('A full solution reference with objectives and variables.')
		),
		user_results: zod.array(
			zod
				.object({
					name: zod
						.union([zod.string(), zod.null()])
						.optional()
						.describe('Optional name to help identify the solution if, e.g., saved.'),
					solution_index: zod
						.union([zod.number(), zod.null()])
						.optional()
						.describe(
							'The index of the referenced solution, if multiple solutions exist in the reference state.'
						),
					state: zod
						.object({
							id: zod.union([zod.number(), zod.null()]).optional(),
							problem_id: zod.union([zod.number(), zod.null()]).optional(),
							session_id: zod.union([zod.number(), zod.null()]).optional(),
							parent_id: zod.union([zod.number(), zod.null()]).optional(),
							state_id: zod.union([zod.number(), zod.null()]).optional()
						})
						.describe('State holder with a single relationship to the base State.'),
					state_id: zod.number(),
					num_solutions: zod.number(),
					objective_values_all: zod.array(zod.record(zod.string(), zod.number())),
					variable_values_all: zod.array(
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.unknown()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						)
					),
					objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()]),
					variable_values: zod.union([
						zod.record(
							zod.string(),
							zod.union([
								zod.number(),
								zod.number(),
								zod.boolean(),
								zod.union([
									zod.array(zod.unknown()),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()])),
									zod.number(),
									zod.number(),
									zod.boolean(),
									zod.literal('List'),
									zod.null()
								])
							])
						),
						zod.null()
					])
				})
				.describe('A full solution reference with objectives and variables.')
		),
		personal_result_index: zod.union([zod.number(), zod.null()])
	})
	.describe('The response for getting GNIMBUS results. NOTE: OBSOLETE!');

/**
 * Get all results from all iterations of the group.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): current user
    session (Annotated[Session, Depends(get_session)]): current session

Returns:
    GNIMBUSAllIterationsResponse: A GNIMBUSAllIterationsResponse response
    containing all the results of the iterations. If last iteration was optimization,
    the first iteration is incomplete (i.e. the voting preferences and voting results are missing)

Raises:
    HTTPException: Validation errors or no results or no states and such.
 * @summary Full Iteration
 */
export const FullIterationGnimbusAllIterationsPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesOneMethodDefault = `optimization`;
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesOnePhaseDefault = `learning`;
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesOneSetPreferencesPreferenceTypeDefault = `reference_point`;
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesOneMethodDefault = `voting`;
export const fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesTwoMethodDefault = `end`;

export const FullIterationGnimbusAllIterationsPostResponse = zod
	.object({
		all_full_iterations: zod.array(
			zod
				.object({
					phase: zod.string().describe('The phase of the iteration.'),
					optimization_preferences: zod
						.union([
							zod
								.object({
									method: zod
										.string()
										.default(
											fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesOneMethodDefault
										),
									phase: zod
										.string()
										.default(
											fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesOnePhaseDefault
										),
									set_preferences: zod.record(
										zod.string(),
										zod
											.object({
												preference_type: zod
													.literal('reference_point')
													.default(
														fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemOptimizationPreferencesOneSetPreferencesPreferenceTypeDefault
													),
												aspiration_levels: zod.record(zod.string(), zod.number())
											})
											.describe('Model for representing a reference point type of preference.')
									)
								})
								.describe(
									'A structure for storing optimization preferences. See GNIMBUS for details.'
								),
							zod.null()
						])
						.describe('The preferences related to the optimization stage of the full iteration.'),
					voting_preferences: zod
						.union([
							zod
								.object({
									method: zod
										.string()
										.default(
											fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesOneMethodDefault
										),
									set_preferences: zod.record(zod.string(), zod.number())
								})
								.describe('A structure for storing voting preferences.'),
							zod
								.object({
									method: zod
										.string()
										.default(
											fullIterationGnimbusAllIterationsPostResponseAllFullIterationsItemVotingPreferencesTwoMethodDefault
										),
									success: zod.union([zod.boolean(), zod.null()]),
									set_preferences: zod.record(zod.string(), zod.boolean())
								})
								.describe(
									'A structure for storing info on whether everyone is happy to end the gnimbus process.'
								),
							zod.null()
						])
						.describe(
							'The preferences related to the voting phase of the iteration.             either actual votes or a vote to see whether to just continue.'
						),
					starting_result: zod
						.union([
							zod
								.object({
									name: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('Optional name to help identify the solution if, e.g., saved.'),
									solution_index: zod
										.union([zod.number(), zod.null()])
										.optional()
										.describe(
											'The index of the referenced solution, if multiple solutions exist in the reference state.'
										),
									state: zod
										.object({
											id: zod.union([zod.number(), zod.null()]).optional(),
											problem_id: zod.union([zod.number(), zod.null()]).optional(),
											session_id: zod.union([zod.number(), zod.null()]).optional(),
											parent_id: zod.union([zod.number(), zod.null()]).optional(),
											state_id: zod.union([zod.number(), zod.null()]).optional()
										})
										.describe('State holder with a single relationship to the base State.'),
									state_id: zod.number(),
									num_solutions: zod.number(),
									objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()])
								})
								.describe(
									'The same as SolutionReference, but without decision variables for more efficient transport over the internet.'
								),
							zod.null()
						])
						.describe(
							"The starting result of the optimization process. Fetched from the previous             iteration's final result."
						),
					common_results: zod
						.array(
							zod
								.object({
									name: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('Optional name to help identify the solution if, e.g., saved.'),
									solution_index: zod
										.union([zod.number(), zod.null()])
										.optional()
										.describe(
											'The index of the referenced solution, if multiple solutions exist in the reference state.'
										),
									state: zod
										.object({
											id: zod.union([zod.number(), zod.null()]).optional(),
											problem_id: zod.union([zod.number(), zod.null()]).optional(),
											session_id: zod.union([zod.number(), zod.null()]).optional(),
											parent_id: zod.union([zod.number(), zod.null()]).optional(),
											state_id: zod.union([zod.number(), zod.null()]).optional()
										})
										.describe('State holder with a single relationship to the base State.'),
									state_id: zod.number(),
									num_solutions: zod.number(),
									objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()])
								})
								.describe(
									'The same as SolutionReference, but without decision variables for more efficient transport over the internet.'
								)
						)
						.describe('The common results (1 to 4) generated by gnimbus.'),
					user_results: zod
						.array(
							zod
								.object({
									name: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('Optional name to help identify the solution if, e.g., saved.'),
									solution_index: zod
										.union([zod.number(), zod.null()])
										.optional()
										.describe(
											'The index of the referenced solution, if multiple solutions exist in the reference state.'
										),
									state: zod
										.object({
											id: zod.union([zod.number(), zod.null()]).optional(),
											problem_id: zod.union([zod.number(), zod.null()]).optional(),
											session_id: zod.union([zod.number(), zod.null()]).optional(),
											parent_id: zod.union([zod.number(), zod.null()]).optional(),
											state_id: zod.union([zod.number(), zod.null()]).optional()
										})
										.describe('State holder with a single relationship to the base State.'),
									state_id: zod.number(),
									num_solutions: zod.number(),
									objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()])
								})
								.describe(
									'The same as SolutionReference, but without decision variables for more efficient transport over the internet.'
								)
						)
						.describe('The user specific results generated by gnimbus in phases learning and crp.'),
					personal_result_index: zod
						.union([zod.number(), zod.null()])
						.describe('The user result index of requester.'),
					final_result: zod
						.union([
							zod
								.object({
									name: zod
										.union([zod.string(), zod.null()])
										.optional()
										.describe('Optional name to help identify the solution if, e.g., saved.'),
									solution_index: zod
										.union([zod.number(), zod.null()])
										.optional()
										.describe(
											'The index of the referenced solution, if multiple solutions exist in the reference state.'
										),
									state: zod
										.object({
											id: zod.union([zod.number(), zod.null()]).optional(),
											problem_id: zod.union([zod.number(), zod.null()]).optional(),
											session_id: zod.union([zod.number(), zod.null()]).optional(),
											parent_id: zod.union([zod.number(), zod.null()]).optional(),
											state_id: zod.union([zod.number(), zod.null()]).optional()
										})
										.describe('State holder with a single relationship to the base State.'),
									state_id: zod.number(),
									num_solutions: zod.number(),
									objective_values: zod.union([zod.record(zod.string(), zod.number()), zod.null()])
								})
								.describe(
									'The same as SolutionReference, but without decision variables for more efficient transport over the internet.'
								),
							zod.null()
						])
						.describe('The final result after voting.')
				})
				.describe(
					'A full iteration item containing results from a complete or incomplete iteration.\n\nThis is a format to send information to the user interface.'
				)
		)
	})
	.describe('The response model for getting all found solutions among others.');

/**
 * Switch the phase from one to another. "learning", "crp", "decision" and "compromise" phases are allowed.
 * @summary Switch Phase
 */
export const SwitchPhaseGnimbusTogglePhasePostBody = zod
	.object({
		group_id: zod.number(),
		new_phase: zod.string()
	})
	.describe('A request for a certain phase. Comes from the group owner/analyst.');

export const SwitchPhaseGnimbusTogglePhasePostResponse = zod
	.object({
		old_phase: zod.string(),
		new_phase: zod.string()
	})
	.describe('A response for the above request.');

/**
 * Get the current phase of the group.
 * @summary Get Phase
 */
export const GetPhaseGnimbusGetPhasePostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const GetPhaseGnimbusGetPhasePostResponse = zod.unknown();

/**
 * Changes the starting solution of an iteration so in case of emergency the group owner can just change it.

Args:
    request (GNIMBUSChangeStartingSolutionRequest): The request containing necessary details to fulfill the change.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): The database session.

Raises:
    HTTPException

Returns:
    JSONResponse: Response that acknowledges the changes.
 * @summary Revert Iteration
 */
export const RevertIterationGnimbusRevertIterationPostBody = zod
	.object({
		group_id: zod.number().describe('The ID of the group we wish to revert.'),
		state_id: zod
			.number()
			.describe(
				"The state's ID to which we want to revert to. Corresponds to state_id in GroupIteration."
			)
	})
	.describe('Class for requesting reverting to certain iteration.');

export const RevertIterationGnimbusRevertIterationPostResponse = zod.unknown();

/**
 * Steps the E-NAUTILUS method.
 * @summary Step
 */
export const StepMethodEnautilusStepPostBody = zod
	.object({
		problem_id: zod.number(),
		session_id: zod.union([zod.number(), zod.null()]).optional(),
		parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
		representative_solutions_id: zod
			.number()
			.describe('The id of the representative solutions to be used.'),
		current_iteration: zod.number().describe('The number of the current iteration.'),
		iterations_left: zod.number().describe('The number of iterations left.'),
		selected_point: zod
			.union([zod.record(zod.string(), zod.number()), zod.null()])
			.describe(
				'The selected intermediate point. If first iteration, set this to be the (approximated) nadir point. If not set, then the point is assumed to be the nadir point of the current approximating set.'
			),
		reachable_point_indices: zod
			.array(zod.number())
			.describe(
				'The indices indicating the point on the non-dominated set that are reachable from the currently selected point.'
			),
		number_of_intermediate_points: zod
			.number()
			.describe('The number of intermediate points to be generated.')
	})
	.describe('Model of the request to the E-NAUTILUS method.');

export const StepMethodEnautilusStepPostResponse = zod
	.object({
		state_id: zod
			.union([zod.number(), zod.null()])
			.describe('The id of the state created by the request that generated this response'),
		current_iteration: zod.number().describe('Number of the current iteration.'),
		iterations_left: zod.number().describe('Number of iterations left.'),
		intermediate_points: zod
			.array(zod.record(zod.string(), zod.number()))
			.describe('New intermediate points'),
		reachable_best_bounds: zod
			.array(zod.record(zod.string(), zod.number()))
			.describe(
				'Best bounds of the objective function values reachable from each intermediate point.'
			),
		reachable_worst_bounds: zod
			.array(zod.record(zod.string(), zod.number()))
			.describe(
				'Worst bounds of the objective function values reachable from each intermediate point.'
			),
		closeness_measures: zod
			.array(zod.number())
			.describe('Closeness measures of each intermediate point.'),
		reachable_point_indices: zod
			.array(zod.array(zod.number()))
			.describe('Indices of the reachable points from each intermediate point.')
	})
	.describe('The response from E-NAUTILUS step endpoint.');

/**
 * Fetch a previous state of the the E-NAUTILUS method.
 * @summary Get State
 */
export const GetStateMethodEnautilusGetStatePostBody = zod
	.object({
		state_id: zod
			.number()
			.describe(
				"The id of the requested 'StateDB' object containing an instance of an 'ENautilusState."
			)
	})
	.describe('Model to request a previous state of the E-NAUTILUS method.');

export const GetStateMethodEnautilusGetStatePostResponse = zod
	.object({
		request: zod
			.object({
				problem_id: zod.number(),
				session_id: zod.union([zod.number(), zod.null()]).optional(),
				parent_state_id: zod.union([zod.number(), zod.null()]).optional(),
				representative_solutions_id: zod
					.number()
					.describe('The id of the representative solutions to be used.'),
				current_iteration: zod.number().describe('The number of the current iteration.'),
				iterations_left: zod.number().describe('The number of iterations left.'),
				selected_point: zod
					.union([zod.record(zod.string(), zod.number()), zod.null()])
					.describe(
						'The selected intermediate point. If first iteration, set this to be the (approximated) nadir point. If not set, then the point is assumed to be the nadir point of the current approximating set.'
					),
				reachable_point_indices: zod
					.array(zod.number())
					.describe(
						'The indices indicating the point on the non-dominated set that are reachable from the currently selected point.'
					),
				number_of_intermediate_points: zod
					.number()
					.describe('The number of intermediate points to be generated.')
			})
			.describe('Model of the request to the E-NAUTILUS method.'),
		response: zod
			.object({
				state_id: zod
					.union([zod.number(), zod.null()])
					.describe('The id of the state created by the request that generated this response'),
				current_iteration: zod.number().describe('Number of the current iteration.'),
				iterations_left: zod.number().describe('Number of iterations left.'),
				intermediate_points: zod
					.array(zod.record(zod.string(), zod.number()))
					.describe('New intermediate points'),
				reachable_best_bounds: zod
					.array(zod.record(zod.string(), zod.number()))
					.describe(
						'Best bounds of the objective function values reachable from each intermediate point.'
					),
				reachable_worst_bounds: zod
					.array(zod.record(zod.string(), zod.number()))
					.describe(
						'Worst bounds of the objective function values reachable from each intermediate point.'
					),
				closeness_measures: zod
					.array(zod.number())
					.describe('Closeness measures of each intermediate point.'),
				reachable_point_indices: zod
					.array(zod.array(zod.number()))
					.describe('Indices of the reachable points from each intermediate point.')
			})
			.describe('The response from E-NAUTILUS step endpoint.')
	})
	.describe('The response model when requesting a state in E-NAUTILUS.');

/**
 * Computes the representative solutions that are closest to the intermediate solutions computed by E-NAUTILUS.

This endpoint should be used to get the actual solution from the
non-dominated representation used in the E-NAUTILUS method's last iteration
(when number of iterations left is 0).

Args:
    request (ENautilusRepresentativeSolutionsRequest): a request which
        contains the id of the `StateDB` with information on the intermediate
        points for which the representative solutions should be computed.
    db_session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: 404 when a `StateDB`, `ProblemDB`, or
        `RepresentativeNonDominatedSolutions` instance cannot be found. 406 when
        the substate of the references `StateDB` is not an instance of
        `ENautilusState`.

Returns:
    ENautilusRepresentativeSolutionsResponse: the information on the representative solutions.
 * @summary Get Representative
 */
export const GetRepresentativeMethodEnautilusGetRepresentativePostBody = zod
	.object({
		state_id: zod
			.number()
			.describe(
				"The id of the requested 'StateDB' object containing an instance of an 'ENautilusState."
			)
	})
	.describe(
		"Model to request the representative solutions of intermediate points.\n\nNote that only the id of the 'StateDB' object with the relevant 'ENautilusInstance' is required."
	);

export const GetRepresentativeMethodEnautilusGetRepresentativePostResponse = zod
	.object({
		solutions: zod
			.array(
				zod
					.object({
						optimal_variables: zod
							.record(
								zod.string(),
								zod.union([zod.number(), zod.number(), zod.array(zod.unknown())])
							)
							.describe('The optimal decision variables found.'),
						optimal_objectives: zod
							.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())]))
							.describe(
								'The objective function values corresponding to the optimal decision variables found.'
							),
						constraint_values: zod
							.union([
								zod.record(
									zod.string(),
									zod.union([
										zod.number(),
										zod.number(),
										zod.array(zod.number()),
										zod.array(zod.unknown())
									])
								),
								zod.unknown(),
								zod.null()
							])
							.optional()
							.describe(
								'The constraint values of the problem. A negative value means the constraint is respected, a positive one means it has been breached.'
							),
						extra_func_values: zod
							.union([
								zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
								zod.null()
							])
							.optional()
							.describe('The extra function values of the problem.'),
						scalarization_values: zod
							.union([
								zod.record(zod.string(), zod.union([zod.number(), zod.array(zod.number())])),
								zod.null()
							])
							.optional()
							.describe('The scalarization function values of the problem.'),
						success: zod
							.boolean()
							.describe(
								'A boolean flag indicating whether the optimization was successful or not.'
							),
						message: zod.string().describe('Description of the cause of termination.')
					})
					.describe('Defines a schema for a dataclass to store the results of a solver.')
			)
			.describe('The solutions on the non-dominated front closest to the intermediate points.')
	})
	.describe('Model of the response when requesting representative solutions from E-NAUTILUS.');

/**
 * Vote for a band using this endpoint.

Args:
    request (GDMScoreBandsVoteRequest): A container for the group id and the vote.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): database session

Raises:
    HTTPException: If something goes wrong. It hopefully let's you know what went wrong.

Returns:
    JSONResponse: A quick confirmation that vote went through.
 * @summary Vote For A Band
 */
export const VoteForABandGdmScoreBandsVotePostBody = zod
	.object({
		group_id: zod.number().describe('ID of the group in question'),
		vote: zod.number().describe('The vote. Vaalisalaisuus.')
	})
	.describe('Request for voting for a band.');

export const VoteForABandGdmScoreBandsVotePostResponse = zod.unknown();

/**
 * Confim the vote. If all confirm, the clustering and new iteration begins.

Args:
    request (GroupInfoRequest): Simple request to get the group ID.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): Database session.

Raises:
    HTTPException: If something goes awry. It should let you know what went wrong, though.

Returns:
    JSONResponse: A simple confirmation that everything went ok and that vote went in.
 * @summary Confirm Vote
 */
export const ConfirmVoteGdmScoreBandsConfirmPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const ConfirmVoteGdmScoreBandsConfirmPostResponse = zod.unknown();

/**
 * An endpoint for two things: Initializing the GDM Score Bands things and Fetching results.

If a group hasn't been initialized, initialize and then return initial clustering information.
If it has been initialized, just fetch the latest iteration's information (clustering, etc.)

Args:
    request (GDMScoreBandsInitializationRequest): Request that contains necessary information for initialization.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): Database session.

Raises:
    HTTPException: It'll let you know.

Returns:
    GDMSCOREBandsResponse: A response containing Group id, group iter id and ScoreBandsResponse.
 * @summary Get Or Initialize
 */
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmOneNameDefault = `GMM`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmOneScoringMethodDefault = `silhouette`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmTwoNameDefault = `DBSCAN`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmThreeNameDefault = `KMeans`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmThreeNClustersDefault = 5;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFourNameDefault = `DimensionCluster`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFourNClustersDefault = 5;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFourKindDefault = `EqualWidth`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFiveNameDefault = `Custom`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmDefault =
	{ name: 'DBSCAN' };
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigDistanceParameterDefault = 0.05;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigUseAbsoluteCorrelationsDefault = false;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigIncludeSolutionsDefault = false;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigIncludeMediansDefault = false;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigIntervalSizeDefault = 0.95;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigMinimumVotesDefault = 1;
export const getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigMinimumVotesExclusiveMin = 0;

export const GetOrInitializeGdmScoreBandsGetOrInitializePostBody = zod
	.object({
		group_id: zod.number().describe('The group to be initialized.'),
		score_bands_config: zod
			.object({
				score_bands_config: zod
					.object({
						dimensions: zod
							.union([zod.array(zod.string()), zod.null()])
							.optional()
							.describe(
								'List of variable/objective names (i.e., column names in the data) to include in the visualization.\nIf None, all columns in the data are used. Defaults to None.'
							),
						descriptive_names: zod
							.union([zod.record(zod.string(), zod.string()), zod.null()])
							.optional()
							.describe(
								'Optional dictionary mapping dimensions to descriptive names for display in the visualization.\nIf None, the original dimension names are used. Defaults to None.'
							),
						units: zod
							.union([zod.record(zod.string(), zod.string()), zod.null()])
							.optional()
							.describe(
								'Optional dictionary mapping dimensions to their units for display in the visualization.\nIf None, no units are displayed. Defaults to None.'
							),
						axis_positions: zod
							.union([zod.record(zod.string(), zod.number()), zod.null()])
							.optional()
							.describe(
								'Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first\nobjective is at position 0.0, and the last objective is at position 1.0. Use this option if you want to\nmanually set the axis positions. If None, the axis positions are calculated automatically based on correlations.\nDefaults to None.'
							),
						clustering_algorithm: zod
							.union([
								zod
									.object({
										name: zod
											.string()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmOneNameDefault
											)
											.describe('Gaussian Mixture Model clustering algorithm.'),
										scoring_method: zod
											.enum(['BIC', 'silhouette'])
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmOneScoringMethodDefault
											)
											.describe(
												'Scoring method to use for GMM. Either \"BIC\" or \"silhouette\". Defaults to \"silhouette\".\nThis option determines how the number of clusters is chosen.'
											)
									})
									.describe('Options for Gaussian Mixture Model clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmTwoNameDefault
											)
											.describe('DBSCAN clustering algorithm.')
									})
									.describe('Options for DBSCAN clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmThreeNameDefault
											)
											.describe('KMeans clustering algorithm.'),
										n_clusters: zod
											.number()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmThreeNClustersDefault
											)
											.describe('Number of clusters to use. Defaults to 5.')
									})
									.describe('Options for KMeans clustering algorithm.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFourNameDefault
											)
											.describe('Clustering by one of the dimensions.'),
										dimension_name: zod.string().describe('Dimension to use for clustering.'),
										n_clusters: zod
											.number()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFourNClustersDefault
											)
											.describe('Number of clusters to use. Defaults to 5.'),
										kind: zod
											.enum(['EqualWidth', 'EqualFrequency'])
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFourKindDefault
											)
											.describe(
												'Kind of clustering to use. Either \"EqualWidth\", which divides the dimension range into equal width intervals,\nor \"EqualFrequency\", which divides the dimension values into intervals with equal number of solutions.\nDefaults to \"EqualWidth\".'
											)
									})
									.describe('Options for clustering by one of the objectives/decision variables.'),
								zod
									.object({
										name: zod
											.string()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmFiveNameDefault
											)
											.describe('Custom user-provided clusters.'),
										clusters: zod
											.array(zod.number())
											.describe(
												'List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.'
											)
									})
									.describe('Options for custom clustering provided by the user.')
							])
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigClusteringAlgorithmDefault
							)
							.describe(
								'Clustering algorithm to use. Currently supported options: \"GMM\", \"DBSCAN\",\n    and \"KMeans\". Defaults to \"DBSCAN\".'
							),
						distance_formula: zod
							.union([zod.literal(1), zod.literal(2)])
							.optional()
							.describe('Distance formulas supported by SCORE bands. See the paper for details.'),
						distance_parameter: zod
							.number()
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigDistanceParameterDefault
							)
							.describe(
								'Change the relative distances between the objective axes. Increase this value if objectives are placed too close\ntogether. Decrease this value if the objectives are equidistant in a problem with objective clusters. Defaults\nto 0.05.'
							),
						use_absolute_correlations: zod
							.boolean()
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigUseAbsoluteCorrelationsDefault
							)
							.describe(
								'Whether to use absolute value of the correlation to calculate the placement of axes. Defaults to False.'
							),
						include_solutions: zod
							.boolean()
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigIncludeSolutionsDefault
							)
							.describe(
								'Whether to include individual solutions. Defaults to False. If True, the size of the resulting figure may be\nvery large for datasets with many solutions. Moreover, the individual traces are hidden by default, but can be\nviewed interactively in the figure.'
							),
						include_medians: zod
							.boolean()
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigIncludeMediansDefault
							)
							.describe(
								'Whether to include cluster medians. Defaults to False. If True, the median traces are hidden by default, but\ncan be viewed interactively in the figure.'
							),
						interval_size: zod
							.number()
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigScoreBandsConfigIntervalSizeDefault
							)
							.describe(
								'The size (as a fraction) of the interval to use for the bands. Defaults to 0.95, meaning that 95% of the\nmiddle solutions in a cluster will be included in the band. The rest will be considered outliers.'
							),
						scales: zod
							.union([
								zod.record(zod.string(), zod.tuple([zod.number(), zod.number()])),
								zod.null()
							])
							.optional()
							.describe(
								'Optional dictionary specifying the min and max values for each objective. The keys should be the\nobjective names (i.e., column names in the data), and the values should be tuples of (min, max).\nIf not provided, the min and max will be calculated from the data.'
							)
					})
					.optional()
					.describe('Configuration options for SCORE bands visualization.'),
				minimum_votes: zod
					.number()
					.gt(
						getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigMinimumVotesExclusiveMin
					)
					.default(
						getOrInitializeGdmScoreBandsGetOrInitializePostBodyScoreBandsConfigMinimumVotesDefault
					),
				from_iteration: zod.union([zod.number(), zod.null()])
			})
			.describe('Configuration for the SCORE bands based GDM.')
	})
	.describe('Request class for initialization of score bands.');

export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneMethodDefault = `gdm-score-bands`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmOneNameDefault = `GMM`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmOneScoringMethodDefault = `silhouette`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmTwoNameDefault = `DBSCAN`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmThreeNameDefault = `KMeans`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmThreeNClustersDefault = 5;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFourNameDefault = `DimensionCluster`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFourNClustersDefault = 5;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFourKindDefault = `EqualWidth`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFiveNameDefault = `Custom`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmDefault =
	{ name: 'DBSCAN' };
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsDistanceParameterDefault = 0.05;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsUseAbsoluteCorrelationsDefault = false;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsIncludeSolutionsDefault = false;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsIncludeMediansDefault = false;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsIntervalSizeDefault = 0.95;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemTwoMethodDefault = `gdm-score-bands-final`;
export const getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemTwoResultMethodDefault = `gdm-score-bands-final`;

export const GetOrInitializeGdmScoreBandsGetOrInitializePostResponse = zod
	.object({
		history: zod.array(
			zod.union([
				zod
					.object({
						method: zod
							.string()
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneMethodDefault
							),
						group_id: zod.number().describe('The group in question.'),
						group_iter_id: zod.number().describe('ID of the latest group iteration.'),
						latest_iteration: zod
							.number()
							.describe('The latest GDM iteration number. Different from Group Iteration id.'),
						result: zod
							.object({
								options: zod
									.object({
										dimensions: zod
											.union([zod.array(zod.string()), zod.null()])
											.optional()
											.describe(
												'List of variable/objective names (i.e., column names in the data) to include in the visualization.\nIf None, all columns in the data are used. Defaults to None.'
											),
										descriptive_names: zod
											.union([zod.record(zod.string(), zod.string()), zod.null()])
											.optional()
											.describe(
												'Optional dictionary mapping dimensions to descriptive names for display in the visualization.\nIf None, the original dimension names are used. Defaults to None.'
											),
										units: zod
											.union([zod.record(zod.string(), zod.string()), zod.null()])
											.optional()
											.describe(
												'Optional dictionary mapping dimensions to their units for display in the visualization.\nIf None, no units are displayed. Defaults to None.'
											),
										axis_positions: zod
											.union([zod.record(zod.string(), zod.number()), zod.null()])
											.optional()
											.describe(
												'Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first\nobjective is at position 0.0, and the last objective is at position 1.0. Use this option if you want to\nmanually set the axis positions. If None, the axis positions are calculated automatically based on correlations.\nDefaults to None.'
											),
										clustering_algorithm: zod
											.union([
												zod
													.object({
														name: zod
															.string()
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmOneNameDefault
															)
															.describe('Gaussian Mixture Model clustering algorithm.'),
														scoring_method: zod
															.enum(['BIC', 'silhouette'])
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmOneScoringMethodDefault
															)
															.describe(
																'Scoring method to use for GMM. Either \"BIC\" or \"silhouette\". Defaults to \"silhouette\".\nThis option determines how the number of clusters is chosen.'
															)
													})
													.describe('Options for Gaussian Mixture Model clustering algorithm.'),
												zod
													.object({
														name: zod
															.string()
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmTwoNameDefault
															)
															.describe('DBSCAN clustering algorithm.')
													})
													.describe('Options for DBSCAN clustering algorithm.'),
												zod
													.object({
														name: zod
															.string()
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmThreeNameDefault
															)
															.describe('KMeans clustering algorithm.'),
														n_clusters: zod
															.number()
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmThreeNClustersDefault
															)
															.describe('Number of clusters to use. Defaults to 5.')
													})
													.describe('Options for KMeans clustering algorithm.'),
												zod
													.object({
														name: zod
															.string()
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFourNameDefault
															)
															.describe('Clustering by one of the dimensions.'),
														dimension_name: zod
															.string()
															.describe('Dimension to use for clustering.'),
														n_clusters: zod
															.number()
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFourNClustersDefault
															)
															.describe('Number of clusters to use. Defaults to 5.'),
														kind: zod
															.enum(['EqualWidth', 'EqualFrequency'])
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFourKindDefault
															)
															.describe(
																'Kind of clustering to use. Either \"EqualWidth\", which divides the dimension range into equal width intervals,\nor \"EqualFrequency\", which divides the dimension values into intervals with equal number of solutions.\nDefaults to \"EqualWidth\".'
															)
													})
													.describe(
														'Options for clustering by one of the objectives/decision variables.'
													),
												zod
													.object({
														name: zod
															.string()
															.default(
																getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmFiveNameDefault
															)
															.describe('Custom user-provided clusters.'),
														clusters: zod
															.array(zod.number())
															.describe(
																'List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.'
															)
													})
													.describe('Options for custom clustering provided by the user.')
											])
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsClusteringAlgorithmDefault
											)
											.describe(
												'Clustering algorithm to use. Currently supported options: \"GMM\", \"DBSCAN\",\n    and \"KMeans\". Defaults to \"DBSCAN\".'
											),
										distance_formula: zod
											.union([zod.literal(1), zod.literal(2)])
											.optional()
											.describe(
												'Distance formulas supported by SCORE bands. See the paper for details.'
											),
										distance_parameter: zod
											.number()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsDistanceParameterDefault
											)
											.describe(
												'Change the relative distances between the objective axes. Increase this value if objectives are placed too close\ntogether. Decrease this value if the objectives are equidistant in a problem with objective clusters. Defaults\nto 0.05.'
											),
										use_absolute_correlations: zod
											.boolean()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsUseAbsoluteCorrelationsDefault
											)
											.describe(
												'Whether to use absolute value of the correlation to calculate the placement of axes. Defaults to False.'
											),
										include_solutions: zod
											.boolean()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsIncludeSolutionsDefault
											)
											.describe(
												'Whether to include individual solutions. Defaults to False. If True, the size of the resulting figure may be\nvery large for datasets with many solutions. Moreover, the individual traces are hidden by default, but can be\nviewed interactively in the figure.'
											),
										include_medians: zod
											.boolean()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsIncludeMediansDefault
											)
											.describe(
												'Whether to include cluster medians. Defaults to False. If True, the median traces are hidden by default, but\ncan be viewed interactively in the figure.'
											),
										interval_size: zod
											.number()
											.default(
												getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemOneResultOptionsIntervalSizeDefault
											)
											.describe(
												'The size (as a fraction) of the interval to use for the bands. Defaults to 0.95, meaning that 95% of the\nmiddle solutions in a cluster will be included in the band. The rest will be considered outliers.'
											),
										scales: zod
											.union([
												zod.record(zod.string(), zod.tuple([zod.number(), zod.number()])),
												zod.null()
											])
											.optional()
											.describe(
												'Optional dictionary specifying the min and max values for each objective. The keys should be the\nobjective names (i.e., column names in the data), and the values should be tuples of (min, max).\nIf not provided, the min and max will be calculated from the data.'
											)
									})
									.describe('Configuration options for SCORE bands visualization.'),
								ordered_dimensions: zod
									.array(zod.string())
									.describe(
										'List of variable/objective names (i.e., column names in the data).\nOrdered according to their placement in the SCORE bands visualization.'
									),
								clusters: zod
									.array(zod.number())
									.describe(
										'List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.'
									),
								axis_positions: zod
									.record(zod.string(), zod.number())
									.describe(
										'Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first\nobjective is at position 0.0, and the last objective is at position 1.0.'
									),
								bands: zod
									.record(
										zod.string(),
										zod.record(zod.string(), zod.tuple([zod.number(), zod.number()]))
									)
									.describe(
										'Dictionary mapping cluster IDs to dictionaries of objective names and their corresponding band\nextremes (min, max).'
									),
								medians: zod
									.record(zod.string(), zod.record(zod.string(), zod.number()))
									.describe(
										'Dictionary mapping cluster IDs to dictionaries of objective names and their corresponding median values.'
									),
								cardinalities: zod
									.record(zod.string(), zod.number())
									.describe(
										'Dictionary mapping cluster IDs to the number of solutions in each cluster.'
									)
							})
							.describe('Pydantic/JSON model for representing SCORE Bands.')
					})
					.describe('Response class for GDMSCOREBands, whether it is initialization or not.'),
				zod
					.object({
						method: zod
							.string()
							.default(
								getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemTwoMethodDefault
							),
						group_id: zod.number().describe('The group in question.'),
						group_iter_id: zod.number().describe('ID of the latest group iteration.'),
						result: zod
							.object({
								method: zod
									.string()
									.default(
										getOrInitializeGdmScoreBandsGetOrInitializePostResponseHistoryItemTwoResultMethodDefault
									),
								user_votes: zod.record(zod.string(), zod.number()).describe('Dictionary of votes.'),
								user_confirms: zod
									.array(zod.number())
									.describe('List of users who want to move on.'),
								solution_variables: zod.record(
									zod.string(),
									zod.array(zod.union([zod.number(), zod.number(), zod.boolean()]))
								),
								solution_objectives: zod.record(zod.string(), zod.array(zod.number())),
								winner_solution_variables: zod.record(
									zod.string(),
									zod.union([zod.number(), zod.number(), zod.boolean()])
								),
								winner_solution_objectives: zod.record(zod.string(), zod.number())
							})
							.describe(
								'Class for containing the final 10 or less solutions, the final solution and the votes that led to it.'
							)
					})
					.describe(
						'Response class for gdm score bands that includes the last 10 or less solutions.'
					)
			])
		)
	})
	.describe('Response class for all history. Allows for going to a previous iteration.');

/**
 * Returns the current status of votes and confirmations in current iteration.

Args:
    request (GroupInfoRequest): The group we'd like the info on.
    user (Annotated[User, Depends): The user that requests the data.
    session (Annotated[Session, Depends): The database session.

Raises:
    HTTPException: If group doesn't exists etc errors.

Returns:
    JSONResponse: A response containing the votes and confirmations.
 * @summary Get Votes And Confirms
 */
export const GetVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostBody = zod
	.object({
		group_id: zod.number()
	})
	.describe('Class for requesting group information.');

export const GetVotesAndConfirmsGdmScoreBandsGetVotesAndConfirmsPostResponse = zod.unknown();

/**
 * Revert to a previous iteration. Usable only by the analyst.

This implies that we're gonna need to see ALL previous iterations I'd say.

Args:
    request (GDMSCOREBandsRevertRequest): The request containing group id and iteration number.
    user (Annotated[User, Depends): The current user.
    session (Annotated[Session, Depends): The database session.

Returns:
    JSONResponse: Acknowledgement of the revert.
 * @summary Revert
 */
export const RevertGdmScoreBandsRevertPostBody = zod
	.object({
		group_id: zod.number().describe('Group ID.'),
		iteration_number: zod
			.number()
			.describe('The number of the iteration that we want to revert to.')
	})
	.describe('Request for reverting to a previous setup.');

export const RevertGdmScoreBandsRevertPostResponse = zod.unknown();

/**
 * Configure the SCORE Bands settings.

Args:
    config (SCOREBandsGDMConfig): The configuration object
    group_id (int): group id
    user (Annotated[User, Depends): The user doing the request
    session (Annotated[Session, Depends): The database session.

Returns:
    JSONResponse: Acknowledgement that yeah ok reconfigured.
 * @summary Configure Gdm
 */
export const ConfigureGdmGdmScoreBandsConfigurePostQueryParams = zod.object({
	group_id: zod.number()
});

export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmOneNameDefault = `GMM`;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmOneScoringMethodDefault = `silhouette`;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmTwoNameDefault = `DBSCAN`;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmThreeNameDefault = `KMeans`;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmThreeNClustersDefault = 5;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFourNameDefault = `DimensionCluster`;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFourNClustersDefault = 5;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFourKindDefault = `EqualWidth`;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFiveNameDefault = `Custom`;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmDefault =
	{ name: 'DBSCAN' };
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigDistanceParameterDefault = 0.05;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigUseAbsoluteCorrelationsDefault = false;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigIncludeSolutionsDefault = false;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigIncludeMediansDefault = false;
export const configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigIntervalSizeDefault = 0.95;
export const configureGdmGdmScoreBandsConfigurePostBodyMinimumVotesDefault = 1;
export const configureGdmGdmScoreBandsConfigurePostBodyMinimumVotesExclusiveMin = 0;

export const ConfigureGdmGdmScoreBandsConfigurePostBody = zod
	.object({
		score_bands_config: zod
			.object({
				dimensions: zod
					.union([zod.array(zod.string()), zod.null()])
					.optional()
					.describe(
						'List of variable/objective names (i.e., column names in the data) to include in the visualization.\nIf None, all columns in the data are used. Defaults to None.'
					),
				descriptive_names: zod
					.union([zod.record(zod.string(), zod.string()), zod.null()])
					.optional()
					.describe(
						'Optional dictionary mapping dimensions to descriptive names for display in the visualization.\nIf None, the original dimension names are used. Defaults to None.'
					),
				units: zod
					.union([zod.record(zod.string(), zod.string()), zod.null()])
					.optional()
					.describe(
						'Optional dictionary mapping dimensions to their units for display in the visualization.\nIf None, no units are displayed. Defaults to None.'
					),
				axis_positions: zod
					.union([zod.record(zod.string(), zod.number()), zod.null()])
					.optional()
					.describe(
						'Dictionary mapping objective names to their positions on the axes in the SCORE bands visualization. The first\nobjective is at position 0.0, and the last objective is at position 1.0. Use this option if you want to\nmanually set the axis positions. If None, the axis positions are calculated automatically based on correlations.\nDefaults to None.'
					),
				clustering_algorithm: zod
					.union([
						zod
							.object({
								name: zod
									.string()
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmOneNameDefault
									)
									.describe('Gaussian Mixture Model clustering algorithm.'),
								scoring_method: zod
									.enum(['BIC', 'silhouette'])
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmOneScoringMethodDefault
									)
									.describe(
										'Scoring method to use for GMM. Either \"BIC\" or \"silhouette\". Defaults to \"silhouette\".\nThis option determines how the number of clusters is chosen.'
									)
							})
							.describe('Options for Gaussian Mixture Model clustering algorithm.'),
						zod
							.object({
								name: zod
									.string()
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmTwoNameDefault
									)
									.describe('DBSCAN clustering algorithm.')
							})
							.describe('Options for DBSCAN clustering algorithm.'),
						zod
							.object({
								name: zod
									.string()
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmThreeNameDefault
									)
									.describe('KMeans clustering algorithm.'),
								n_clusters: zod
									.number()
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmThreeNClustersDefault
									)
									.describe('Number of clusters to use. Defaults to 5.')
							})
							.describe('Options for KMeans clustering algorithm.'),
						zod
							.object({
								name: zod
									.string()
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFourNameDefault
									)
									.describe('Clustering by one of the dimensions.'),
								dimension_name: zod.string().describe('Dimension to use for clustering.'),
								n_clusters: zod
									.number()
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFourNClustersDefault
									)
									.describe('Number of clusters to use. Defaults to 5.'),
								kind: zod
									.enum(['EqualWidth', 'EqualFrequency'])
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFourKindDefault
									)
									.describe(
										'Kind of clustering to use. Either \"EqualWidth\", which divides the dimension range into equal width intervals,\nor \"EqualFrequency\", which divides the dimension values into intervals with equal number of solutions.\nDefaults to \"EqualWidth\".'
									)
							})
							.describe('Options for clustering by one of the objectives/decision variables.'),
						zod
							.object({
								name: zod
									.string()
									.default(
										configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmFiveNameDefault
									)
									.describe('Custom user-provided clusters.'),
								clusters: zod
									.array(zod.number())
									.describe(
										'List of cluster IDs (one for each solution) indicating the cluster to which each solution belongs.'
									)
							})
							.describe('Options for custom clustering provided by the user.')
					])
					.default(
						configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigClusteringAlgorithmDefault
					)
					.describe(
						'Clustering algorithm to use. Currently supported options: \"GMM\", \"DBSCAN\",\n    and \"KMeans\". Defaults to \"DBSCAN\".'
					),
				distance_formula: zod
					.union([zod.literal(1), zod.literal(2)])
					.optional()
					.describe('Distance formulas supported by SCORE bands. See the paper for details.'),
				distance_parameter: zod
					.number()
					.default(
						configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigDistanceParameterDefault
					)
					.describe(
						'Change the relative distances between the objective axes. Increase this value if objectives are placed too close\ntogether. Decrease this value if the objectives are equidistant in a problem with objective clusters. Defaults\nto 0.05.'
					),
				use_absolute_correlations: zod
					.boolean()
					.default(
						configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigUseAbsoluteCorrelationsDefault
					)
					.describe(
						'Whether to use absolute value of the correlation to calculate the placement of axes. Defaults to False.'
					),
				include_solutions: zod
					.boolean()
					.default(
						configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigIncludeSolutionsDefault
					)
					.describe(
						'Whether to include individual solutions. Defaults to False. If True, the size of the resulting figure may be\nvery large for datasets with many solutions. Moreover, the individual traces are hidden by default, but can be\nviewed interactively in the figure.'
					),
				include_medians: zod
					.boolean()
					.default(configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigIncludeMediansDefault)
					.describe(
						'Whether to include cluster medians. Defaults to False. If True, the median traces are hidden by default, but\ncan be viewed interactively in the figure.'
					),
				interval_size: zod
					.number()
					.default(configureGdmGdmScoreBandsConfigurePostBodyScoreBandsConfigIntervalSizeDefault)
					.describe(
						'The size (as a fraction) of the interval to use for the bands. Defaults to 0.95, meaning that 95% of the\nmiddle solutions in a cluster will be included in the band. The rest will be considered outliers.'
					),
				scales: zod
					.union([zod.record(zod.string(), zod.tuple([zod.number(), zod.number()])), zod.null()])
					.optional()
					.describe(
						'Optional dictionary specifying the min and max values for each objective. The keys should be the\nobjective names (i.e., column names in the data), and the values should be tuples of (min, max).\nIf not provided, the min and max will be calculated from the data.'
					)
			})
			.optional()
			.describe('Configuration options for SCORE bands visualization.'),
		minimum_votes: zod
			.number()
			.gt(configureGdmGdmScoreBandsConfigurePostBodyMinimumVotesExclusiveMin)
			.default(configureGdmGdmScoreBandsConfigurePostBodyMinimumVotesDefault),
		from_iteration: zod.union([zod.number(), zod.null()])
	})
	.describe('Configuration for the SCORE bands based GDM.');

export const ConfigureGdmGdmScoreBandsConfigurePostResponse = zod.unknown();
