/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * DESDEO (fast)API
 * A rest API for the DESDEO framework.
 * OpenAPI spec version: 0.1.0
 */
import type {
	BodyAddNewAnalystAddNewAnalystPost,
	BodyAddNewDmAddNewDmPost,
	BodyLoginLoginPost,
	CreateSessionRequest,
	EnautilusStepRequest,
	GNIMBUSSwitchPhaseRequest,
	GetSessionRequest,
	GroupCreateRequest,
	GroupInfoRequest,
	GroupModifyRequest,
	HTTPValidationError,
	IntermediateSolutionRequest,
	LoginLoginPostParams,
	NIMBUSClassificationRequest,
	NIMBUSInitializationRequest,
	NIMBUSSaveRequest,
	ProblemGetRequest,
	ProblemMetaDataGetRequest,
	ProblemSelectSolverRequest,
	RPMSolveRequest,
	ScoreBandsRequest,
	UtopiaRequest
} from '../models';

import { faker } from '@faker-js/faker';

import { HttpResponse, delay, http } from 'msw';
import type { RequestHandlerOptions } from 'msw';

import {
	ConstraintTypeEnum,
	ObjectiveTypeEnum,
	UserRole,
	VariableDomainTypeEnum,
	VariableTypeEnum
} from '../models';
import type {
	ENautilusState,
	GNIMBUSAllIterationsResponse,
	GNIMBUSResultResponse,
	GNIMBUSSwitchPhaseResponse,
	GenericIntermediateSolutionResponse,
	GetMetadataProblemGetMetadataPost200Item,
	GetOrInitializeMethodNimbusGetOrInitializePost200,
	GroupPublic,
	InteractiveSessionBase,
	NIMBUSClassificationResponse,
	NIMBUSInitializationResponse,
	NIMBUSIntermediateSolutionResponse,
	NIMBUSSaveResponse,
	ProblemInfo,
	ProblemInfoSmall,
	RPMState,
	ScoreBandsResponse,
	Tokens,
	UserPublic,
	UtopiaResponse
} from '../models';

import { customFetch } from '../../api/new-client';
/**
 * Return information about the current user.

Args:
    user (Annotated[User, Depends): user dependency, handled by `get_current_user`.

Returns:
    UserPublic: public information about the current user.
 * @summary Get Current User Info
 */
export type getCurrentUserInfoUserInfoGetResponse200 = {
	data: UserPublic;
	status: 200;
};

export type getCurrentUserInfoUserInfoGetResponseSuccess =
	getCurrentUserInfoUserInfoGetResponse200 & {
		headers: Headers;
	};
export type getCurrentUserInfoUserInfoGetResponse = getCurrentUserInfoUserInfoGetResponseSuccess;

export const getGetCurrentUserInfoUserInfoGetUrl = () => {
	return `http://localhost:8000/user_info`;
};

export const getCurrentUserInfoUserInfoGet = async (
	options?: RequestInit
): Promise<getCurrentUserInfoUserInfoGetResponse> => {
	return customFetch<getCurrentUserInfoUserInfoGetResponse>(getGetCurrentUserInfoUserInfoGetUrl(), {
		...options,
		method: 'GET'
	});
};

/**
 * Login to get an authentication token.

Return an access token in the response and a cookie storing a refresh token.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]):
        The form data to authenticate the user.
    session (Annotated[Session, Depends(get_db)]): The database session.
    cookie_max_age (int): the lifetime of the cookie storing the refresh token.
 * @summary Login
 */
export type loginLoginPostResponse200 = {
	data: Tokens;
	status: 200;
};

export type loginLoginPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type loginLoginPostResponseSuccess = loginLoginPostResponse200 & {
	headers: Headers;
};
export type loginLoginPostResponseError = loginLoginPostResponse422 & {
	headers: Headers;
};

export type loginLoginPostResponse = loginLoginPostResponseSuccess | loginLoginPostResponseError;

export const getLoginLoginPostUrl = (params?: LoginLoginPostParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? 'null' : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `http://localhost:8000/login?${stringifiedParams}`
		: `http://localhost:8000/login`;
};

export const loginLoginPost = async (
	bodyLoginLoginPost: BodyLoginLoginPost,
	params?: LoginLoginPostParams,
	options?: RequestInit
): Promise<loginLoginPostResponse> => {
	const formUrlEncoded = new URLSearchParams();
	if (bodyLoginLoginPost.grant_type !== undefined && bodyLoginLoginPost.grant_type !== null) {
		formUrlEncoded.append(`grant_type`, bodyLoginLoginPost.grant_type);
	}
	formUrlEncoded.append(`username`, bodyLoginLoginPost.username);
	formUrlEncoded.append(`password`, bodyLoginLoginPost.password);
	if (bodyLoginLoginPost.scope !== undefined) {
		formUrlEncoded.append(`scope`, bodyLoginLoginPost.scope);
	}
	if (bodyLoginLoginPost.client_id !== undefined && bodyLoginLoginPost.client_id !== null) {
		formUrlEncoded.append(`client_id`, bodyLoginLoginPost.client_id);
	}
	if (bodyLoginLoginPost.client_secret !== undefined && bodyLoginLoginPost.client_secret !== null) {
		formUrlEncoded.append(`client_secret`, bodyLoginLoginPost.client_secret);
	}

	return customFetch<loginLoginPostResponse>(getLoginLoginPostUrl(params), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
		body: formUrlEncoded
	});
};

/**
 * Log the current user out. Deletes the refresh token that was set by logging in.

Args:
    None

Returns:
    JSONResponse: A response in which the cookies are deleted
 * @summary Logout
 */
export type logoutLogoutPostResponse200 = {
	data: unknown;
	status: 200;
};

export type logoutLogoutPostResponseSuccess = logoutLogoutPostResponse200 & {
	headers: Headers;
};
export type logoutLogoutPostResponse = logoutLogoutPostResponseSuccess;

export const getLogoutLogoutPostUrl = () => {
	return `http://localhost:8000/logout`;
};

export const logoutLogoutPost = async (
	options?: RequestInit
): Promise<logoutLogoutPostResponse> => {
	return customFetch<logoutLogoutPostResponse>(getLogoutLogoutPostUrl(), {
		...options,
		method: 'POST'
	});
};

/**
 * Refresh the access token using the refresh token stored in the cookie.

Args:
    request (Request): The request containing the cookie.
    session (Annotated[Session, Depends(get_db)]): the database session.
    refresh_token (Annotated[Str | None, Cookie()]): the refresh
        token, which is fetched from a cookie included in the response.

Returns:
    dict: A dictionary containing the new access token.
 * @summary Refresh Access Token
 */
export type refreshAccessTokenRefreshPostResponse200 = {
	data: unknown;
	status: 200;
};

export type refreshAccessTokenRefreshPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type refreshAccessTokenRefreshPostResponseSuccess =
	refreshAccessTokenRefreshPostResponse200 & {
		headers: Headers;
	};
export type refreshAccessTokenRefreshPostResponseError =
	refreshAccessTokenRefreshPostResponse422 & {
		headers: Headers;
	};

export type refreshAccessTokenRefreshPostResponse =
	| refreshAccessTokenRefreshPostResponseSuccess
	| refreshAccessTokenRefreshPostResponseError;

export const getRefreshAccessTokenRefreshPostUrl = () => {
	return `http://localhost:8000/refresh`;
};

export const refreshAccessTokenRefreshPost = async (
	options?: RequestInit
): Promise<refreshAccessTokenRefreshPostResponse> => {
	return customFetch<refreshAccessTokenRefreshPostResponse>(getRefreshAccessTokenRefreshPostUrl(), {
		...options,
		method: 'POST'
	});
};

/**
 * Add a new user of the role Decision Maker to the database. Requires no login.

Args:
    form_data (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if username is already in use or if saving to the database fails for some reason.
 * @summary Add New Dm
 */
export type addNewDmAddNewDmPostResponse200 = {
	data: unknown;
	status: 200;
};

export type addNewDmAddNewDmPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addNewDmAddNewDmPostResponseSuccess = addNewDmAddNewDmPostResponse200 & {
	headers: Headers;
};
export type addNewDmAddNewDmPostResponseError = addNewDmAddNewDmPostResponse422 & {
	headers: Headers;
};

export type addNewDmAddNewDmPostResponse =
	| addNewDmAddNewDmPostResponseSuccess
	| addNewDmAddNewDmPostResponseError;

export const getAddNewDmAddNewDmPostUrl = () => {
	return `http://localhost:8000/add_new_dm`;
};

export const addNewDmAddNewDmPost = async (
	bodyAddNewDmAddNewDmPost: BodyAddNewDmAddNewDmPost,
	options?: RequestInit
): Promise<addNewDmAddNewDmPostResponse> => {
	const formUrlEncoded = new URLSearchParams();
	if (
		bodyAddNewDmAddNewDmPost.grant_type !== undefined &&
		bodyAddNewDmAddNewDmPost.grant_type !== null
	) {
		formUrlEncoded.append(`grant_type`, bodyAddNewDmAddNewDmPost.grant_type);
	}
	formUrlEncoded.append(`username`, bodyAddNewDmAddNewDmPost.username);
	formUrlEncoded.append(`password`, bodyAddNewDmAddNewDmPost.password);
	if (bodyAddNewDmAddNewDmPost.scope !== undefined) {
		formUrlEncoded.append(`scope`, bodyAddNewDmAddNewDmPost.scope);
	}
	if (
		bodyAddNewDmAddNewDmPost.client_id !== undefined &&
		bodyAddNewDmAddNewDmPost.client_id !== null
	) {
		formUrlEncoded.append(`client_id`, bodyAddNewDmAddNewDmPost.client_id);
	}
	if (
		bodyAddNewDmAddNewDmPost.client_secret !== undefined &&
		bodyAddNewDmAddNewDmPost.client_secret !== null
	) {
		formUrlEncoded.append(`client_secret`, bodyAddNewDmAddNewDmPost.client_secret);
	}

	return customFetch<addNewDmAddNewDmPostResponse>(getAddNewDmAddNewDmPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
		body: formUrlEncoded
	});
};

/**
 * Add a new user of the role Analyst to the database. Requires a logged in analyst or an admin.

Args:
    user: Annotated[User, Depends(get_current_user)]: Logged in user with the role "analyst" or "admin".
    form_data: (Annotated[OAuth2PasswordRequestForm, Depends()]): The user credentials to add to the database.
    session: (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: A JSON response

Raises:
    HTTPException: if the logged in user is not an analyst or an admin or if
    username is already in use or if saving to the database fails for some reason.
 * @summary Add New Analyst
 */
export type addNewAnalystAddNewAnalystPostResponse200 = {
	data: unknown;
	status: 200;
};

export type addNewAnalystAddNewAnalystPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addNewAnalystAddNewAnalystPostResponseSuccess =
	addNewAnalystAddNewAnalystPostResponse200 & {
		headers: Headers;
	};
export type addNewAnalystAddNewAnalystPostResponseError =
	addNewAnalystAddNewAnalystPostResponse422 & {
		headers: Headers;
	};

export type addNewAnalystAddNewAnalystPostResponse =
	| addNewAnalystAddNewAnalystPostResponseSuccess
	| addNewAnalystAddNewAnalystPostResponseError;

export const getAddNewAnalystAddNewAnalystPostUrl = () => {
	return `http://localhost:8000/add_new_analyst`;
};

export const addNewAnalystAddNewAnalystPost = async (
	bodyAddNewAnalystAddNewAnalystPost: BodyAddNewAnalystAddNewAnalystPost,
	options?: RequestInit
): Promise<addNewAnalystAddNewAnalystPostResponse> => {
	const formUrlEncoded = new URLSearchParams();
	if (
		bodyAddNewAnalystAddNewAnalystPost.grant_type !== undefined &&
		bodyAddNewAnalystAddNewAnalystPost.grant_type !== null
	) {
		formUrlEncoded.append(`grant_type`, bodyAddNewAnalystAddNewAnalystPost.grant_type);
	}
	formUrlEncoded.append(`username`, bodyAddNewAnalystAddNewAnalystPost.username);
	formUrlEncoded.append(`password`, bodyAddNewAnalystAddNewAnalystPost.password);
	if (bodyAddNewAnalystAddNewAnalystPost.scope !== undefined) {
		formUrlEncoded.append(`scope`, bodyAddNewAnalystAddNewAnalystPost.scope);
	}
	if (
		bodyAddNewAnalystAddNewAnalystPost.client_id !== undefined &&
		bodyAddNewAnalystAddNewAnalystPost.client_id !== null
	) {
		formUrlEncoded.append(`client_id`, bodyAddNewAnalystAddNewAnalystPost.client_id);
	}
	if (
		bodyAddNewAnalystAddNewAnalystPost.client_secret !== undefined &&
		bodyAddNewAnalystAddNewAnalystPost.client_secret !== null
	) {
		formUrlEncoded.append(`client_secret`, bodyAddNewAnalystAddNewAnalystPost.client_secret);
	}

	return customFetch<addNewAnalystAddNewAnalystPostResponse>(
		getAddNewAnalystAddNewAnalystPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
			body: formUrlEncoded
		}
	);
};

/**
 * Get information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfoSmall]: a list of information on all the problems.
 * @summary Get Problems
 */
export type getProblemsProblemAllGetResponse200 = {
	data: ProblemInfoSmall[];
	status: 200;
};

export type getProblemsProblemAllGetResponseSuccess = getProblemsProblemAllGetResponse200 & {
	headers: Headers;
};
export type getProblemsProblemAllGetResponse = getProblemsProblemAllGetResponseSuccess;

export const getGetProblemsProblemAllGetUrl = () => {
	return `http://localhost:8000/problem/all`;
};

export const getProblemsProblemAllGet = async (
	options?: RequestInit
): Promise<getProblemsProblemAllGetResponse> => {
	return customFetch<getProblemsProblemAllGetResponse>(getGetProblemsProblemAllGetUrl(), {
		...options,
		method: 'GET'
	});
};

/**
 * Get detailed information on all the current user's problems.

Args:
    user (Annotated[User, Depends): the current user.

Returns:
    list[ProblemInfo]: a list of the detailed information on all the problems.
 * @summary Get Problems Info
 */
export type getProblemsInfoProblemAllInfoGetResponse200 = {
	data: ProblemInfo[];
	status: 200;
};

export type getProblemsInfoProblemAllInfoGetResponseSuccess =
	getProblemsInfoProblemAllInfoGetResponse200 & {
		headers: Headers;
	};
export type getProblemsInfoProblemAllInfoGetResponse =
	getProblemsInfoProblemAllInfoGetResponseSuccess;

export const getGetProblemsInfoProblemAllInfoGetUrl = () => {
	return `http://localhost:8000/problem/all_info`;
};

export const getProblemsInfoProblemAllInfoGet = async (
	options?: RequestInit
): Promise<getProblemsInfoProblemAllInfoGetResponse> => {
	return customFetch<getProblemsInfoProblemAllInfoGetResponse>(
		getGetProblemsInfoProblemAllInfoGetUrl(),
		{
			...options,
			method: 'GET'
		}
	);
};

/**
 * Get the model of a specific problem.

Args:
    request (ProblemGetRequest): the request containing the problem's id `problem_id`.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find a problem with the given id.

Returns:
    ProblemInfo: detailed information on the requested problem.
 * @summary Get Problem
 */
export type getProblemProblemGetPostResponse200 = {
	data: ProblemInfo;
	status: 200;
};

export type getProblemProblemGetPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getProblemProblemGetPostResponseSuccess = getProblemProblemGetPostResponse200 & {
	headers: Headers;
};
export type getProblemProblemGetPostResponseError = getProblemProblemGetPostResponse422 & {
	headers: Headers;
};

export type getProblemProblemGetPostResponse =
	| getProblemProblemGetPostResponseSuccess
	| getProblemProblemGetPostResponseError;

export const getGetProblemProblemGetPostUrl = () => {
	return `http://localhost:8000/problem/get`;
};

export const getProblemProblemGetPost = async (
	problemGetRequest: ProblemGetRequest,
	options?: RequestInit
): Promise<getProblemProblemGetPostResponse> => {
	return customFetch<getProblemProblemGetPostResponse>(getGetProblemProblemGetPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(problemGetRequest)
	});
};

/**
 * Add a newly defined problem to the database.

Args:
    request (Problem): the JSON representation of the problem.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Note:
    Users with the role 'guest' may not add new problems.

Raises:
    HTTPException: when any issue with defining the problem arises.

Returns:
    ProblemInfo: the information about the problem added.
 * @summary Add Problem
 */
export type addProblemProblemAddPostResponse200 = {
	data: ProblemInfo;
	status: 200;
};

export type addProblemProblemAddPostResponseSuccess = addProblemProblemAddPostResponse200 & {
	headers: Headers;
};
export type addProblemProblemAddPostResponse = addProblemProblemAddPostResponseSuccess;

export const getAddProblemProblemAddPostUrl = () => {
	return `http://localhost:8000/problem/add`;
};

export const addProblemProblemAddPost = async (
	options?: RequestInit
): Promise<addProblemProblemAddPostResponse> => {
	return customFetch<addProblemProblemAddPostResponse>(getAddProblemProblemAddPostUrl(), {
		...options,
		method: 'POST'
	});
};

/**
 * Fetch specific metadata for a specific problem.

Fetch specific metadata for a specific problem. See all the possible
metadata types from DESDEO/desdeo/api/models/problem.py Problem Metadata
section.

Args:
    request (MetaDataGetRequest): the requested metadata type.
    user (Annotated[User, Depends]): the current user.
    session (Annotated[Session, Depends]): the database session.

Returns:
    list[ForestProblemMetadata | RepresentativeNonDominatedSolutions]: list containing all the metadata
        defined for the problem with the requested metadata type. If no match is found,
        returns an empty list.
 * @summary Get Metadata
 */
export type getMetadataProblemGetMetadataPostResponse200 = {
	data: GetMetadataProblemGetMetadataPost200Item[];
	status: 200;
};

export type getMetadataProblemGetMetadataPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getMetadataProblemGetMetadataPostResponseSuccess =
	getMetadataProblemGetMetadataPostResponse200 & {
		headers: Headers;
	};
export type getMetadataProblemGetMetadataPostResponseError =
	getMetadataProblemGetMetadataPostResponse422 & {
		headers: Headers;
	};

export type getMetadataProblemGetMetadataPostResponse =
	| getMetadataProblemGetMetadataPostResponseSuccess
	| getMetadataProblemGetMetadataPostResponseError;

export const getGetMetadataProblemGetMetadataPostUrl = () => {
	return `http://localhost:8000/problem/get_metadata`;
};

export const getMetadataProblemGetMetadataPost = async (
	problemMetaDataGetRequest: ProblemMetaDataGetRequest,
	options?: RequestInit
): Promise<getMetadataProblemGetMetadataPostResponse> => {
	return customFetch<getMetadataProblemGetMetadataPostResponse>(
		getGetMetadataProblemGetMetadataPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(problemMetaDataGetRequest)
		}
	);
};

/**
 * @summary Select Solver
 */
export type selectSolverProblemAssignSolverPostResponse200 = {
	data: unknown;
	status: 200;
};

export type selectSolverProblemAssignSolverPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type selectSolverProblemAssignSolverPostResponseSuccess =
	selectSolverProblemAssignSolverPostResponse200 & {
		headers: Headers;
	};
export type selectSolverProblemAssignSolverPostResponseError =
	selectSolverProblemAssignSolverPostResponse422 & {
		headers: Headers;
	};

export type selectSolverProblemAssignSolverPostResponse =
	| selectSolverProblemAssignSolverPostResponseSuccess
	| selectSolverProblemAssignSolverPostResponseError;

export const getSelectSolverProblemAssignSolverPostUrl = () => {
	return `http://localhost:8000/problem/assign_solver`;
};

export const selectSolverProblemAssignSolverPost = async (
	problemSelectSolverRequest: ProblemSelectSolverRequest,
	options?: RequestInit
): Promise<selectSolverProblemAssignSolverPostResponse> => {
	return customFetch<selectSolverProblemAssignSolverPostResponse>(
		getSelectSolverProblemAssignSolverPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(problemSelectSolverRequest)
		}
	);
};

/**
 * .
 * @summary Create New Session
 */
export type createNewSessionSessionNewPostResponse200 = {
	data: InteractiveSessionBase;
	status: 200;
};

export type createNewSessionSessionNewPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createNewSessionSessionNewPostResponseSuccess =
	createNewSessionSessionNewPostResponse200 & {
		headers: Headers;
	};
export type createNewSessionSessionNewPostResponseError =
	createNewSessionSessionNewPostResponse422 & {
		headers: Headers;
	};

export type createNewSessionSessionNewPostResponse =
	| createNewSessionSessionNewPostResponseSuccess
	| createNewSessionSessionNewPostResponseError;

export const getCreateNewSessionSessionNewPostUrl = () => {
	return `http://localhost:8000/session/new`;
};

export const createNewSessionSessionNewPost = async (
	createSessionRequest: CreateSessionRequest,
	options?: RequestInit
): Promise<createNewSessionSessionNewPostResponse> => {
	return customFetch<createNewSessionSessionNewPostResponse>(
		getCreateNewSessionSessionNewPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(createSessionRequest)
		}
	);
};

/**
 * Return an interactive session with a given id for the current user.

Args:
    request (GetSessionRequest): a request containing the id of the session.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the database session.

Raises:
    HTTPException: could not find an interactive session with the given id
        for the current user.

Returns:
    InteractiveSessionInfo: info on the requested interactive session.
 * @summary Get Session
 */
export type getSessionSessionGetPostResponse200 = {
	data: InteractiveSessionBase;
	status: 200;
};

export type getSessionSessionGetPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getSessionSessionGetPostResponseSuccess = getSessionSessionGetPostResponse200 & {
	headers: Headers;
};
export type getSessionSessionGetPostResponseError = getSessionSessionGetPostResponse422 & {
	headers: Headers;
};

export type getSessionSessionGetPostResponse =
	| getSessionSessionGetPostResponseSuccess
	| getSessionSessionGetPostResponseError;

export const getGetSessionSessionGetPostUrl = () => {
	return `http://localhost:8000/session/get`;
};

export const getSessionSessionGetPost = async (
	getSessionRequest: GetSessionRequest,
	options?: RequestInit
): Promise<getSessionSessionGetPostResponse> => {
	return customFetch<getSessionSessionGetPostResponse>(getGetSessionSessionGetPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(getSessionRequest)
	});
};

/**
 * Runs an iteration of the reference point method.

Args:
    request (RPMSolveRequest): a request with the needed information to run the method.
    user (Annotated[User, Depends): the current user.
    session (Annotated[Session, Depends): the current database session.

Returns:
    RPMState: a state with information on the results of iterating the reference point method
        once.
 * @summary Solve Solutions
 */
export type solveSolutionsMethodRpmSolvePostResponse200 = {
	data: RPMState;
	status: 200;
};

export type solveSolutionsMethodRpmSolvePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveSolutionsMethodRpmSolvePostResponseSuccess =
	solveSolutionsMethodRpmSolvePostResponse200 & {
		headers: Headers;
	};
export type solveSolutionsMethodRpmSolvePostResponseError =
	solveSolutionsMethodRpmSolvePostResponse422 & {
		headers: Headers;
	};

export type solveSolutionsMethodRpmSolvePostResponse =
	| solveSolutionsMethodRpmSolvePostResponseSuccess
	| solveSolutionsMethodRpmSolvePostResponseError;

export const getSolveSolutionsMethodRpmSolvePostUrl = () => {
	return `http://localhost:8000/method/rpm/solve`;
};

export const solveSolutionsMethodRpmSolvePost = async (
	rPMSolveRequest: RPMSolveRequest,
	options?: RequestInit
): Promise<solveSolutionsMethodRpmSolvePostResponse> => {
	return customFetch<solveSolutionsMethodRpmSolvePostResponse>(
		getSolveSolutionsMethodRpmSolvePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(rPMSolveRequest)
		}
	);
};

/**
 * Solve the problem using the NIMBUS method.
 * @summary Solve Solutions
 */
export type solveSolutionsMethodNimbusSolvePostResponse200 = {
	data: NIMBUSClassificationResponse;
	status: 200;
};

export type solveSolutionsMethodNimbusSolvePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveSolutionsMethodNimbusSolvePostResponseSuccess =
	solveSolutionsMethodNimbusSolvePostResponse200 & {
		headers: Headers;
	};
export type solveSolutionsMethodNimbusSolvePostResponseError =
	solveSolutionsMethodNimbusSolvePostResponse422 & {
		headers: Headers;
	};

export type solveSolutionsMethodNimbusSolvePostResponse =
	| solveSolutionsMethodNimbusSolvePostResponseSuccess
	| solveSolutionsMethodNimbusSolvePostResponseError;

export const getSolveSolutionsMethodNimbusSolvePostUrl = () => {
	return `http://localhost:8000/method/nimbus/solve`;
};

export const solveSolutionsMethodNimbusSolvePost = async (
	nIMBUSClassificationRequest: NIMBUSClassificationRequest,
	options?: RequestInit
): Promise<solveSolutionsMethodNimbusSolvePostResponse> => {
	return customFetch<solveSolutionsMethodNimbusSolvePostResponse>(
		getSolveSolutionsMethodNimbusSolvePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSClassificationRequest)
		}
	);
};

/**
 * Initialize the problem for the NIMBUS method.
 * @summary Initialize
 */
export type initializeMethodNimbusInitializePostResponse200 = {
	data: NIMBUSInitializationResponse;
	status: 200;
};

export type initializeMethodNimbusInitializePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type initializeMethodNimbusInitializePostResponseSuccess =
	initializeMethodNimbusInitializePostResponse200 & {
		headers: Headers;
	};
export type initializeMethodNimbusInitializePostResponseError =
	initializeMethodNimbusInitializePostResponse422 & {
		headers: Headers;
	};

export type initializeMethodNimbusInitializePostResponse =
	| initializeMethodNimbusInitializePostResponseSuccess
	| initializeMethodNimbusInitializePostResponseError;

export const getInitializeMethodNimbusInitializePostUrl = () => {
	return `http://localhost:8000/method/nimbus/initialize`;
};

export const initializeMethodNimbusInitializePost = async (
	nIMBUSInitializationRequest: NIMBUSInitializationRequest,
	options?: RequestInit
): Promise<initializeMethodNimbusInitializePostResponse> => {
	return customFetch<initializeMethodNimbusInitializePostResponse>(
		getInitializeMethodNimbusInitializePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSInitializationRequest)
		}
	);
};

/**
 * Save solutions.
 * @summary Save
 */
export type saveMethodNimbusSavePostResponse200 = {
	data: NIMBUSSaveResponse;
	status: 200;
};

export type saveMethodNimbusSavePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type saveMethodNimbusSavePostResponseSuccess = saveMethodNimbusSavePostResponse200 & {
	headers: Headers;
};
export type saveMethodNimbusSavePostResponseError = saveMethodNimbusSavePostResponse422 & {
	headers: Headers;
};

export type saveMethodNimbusSavePostResponse =
	| saveMethodNimbusSavePostResponseSuccess
	| saveMethodNimbusSavePostResponseError;

export const getSaveMethodNimbusSavePostUrl = () => {
	return `http://localhost:8000/method/nimbus/save`;
};

export const saveMethodNimbusSavePost = async (
	nIMBUSSaveRequest: NIMBUSSaveRequest,
	options?: RequestInit
): Promise<saveMethodNimbusSavePostResponse> => {
	return customFetch<saveMethodNimbusSavePostResponse>(getSaveMethodNimbusSavePostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(nIMBUSSaveRequest)
	});
};

/**
 * Solve intermediate solutions by forwarding the request to generic intermediate endpoint with context nimbus.
 * @summary Solve Nimbus Intermediate
 */
export type solveNimbusIntermediateMethodNimbusIntermediatePostResponse200 = {
	data: NIMBUSIntermediateSolutionResponse;
	status: 200;
};

export type solveNimbusIntermediateMethodNimbusIntermediatePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveNimbusIntermediateMethodNimbusIntermediatePostResponseSuccess =
	solveNimbusIntermediateMethodNimbusIntermediatePostResponse200 & {
		headers: Headers;
	};
export type solveNimbusIntermediateMethodNimbusIntermediatePostResponseError =
	solveNimbusIntermediateMethodNimbusIntermediatePostResponse422 & {
		headers: Headers;
	};

export type solveNimbusIntermediateMethodNimbusIntermediatePostResponse =
	| solveNimbusIntermediateMethodNimbusIntermediatePostResponseSuccess
	| solveNimbusIntermediateMethodNimbusIntermediatePostResponseError;

export const getSolveNimbusIntermediateMethodNimbusIntermediatePostUrl = () => {
	return `http://localhost:8000/method/nimbus/intermediate`;
};

export const solveNimbusIntermediateMethodNimbusIntermediatePost = async (
	intermediateSolutionRequest: IntermediateSolutionRequest,
	options?: RequestInit
): Promise<solveNimbusIntermediateMethodNimbusIntermediatePostResponse> => {
	return customFetch<solveNimbusIntermediateMethodNimbusIntermediatePostResponse>(
		getSolveNimbusIntermediateMethodNimbusIntermediatePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(intermediateSolutionRequest)
		}
	);
};

/**
 * Get the latest NIMBUS state if it exists, or initialize a new one if it doesn't.
 * @summary Get Or Initialize
 */
export type getOrInitializeMethodNimbusGetOrInitializePostResponse200 = {
	data: GetOrInitializeMethodNimbusGetOrInitializePost200;
	status: 200;
};

export type getOrInitializeMethodNimbusGetOrInitializePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getOrInitializeMethodNimbusGetOrInitializePostResponseSuccess =
	getOrInitializeMethodNimbusGetOrInitializePostResponse200 & {
		headers: Headers;
	};
export type getOrInitializeMethodNimbusGetOrInitializePostResponseError =
	getOrInitializeMethodNimbusGetOrInitializePostResponse422 & {
		headers: Headers;
	};

export type getOrInitializeMethodNimbusGetOrInitializePostResponse =
	| getOrInitializeMethodNimbusGetOrInitializePostResponseSuccess
	| getOrInitializeMethodNimbusGetOrInitializePostResponseError;

export const getGetOrInitializeMethodNimbusGetOrInitializePostUrl = () => {
	return `http://localhost:8000/method/nimbus/get-or-initialize`;
};

export const getOrInitializeMethodNimbusGetOrInitializePost = async (
	nIMBUSInitializationRequest: NIMBUSInitializationRequest,
	options?: RequestInit
): Promise<getOrInitializeMethodNimbusGetOrInitializePostResponse> => {
	return customFetch<getOrInitializeMethodNimbusGetOrInitializePostResponse>(
		getGetOrInitializeMethodNimbusGetOrInitializePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(nIMBUSInitializationRequest)
		}
	);
};

/**
 * Solve intermediate solutions between given two solutions.
 * @summary Solve Intermediate
 */
export type solveIntermediateMethodGenericIntermediatePostResponse200 = {
	data: GenericIntermediateSolutionResponse;
	status: 200;
};

export type solveIntermediateMethodGenericIntermediatePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type solveIntermediateMethodGenericIntermediatePostResponseSuccess =
	solveIntermediateMethodGenericIntermediatePostResponse200 & {
		headers: Headers;
	};
export type solveIntermediateMethodGenericIntermediatePostResponseError =
	solveIntermediateMethodGenericIntermediatePostResponse422 & {
		headers: Headers;
	};

export type solveIntermediateMethodGenericIntermediatePostResponse =
	| solveIntermediateMethodGenericIntermediatePostResponseSuccess
	| solveIntermediateMethodGenericIntermediatePostResponseError;

export const getSolveIntermediateMethodGenericIntermediatePostUrl = () => {
	return `http://localhost:8000/method/generic/intermediate`;
};

export const solveIntermediateMethodGenericIntermediatePost = async (
	intermediateSolutionRequest: IntermediateSolutionRequest,
	options?: RequestInit
): Promise<solveIntermediateMethodGenericIntermediatePostResponse> => {
	return customFetch<solveIntermediateMethodGenericIntermediatePostResponse>(
		getSolveIntermediateMethodGenericIntermediatePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(intermediateSolutionRequest)
		}
	);
};

/**
 * Calculate SCORE bands parameters from objective data.
 * @summary Calculate Score Bands
 */
export type calculateScoreBandsMethodGenericScoreBandsPostResponse200 = {
	data: ScoreBandsResponse;
	status: 200;
};

export type calculateScoreBandsMethodGenericScoreBandsPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type calculateScoreBandsMethodGenericScoreBandsPostResponseSuccess =
	calculateScoreBandsMethodGenericScoreBandsPostResponse200 & {
		headers: Headers;
	};
export type calculateScoreBandsMethodGenericScoreBandsPostResponseError =
	calculateScoreBandsMethodGenericScoreBandsPostResponse422 & {
		headers: Headers;
	};

export type calculateScoreBandsMethodGenericScoreBandsPostResponse =
	| calculateScoreBandsMethodGenericScoreBandsPostResponseSuccess
	| calculateScoreBandsMethodGenericScoreBandsPostResponseError;

export const getCalculateScoreBandsMethodGenericScoreBandsPostUrl = () => {
	return `http://localhost:8000/method/generic/score-bands`;
};

export const calculateScoreBandsMethodGenericScoreBandsPost = async (
	scoreBandsRequest: ScoreBandsRequest,
	options?: RequestInit
): Promise<calculateScoreBandsMethodGenericScoreBandsPostResponse> => {
	return customFetch<calculateScoreBandsMethodGenericScoreBandsPostResponse>(
		getCalculateScoreBandsMethodGenericScoreBandsPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(scoreBandsRequest)
		}
	);
};

/**
 * Request and receive the Utopia map corresponding to the decision variables sent. Can be just the optimal_variables form a SolverResult.

Args:
    request (UtopiaRequest): the set of decision variables and problem for which the utopia forest map is requested for.
    user (Annotated[User, Depend(get_current_user)]) the current user
    session (Annotated[Session, Depends(get_session)]) the current database session
Raises:
    HTTPException:
Returns:
    UtopiaResponse: the map for the forest, to be rendered in frontend
 * @summary Get Utopia Data
 */
export type getUtopiaDataUtopiaPostResponse200 = {
	data: UtopiaResponse;
	status: 200;
};

export type getUtopiaDataUtopiaPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getUtopiaDataUtopiaPostResponseSuccess = getUtopiaDataUtopiaPostResponse200 & {
	headers: Headers;
};
export type getUtopiaDataUtopiaPostResponseError = getUtopiaDataUtopiaPostResponse422 & {
	headers: Headers;
};

export type getUtopiaDataUtopiaPostResponse =
	| getUtopiaDataUtopiaPostResponseSuccess
	| getUtopiaDataUtopiaPostResponseError;

export const getGetUtopiaDataUtopiaPostUrl = () => {
	return `http://localhost:8000/utopia/`;
};

export const getUtopiaDataUtopiaPost = async (
	utopiaRequest: UtopiaRequest,
	options?: RequestInit
): Promise<getUtopiaDataUtopiaPostResponse> => {
	return customFetch<getUtopiaDataUtopiaPostResponse>(getGetUtopiaDataUtopiaPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(utopiaRequest)
	});
};

/**
 * Initialize the problem for NIMBUS

Different initializations should be used for different methods
 * @summary Gnimbus Initialize
 */
export type gnimbusInitializeGnimbusInitializePostResponse200 = {
	data: unknown;
	status: 200;
};

export type gnimbusInitializeGnimbusInitializePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type gnimbusInitializeGnimbusInitializePostResponseSuccess =
	gnimbusInitializeGnimbusInitializePostResponse200 & {
		headers: Headers;
	};
export type gnimbusInitializeGnimbusInitializePostResponseError =
	gnimbusInitializeGnimbusInitializePostResponse422 & {
		headers: Headers;
	};

export type gnimbusInitializeGnimbusInitializePostResponse =
	| gnimbusInitializeGnimbusInitializePostResponseSuccess
	| gnimbusInitializeGnimbusInitializePostResponseError;

export const getGnimbusInitializeGnimbusInitializePostUrl = () => {
	return `http://localhost:8000/gnimbus/initialize`;
};

export const gnimbusInitializeGnimbusInitializePost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<gnimbusInitializeGnimbusInitializePostResponse> => {
	return customFetch<gnimbusInitializeGnimbusInitializePostResponse>(
		getGnimbusInitializeGnimbusInitializePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Get the latest results from group iteration
NOTE: This function is likely obsolete as full_iterations does what it does ans more.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): current user
    session (Annotated[Session, Depends(get_session)])

Returns:
    GNIMBUSResultResponse: A GNIMBUSResultResponse response containing the latest gnimbus results

Raises:
    HTTPException: Validation errors or no results
 * @summary Get Latest Results
 */
export type getLatestResultsGnimbusGetLatestResultsPostResponse200 = {
	data: GNIMBUSResultResponse;
	status: 200;
};

export type getLatestResultsGnimbusGetLatestResultsPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getLatestResultsGnimbusGetLatestResultsPostResponseSuccess =
	getLatestResultsGnimbusGetLatestResultsPostResponse200 & {
		headers: Headers;
	};
export type getLatestResultsGnimbusGetLatestResultsPostResponseError =
	getLatestResultsGnimbusGetLatestResultsPostResponse422 & {
		headers: Headers;
	};

export type getLatestResultsGnimbusGetLatestResultsPostResponse =
	| getLatestResultsGnimbusGetLatestResultsPostResponseSuccess
	| getLatestResultsGnimbusGetLatestResultsPostResponseError;

export const getGetLatestResultsGnimbusGetLatestResultsPostUrl = () => {
	return `http://localhost:8000/gnimbus/get_latest_results`;
};

export const getLatestResultsGnimbusGetLatestResultsPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<getLatestResultsGnimbusGetLatestResultsPostResponse> => {
	return customFetch<getLatestResultsGnimbusGetLatestResultsPostResponse>(
		getGetLatestResultsGnimbusGetLatestResultsPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Get all results from all iterations of the group.

Args:
    request (GroupInfoRequest): essentially just the ID of the group
    user (Annotated[User, Depends(get_current_user)]): current user
    session (Annotated[Session, Depends(get_session)])

Returns:
    GNIMBUSAllIterationsResponse: A GNIMBUSAllIterationsResponse response
    containing all the results of the iterations. If last iteration was optimization,
    the first iteration is incomplete (i.e. the voting preferences and voting results are missing)

Raises:
    HTTPException: Validation errors or no results or no states and such.
 * @summary Full Iteration
 */
export type fullIterationGnimbusAllIterationsPostResponse200 = {
	data: GNIMBUSAllIterationsResponse;
	status: 200;
};

export type fullIterationGnimbusAllIterationsPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type fullIterationGnimbusAllIterationsPostResponseSuccess =
	fullIterationGnimbusAllIterationsPostResponse200 & {
		headers: Headers;
	};
export type fullIterationGnimbusAllIterationsPostResponseError =
	fullIterationGnimbusAllIterationsPostResponse422 & {
		headers: Headers;
	};

export type fullIterationGnimbusAllIterationsPostResponse =
	| fullIterationGnimbusAllIterationsPostResponseSuccess
	| fullIterationGnimbusAllIterationsPostResponseError;

export const getFullIterationGnimbusAllIterationsPostUrl = () => {
	return `http://localhost:8000/gnimbus/all_iterations`;
};

export const fullIterationGnimbusAllIterationsPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<fullIterationGnimbusAllIterationsPostResponse> => {
	return customFetch<fullIterationGnimbusAllIterationsPostResponse>(
		getFullIterationGnimbusAllIterationsPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * Toggle the phase from learning to decision and vice versa
 * @summary Toggle Phase
 */
export type togglePhaseGnimbusTogglePhasePostResponse200 = {
	data: GNIMBUSSwitchPhaseResponse;
	status: 200;
};

export type togglePhaseGnimbusTogglePhasePostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type togglePhaseGnimbusTogglePhasePostResponseSuccess =
	togglePhaseGnimbusTogglePhasePostResponse200 & {
		headers: Headers;
	};
export type togglePhaseGnimbusTogglePhasePostResponseError =
	togglePhaseGnimbusTogglePhasePostResponse422 & {
		headers: Headers;
	};

export type togglePhaseGnimbusTogglePhasePostResponse =
	| togglePhaseGnimbusTogglePhasePostResponseSuccess
	| togglePhaseGnimbusTogglePhasePostResponseError;

export const getTogglePhaseGnimbusTogglePhasePostUrl = () => {
	return `http://localhost:8000/gnimbus/toggle_phase`;
};

export const togglePhaseGnimbusTogglePhasePost = async (
	gNIMBUSSwitchPhaseRequest: GNIMBUSSwitchPhaseRequest,
	options?: RequestInit
): Promise<togglePhaseGnimbusTogglePhasePostResponse> => {
	return customFetch<togglePhaseGnimbusTogglePhasePostResponse>(
		getTogglePhaseGnimbusTogglePhasePostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(gNIMBUSSwitchPhaseRequest)
		}
	);
};

/**
 * Create group.

Args:
    request (GroupCreateRequest): a request that holds information to be used in creation of the group.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledgement that the gourp was created

Raises:
    HTTPException
 * @summary Create Group
 */
export type createGroupGdmCreateGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type createGroupGdmCreateGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type createGroupGdmCreateGroupPostResponseSuccess =
	createGroupGdmCreateGroupPostResponse200 & {
		headers: Headers;
	};
export type createGroupGdmCreateGroupPostResponseError =
	createGroupGdmCreateGroupPostResponse422 & {
		headers: Headers;
	};

export type createGroupGdmCreateGroupPostResponse =
	| createGroupGdmCreateGroupPostResponseSuccess
	| createGroupGdmCreateGroupPostResponseError;

export const getCreateGroupGdmCreateGroupPostUrl = () => {
	return `http://localhost:8000/gdm/create_group`;
};

export const createGroupGdmCreateGroupPost = async (
	groupCreateRequest: GroupCreateRequest,
	options?: RequestInit
): Promise<createGroupGdmCreateGroupPostResponse> => {
	return customFetch<createGroupGdmCreateGroupPostResponse>(getCreateGroupGdmCreateGroupPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(groupCreateRequest)
	});
};

/**
 * Delete the group with given ID

Args:
    request (GroupInfoRequest): Contains the ID of the group to be deleted
    user (Annotated[User, Depends(get_current_user)]): The user (in this case must be owner for anything to happen)
    session (Annotated[Session, Depends(get_session)]): The database session

Returns:
    JSONResponse: Aknowledgement of the deletion

Raises:
    HTTPException: Insufficient authorization etc.
 * @summary Delete Group
 */
export type deleteGroupGdmDeleteGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type deleteGroupGdmDeleteGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type deleteGroupGdmDeleteGroupPostResponseSuccess =
	deleteGroupGdmDeleteGroupPostResponse200 & {
		headers: Headers;
	};
export type deleteGroupGdmDeleteGroupPostResponseError =
	deleteGroupGdmDeleteGroupPostResponse422 & {
		headers: Headers;
	};

export type deleteGroupGdmDeleteGroupPostResponse =
	| deleteGroupGdmDeleteGroupPostResponseSuccess
	| deleteGroupGdmDeleteGroupPostResponseError;

export const getDeleteGroupGdmDeleteGroupPostUrl = () => {
	return `http://localhost:8000/gdm/delete_group`;
};

export const deleteGroupGdmDeleteGroupPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<deleteGroupGdmDeleteGroupPostResponse> => {
	return customFetch<deleteGroupGdmDeleteGroupPostResponse>(getDeleteGroupGdmDeleteGroupPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(groupInfoRequest)
	});
};

/**
 * Add a user to a group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been added to the group

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Add To Group
 */
export type addToGroupGdmAddToGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type addToGroupGdmAddToGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type addToGroupGdmAddToGroupPostResponseSuccess = addToGroupGdmAddToGroupPostResponse200 & {
	headers: Headers;
};
export type addToGroupGdmAddToGroupPostResponseError = addToGroupGdmAddToGroupPostResponse422 & {
	headers: Headers;
};

export type addToGroupGdmAddToGroupPostResponse =
	| addToGroupGdmAddToGroupPostResponseSuccess
	| addToGroupGdmAddToGroupPostResponseError;

export const getAddToGroupGdmAddToGroupPostUrl = () => {
	return `http://localhost:8000/gdm/add_to_group`;
};

export const addToGroupGdmAddToGroupPost = async (
	groupModifyRequest: GroupModifyRequest,
	options?: RequestInit
): Promise<addToGroupGdmAddToGroupPostResponse> => {
	return customFetch<addToGroupGdmAddToGroupPostResponse>(getAddToGroupGdmAddToGroupPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(groupModifyRequest)
	});
};

/**
 * Remove user from group.

Args:
    request (GroupModifyRequest): Request object that has group and user IDs.
    user (Annotated[User, Depends(get_current_user)]): the current user.
    session (Annotated[Session, Depends(get_session)]): the database session.

Returns:
    JSONResponse: Aknowledge that user has been removed from the group.

Raises:
    HTTPException: Authorization issues, group or user not found.
 * @summary Remove From Group
 */
export type removeFromGroupGdmRemoveFromGroupPostResponse200 = {
	data: unknown;
	status: 200;
};

export type removeFromGroupGdmRemoveFromGroupPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type removeFromGroupGdmRemoveFromGroupPostResponseSuccess =
	removeFromGroupGdmRemoveFromGroupPostResponse200 & {
		headers: Headers;
	};
export type removeFromGroupGdmRemoveFromGroupPostResponseError =
	removeFromGroupGdmRemoveFromGroupPostResponse422 & {
		headers: Headers;
	};

export type removeFromGroupGdmRemoveFromGroupPostResponse =
	| removeFromGroupGdmRemoveFromGroupPostResponseSuccess
	| removeFromGroupGdmRemoveFromGroupPostResponseError;

export const getRemoveFromGroupGdmRemoveFromGroupPostUrl = () => {
	return `http://localhost:8000/gdm/remove_from_group`;
};

export const removeFromGroupGdmRemoveFromGroupPost = async (
	groupModifyRequest: GroupModifyRequest,
	options?: RequestInit
): Promise<removeFromGroupGdmRemoveFromGroupPostResponse> => {
	return customFetch<removeFromGroupGdmRemoveFromGroupPostResponse>(
		getRemoveFromGroupGdmRemoveFromGroupPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupModifyRequest)
		}
	);
};

/**
 * Get information about the group

Args:
    request (GroupInfoRequest): the id of the group for which we desire info on
    session (Annotated[Session, Depends(get_session)]): the database session

Returns:
    GroupPublic: public info of the group

Raises:
    HTTPException: If there's no group with the requests group id
 * @summary Get Group Info
 */
export type getGroupInfoGdmGetGroupInfoPostResponse200 = {
	data: GroupPublic;
	status: 200;
};

export type getGroupInfoGdmGetGroupInfoPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type getGroupInfoGdmGetGroupInfoPostResponseSuccess =
	getGroupInfoGdmGetGroupInfoPostResponse200 & {
		headers: Headers;
	};
export type getGroupInfoGdmGetGroupInfoPostResponseError =
	getGroupInfoGdmGetGroupInfoPostResponse422 & {
		headers: Headers;
	};

export type getGroupInfoGdmGetGroupInfoPostResponse =
	| getGroupInfoGdmGetGroupInfoPostResponseSuccess
	| getGroupInfoGdmGetGroupInfoPostResponseError;

export const getGetGroupInfoGdmGetGroupInfoPostUrl = () => {
	return `http://localhost:8000/gdm/get_group_info`;
};

export const getGroupInfoGdmGetGroupInfoPost = async (
	groupInfoRequest: GroupInfoRequest,
	options?: RequestInit
): Promise<getGroupInfoGdmGetGroupInfoPostResponse> => {
	return customFetch<getGroupInfoGdmGetGroupInfoPostResponse>(
		getGetGroupInfoGdmGetGroupInfoPostUrl(),
		{
			...options,
			method: 'POST',
			headers: { 'Content-Type': 'application/json', ...options?.headers },
			body: JSON.stringify(groupInfoRequest)
		}
	);
};

/**
 * .
 * @summary Step
 */
export type stepMethodEnautilusStepPostResponse200 = {
	data: ENautilusState;
	status: 200;
};

export type stepMethodEnautilusStepPostResponse422 = {
	data: HTTPValidationError;
	status: 422;
};

export type stepMethodEnautilusStepPostResponseSuccess = stepMethodEnautilusStepPostResponse200 & {
	headers: Headers;
};
export type stepMethodEnautilusStepPostResponseError = stepMethodEnautilusStepPostResponse422 & {
	headers: Headers;
};

export type stepMethodEnautilusStepPostResponse =
	| stepMethodEnautilusStepPostResponseSuccess
	| stepMethodEnautilusStepPostResponseError;

export const getStepMethodEnautilusStepPostUrl = () => {
	return `http://localhost:8000/method/enautilus/step`;
};

export const stepMethodEnautilusStepPost = async (
	enautilusStepRequest: EnautilusStepRequest,
	options?: RequestInit
): Promise<stepMethodEnautilusStepPostResponse> => {
	return customFetch<stepMethodEnautilusStepPostResponse>(getStepMethodEnautilusStepPostUrl(), {
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(enautilusStepRequest)
	});
};

export const getGetCurrentUserInfoUserInfoGetResponseMock = (
	overrideResponse: Partial<UserPublic> = {}
): UserPublic => ({
	username: faker.string.alpha({ length: { min: 10, max: 20 } }),
	id: faker.number.int({ min: undefined, max: undefined }),
	role: faker.helpers.arrayElement(Object.values(UserRole)),
	group_ids: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
			faker.number.int({ min: undefined, max: undefined })
		),
		null
	]),
	...overrideResponse
});

export const getLoginLoginPostResponseMock = (overrideResponse: Partial<Tokens> = {}): Tokens => ({
	access_token: faker.string.alpha({ length: { min: 10, max: 20 } }),
	refresh_token: faker.string.alpha({ length: { min: 10, max: 20 } }),
	token_type: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse
});

export const getGetProblemsProblemAllGetResponseMock = (): ProblemInfoSmall[] =>
	Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
		name: faker.string.alpha({ length: { min: 10, max: 20 } }),
		description: faker.string.alpha({ length: { min: 10, max: 20 } }),
		is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
		is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
		is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
		scenario_keys: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
				faker.string.alpha({ length: { min: 10, max: 20 } })
			),
			null
		]),
		variable_domain: faker.helpers.arrayElement(Object.values(VariableDomainTypeEnum)),
		id: faker.number.int({ min: undefined, max: undefined }),
		user_id: faker.number.int({ min: undefined, max: undefined }),
		problem_metadata: faker.helpers.arrayElement([
			{
				problem_id: faker.number.int({ min: undefined, max: undefined }),
				forest_metadata: faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => ({
							id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_type: faker.helpers.arrayElement([
								faker.string.alpha({ length: { min: 10, max: 20 } }),
								undefined
							]),
							map_json: faker.string.alpha({ length: { min: 10, max: 20 } }),
							schedule_dict: {},
							years: Array.from(
								{ length: faker.number.int({ min: 1, max: 10 }) },
								(_, i) => i + 1
							).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
							stand_id_field: faker.string.alpha({ length: { min: 10, max: 20 } }),
							stand_descriptor: faker.helpers.arrayElement([
								faker.helpers.arrayElement([null]),
								undefined
							]),
							compensation: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									null
								]),
								undefined
							])
						})
					),
					null
				]),
				representative_nd_metadata: faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => ({
							id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_type: faker.helpers.arrayElement([
								faker.string.alpha({ length: { min: 10, max: 20 } }),
								undefined
							]),
							name: faker.string.alpha({ length: { min: 10, max: 20 } }),
							description: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.string.alpha({ length: { min: 10, max: 20 } }),
									null
								]),
								undefined
							]),
							solution_data: {
								[faker.string.alphanumeric(5)]: Array.from(
									{ length: faker.number.int({ min: 1, max: 10 }) },
									(_, i) => i + 1
								).map(() =>
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })
								)
							},
							ideal: {
								[faker.string.alphanumeric(5)]: faker.number.float({
									min: undefined,
									max: undefined,
									fractionDigits: 2
								})
							},
							nadir: {
								[faker.string.alphanumeric(5)]: faker.number.float({
									min: undefined,
									max: undefined,
									fractionDigits: 2
								})
							}
						})
					),
					null
				])
			},
			null
		])
	}));

export const getGetProblemsInfoProblemAllInfoGetResponseMock = (): ProblemInfo[] =>
	Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
		name: faker.string.alpha({ length: { min: 10, max: 20 } }),
		description: faker.string.alpha({ length: { min: 10, max: 20 } }),
		is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
		is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
		is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
		scenario_keys: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
				faker.string.alpha({ length: { min: 10, max: 20 } })
			),
			null
		]),
		variable_domain: faker.helpers.arrayElement(Object.values(VariableDomainTypeEnum)),
		id: faker.number.int({ min: undefined, max: undefined }),
		user_id: faker.number.int({ min: undefined, max: undefined }),
		constants: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				value: faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		tensor_constants: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				values: faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				]),
				shape: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => faker.number.int({ min: undefined, max: undefined })
				),
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		variables: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				variable_type: faker.helpers.arrayElement(Object.values(VariableTypeEnum)),
				lowerbound: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						null
					]),
					undefined
				]),
				upperbound: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						null
					]),
					undefined
				]),
				initial_value: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						null
					]),
					undefined
				]),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		tensor_variables: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				initial_values: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					]),
					null
				]),
				lowerbounds: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					]),
					null
				]),
				upperbounds: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					]),
					null
				]),
				shape: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => faker.number.int({ min: undefined, max: undefined })
				),
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				variable_type: faker.helpers.arrayElement(Object.values(VariableTypeEnum)),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		objectives: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
			() => ({
				func: faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => ({})
					),
					null
				]),
				scenario_keys: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.string.alpha({ length: { min: 10, max: 20 } })
						),
						null
					]),
					undefined
				]),
				surrogates: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.string.alpha({ length: { min: 10, max: 20 } })
						),
						null
					]),
					undefined
				]),
				simulator_path: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						{
							url: faker.string.alpha({ length: { min: 10, max: 20 } }),
							auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
						},
						null
					]),
					undefined
				]),
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				unit: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
					undefined
				]),
				maximize: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				ideal: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						null
					]),
					undefined
				]),
				nadir: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						null
					]),
					undefined
				]),
				objective_type: faker.helpers.arrayElement([
					faker.helpers.arrayElement(Object.values(ObjectiveTypeEnum)),
					undefined
				]),
				is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})
		),
		constraints: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => ({})
				),
				scenario_keys: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.string.alpha({ length: { min: 10, max: 20 } })
						),
						null
					]),
					undefined
				]),
				surrogates: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.string.alpha({ length: { min: 10, max: 20 } })
						),
						null
					]),
					undefined
				]),
				simulator_path: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						{
							url: faker.string.alpha({ length: { min: 10, max: 20 } }),
							auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
						},
						null
					]),
					undefined
				]),
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				cons_type: faker.helpers.arrayElement(Object.values(ConstraintTypeEnum)),
				is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		scalarization_funcs: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => ({})
				),
				scenario_keys: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
					undefined
				]),
				is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		extra_funcs: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => ({})
				),
				scenario_keys: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.string.alpha({ length: { min: 10, max: 20 } })
						),
						null
					]),
					undefined
				]),
				surrogates: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.string.alpha({ length: { min: 10, max: 20 } })
						),
						null
					]),
					undefined
				]),
				simulator_path: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						{
							url: faker.string.alpha({ length: { min: 10, max: 20 } }),
							auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
						},
						null
					]),
					undefined
				]),
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		discrete_representation: faker.helpers.arrayElement([
			{
				non_dominated: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
				variable_values: {
					[faker.string.alphanumeric(5)]: Array.from(
						{ length: faker.number.int({ min: 1, max: 10 }) },
						(_, i) => i + 1
					).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					)
				},
				objective_values: {
					[faker.string.alphanumeric(5)]: Array.from(
						{ length: faker.number.int({ min: 1, max: 10 }) },
						(_, i) => i + 1
					).map(() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }))
				},
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			},
			null
		]),
		simulators: faker.helpers.arrayElement([
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
				file: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
					undefined
				]),
				url: faker.helpers.arrayElement([
					faker.helpers.arrayElement([
						{
							url: faker.string.alpha({ length: { min: 10, max: 20 } }),
							auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
						},
						null
					]),
					undefined
				]),
				parameter_options: faker.helpers.arrayElement([
					faker.helpers.arrayElement([null]),
					undefined
				]),
				name: faker.string.alpha({ length: { min: 10, max: 20 } }),
				symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			})),
			null
		]),
		problem_metadata: faker.helpers.arrayElement([
			{
				problem_id: faker.number.int({ min: undefined, max: undefined }),
				forest_metadata: faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => ({
							id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_type: faker.helpers.arrayElement([
								faker.string.alpha({ length: { min: 10, max: 20 } }),
								undefined
							]),
							map_json: faker.string.alpha({ length: { min: 10, max: 20 } }),
							schedule_dict: {},
							years: Array.from(
								{ length: faker.number.int({ min: 1, max: 10 }) },
								(_, i) => i + 1
							).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
							stand_id_field: faker.string.alpha({ length: { min: 10, max: 20 } }),
							stand_descriptor: faker.helpers.arrayElement([
								faker.helpers.arrayElement([null]),
								undefined
							]),
							compensation: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									null
								]),
								undefined
							])
						})
					),
					null
				]),
				representative_nd_metadata: faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => ({
							id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_id: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.number.int({ min: undefined, max: undefined }),
									null
								]),
								undefined
							]),
							metadata_type: faker.helpers.arrayElement([
								faker.string.alpha({ length: { min: 10, max: 20 } }),
								undefined
							]),
							name: faker.string.alpha({ length: { min: 10, max: 20 } }),
							description: faker.helpers.arrayElement([
								faker.helpers.arrayElement([
									faker.string.alpha({ length: { min: 10, max: 20 } }),
									null
								]),
								undefined
							]),
							solution_data: {
								[faker.string.alphanumeric(5)]: Array.from(
									{ length: faker.number.int({ min: 1, max: 10 }) },
									(_, i) => i + 1
								).map(() =>
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })
								)
							},
							ideal: {
								[faker.string.alphanumeric(5)]: faker.number.float({
									min: undefined,
									max: undefined,
									fractionDigits: 2
								})
							},
							nadir: {
								[faker.string.alphanumeric(5)]: faker.number.float({
									min: undefined,
									max: undefined,
									fractionDigits: 2
								})
							}
						})
					),
					null
				])
			},
			null
		])
	}));

export const getGetProblemProblemGetPostResponseMock = (
	overrideResponse: Partial<ProblemInfo> = {}
): ProblemInfo => ({
	name: faker.string.alpha({ length: { min: 10, max: 20 } }),
	description: faker.string.alpha({ length: { min: 10, max: 20 } }),
	is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
	is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
	is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
	scenario_keys: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
			faker.string.alpha({ length: { min: 10, max: 20 } })
		),
		null
	]),
	variable_domain: faker.helpers.arrayElement(Object.values(VariableDomainTypeEnum)),
	id: faker.number.int({ min: undefined, max: undefined }),
	user_id: faker.number.int({ min: undefined, max: undefined }),
	constants: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			value: faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	tensor_constants: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			values: faker.helpers.arrayElement([
				[],
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean()
					])
				),
				faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
				faker.number.int({ min: undefined, max: undefined }),
				faker.datatype.boolean(),
				'List',
				null
			]),
			shape: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => faker.number.int({ min: undefined, max: undefined })
			),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	variables: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			variable_type: faker.helpers.arrayElement(Object.values(VariableTypeEnum)),
			lowerbound: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			upperbound: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			initial_value: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	tensor_variables: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			initial_values: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				]),
				null
			]),
			lowerbounds: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				]),
				null
			]),
			upperbounds: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				]),
				null
			]),
			shape: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => faker.number.int({ min: undefined, max: undefined })
			),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			variable_type: faker.helpers.arrayElement(Object.values(VariableTypeEnum)),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	objectives: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => ({
			func: faker.helpers.arrayElement([
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => ({})
				),
				null
			]),
			scenario_keys: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			surrogates: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			simulator_path: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			unit: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			maximize: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			ideal: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			nadir: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			objective_type: faker.helpers.arrayElement([
				faker.helpers.arrayElement(Object.values(ObjectiveTypeEnum)),
				undefined
			]),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})
	),
	constraints: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => ({})
			),
			scenario_keys: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			surrogates: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			simulator_path: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			cons_type: faker.helpers.arrayElement(Object.values(ConstraintTypeEnum)),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	scalarization_funcs: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => ({})
			),
			scenario_keys: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	extra_funcs: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => ({})
			),
			scenario_keys: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			surrogates: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			simulator_path: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	discrete_representation: faker.helpers.arrayElement([
		{
			non_dominated: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			variable_values: {
				[faker.string.alphanumeric(5)]: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() =>
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean()
					])
				)
			},
			objective_values: {
				[faker.string.alphanumeric(5)]: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }))
			},
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		},
		null
	]),
	simulators: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			file: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			url: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			parameter_options: faker.helpers.arrayElement([
				faker.helpers.arrayElement([null]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	problem_metadata: faker.helpers.arrayElement([
		{
			problem_id: faker.number.int({ min: undefined, max: undefined }),
			forest_metadata: faker.helpers.arrayElement([
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_type: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						undefined
					]),
					map_json: faker.string.alpha({ length: { min: 10, max: 20 } }),
					schedule_dict: {},
					years: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					stand_id_field: faker.string.alpha({ length: { min: 10, max: 20 } }),
					stand_descriptor: faker.helpers.arrayElement([
						faker.helpers.arrayElement([null]),
						undefined
					]),
					compensation: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							null
						]),
						undefined
					])
				})),
				null
			]),
			representative_nd_metadata: faker.helpers.arrayElement([
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_type: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						undefined
					]),
					name: faker.string.alpha({ length: { min: 10, max: 20 } }),
					description: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.string.alpha({ length: { min: 10, max: 20 } }),
							null
						]),
						undefined
					]),
					solution_data: {
						[faker.string.alphanumeric(5)]: Array.from(
							{ length: faker.number.int({ min: 1, max: 10 }) },
							(_, i) => i + 1
						).map(() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }))
					},
					ideal: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					},
					nadir: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					}
				})),
				null
			])
		},
		null
	]),
	...overrideResponse
});

export const getAddProblemProblemAddPostResponseMock = (
	overrideResponse: Partial<ProblemInfo> = {}
): ProblemInfo => ({
	name: faker.string.alpha({ length: { min: 10, max: 20 } }),
	description: faker.string.alpha({ length: { min: 10, max: 20 } }),
	is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
	is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
	is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
	scenario_keys: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
			faker.string.alpha({ length: { min: 10, max: 20 } })
		),
		null
	]),
	variable_domain: faker.helpers.arrayElement(Object.values(VariableDomainTypeEnum)),
	id: faker.number.int({ min: undefined, max: undefined }),
	user_id: faker.number.int({ min: undefined, max: undefined }),
	constants: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			value: faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	tensor_constants: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			values: faker.helpers.arrayElement([
				[],
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean()
					])
				),
				faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
				faker.number.int({ min: undefined, max: undefined }),
				faker.datatype.boolean(),
				'List',
				null
			]),
			shape: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => faker.number.int({ min: undefined, max: undefined })
			),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	variables: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			variable_type: faker.helpers.arrayElement(Object.values(VariableTypeEnum)),
			lowerbound: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			upperbound: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			initial_value: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	tensor_variables: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			initial_values: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				]),
				null
			]),
			lowerbounds: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				]),
				null
			]),
			upperbounds: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				]),
				null
			]),
			shape: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => faker.number.int({ min: undefined, max: undefined })
			),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			variable_type: faker.helpers.arrayElement(Object.values(VariableTypeEnum)),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	objectives: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => ({
			func: faker.helpers.arrayElement([
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => ({})
				),
				null
			]),
			scenario_keys: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			surrogates: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			simulator_path: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			unit: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			maximize: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			ideal: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			nadir: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					null
				]),
				undefined
			]),
			objective_type: faker.helpers.arrayElement([
				faker.helpers.arrayElement(Object.values(ObjectiveTypeEnum)),
				undefined
			]),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})
	),
	constraints: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => ({})
			),
			scenario_keys: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			surrogates: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			simulator_path: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			cons_type: faker.helpers.arrayElement(Object.values(ConstraintTypeEnum)),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	scalarization_funcs: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => ({})
			),
			scenario_keys: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	extra_funcs: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			func: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
				() => ({})
			),
			scenario_keys: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			surrogates: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					null
				]),
				undefined
			]),
			simulator_path: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			is_linear: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_convex: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			is_twice_differentiable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	discrete_representation: faker.helpers.arrayElement([
		{
			non_dominated: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
			variable_values: {
				[faker.string.alphanumeric(5)]: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() =>
					faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean()
					])
				)
			},
			objective_values: {
				[faker.string.alphanumeric(5)]: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }))
			},
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		},
		null
	]),
	simulators: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
			file: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			url: faker.helpers.arrayElement([
				faker.helpers.arrayElement([
					{
						url: faker.string.alpha({ length: { min: 10, max: 20 } }),
						auth: faker.helpers.arrayElement([faker.helpers.arrayElement([[], null]), undefined])
					},
					null
				]),
				undefined
			]),
			parameter_options: faker.helpers.arrayElement([
				faker.helpers.arrayElement([null]),
				undefined
			]),
			name: faker.string.alpha({ length: { min: 10, max: 20 } }),
			symbol: faker.string.alpha({ length: { min: 10, max: 20 } }),
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		})),
		null
	]),
	problem_metadata: faker.helpers.arrayElement([
		{
			problem_id: faker.number.int({ min: undefined, max: undefined }),
			forest_metadata: faker.helpers.arrayElement([
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_type: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						undefined
					]),
					map_json: faker.string.alpha({ length: { min: 10, max: 20 } }),
					schedule_dict: {},
					years: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					stand_id_field: faker.string.alpha({ length: { min: 10, max: 20 } }),
					stand_descriptor: faker.helpers.arrayElement([
						faker.helpers.arrayElement([null]),
						undefined
					]),
					compensation: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							null
						]),
						undefined
					])
				})),
				null
			]),
			representative_nd_metadata: faker.helpers.arrayElement([
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_type: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						undefined
					]),
					name: faker.string.alpha({ length: { min: 10, max: 20 } }),
					description: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.string.alpha({ length: { min: 10, max: 20 } }),
							null
						]),
						undefined
					]),
					solution_data: {
						[faker.string.alphanumeric(5)]: Array.from(
							{ length: faker.number.int({ min: 1, max: 10 }) },
							(_, i) => i + 1
						).map(() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }))
					},
					ideal: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					},
					nadir: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					}
				})),
				null
			])
		},
		null
	]),
	...overrideResponse
});

export const getGetMetadataProblemGetMetadataPostResponseMock =
	(): GetMetadataProblemGetMetadataPost200Item[] =>
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
			faker.helpers.arrayElement([
				{
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_type: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						undefined
					]),
					map_json: faker.string.alpha({ length: { min: 10, max: 20 } }),
					schedule_dict: {},
					years: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
						() => faker.string.alpha({ length: { min: 10, max: 20 } })
					),
					stand_id_field: faker.string.alpha({ length: { min: 10, max: 20 } }),
					stand_descriptor: faker.helpers.arrayElement([
						faker.helpers.arrayElement([null]),
						undefined
					]),
					compensation: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							null
						]),
						undefined
					])
				},
				{
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_type: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						undefined
					]),
					name: faker.string.alpha({ length: { min: 10, max: 20 } }),
					description: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.string.alpha({ length: { min: 10, max: 20 } }),
							null
						]),
						undefined
					]),
					solution_data: {
						[faker.string.alphanumeric(5)]: Array.from(
							{ length: faker.number.int({ min: 1, max: 10 }) },
							(_, i) => i + 1
						).map(() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }))
					},
					ideal: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					},
					nadir: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					}
				},
				{
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					metadata_type: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						undefined
					]),
					solver_string_representation: faker.string.alpha({ length: { min: 10, max: 20 } })
				}
			])
		);

export const getCreateNewSessionSessionNewPostResponseMock = (
	overrideResponse: Partial<InteractiveSessionBase> = {}
): InteractiveSessionBase => ({
	id: faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
	user_id: faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
	info: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
	...overrideResponse
});

export const getGetSessionSessionGetPostResponseMock = (
	overrideResponse: Partial<InteractiveSessionBase> = {}
): InteractiveSessionBase => ({
	id: faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
	user_id: faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
	info: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
	...overrideResponse
});

export const getSolveSolutionsMethodRpmSolvePostResponseMock = (
	overrideResponse: Partial<RPMState> = {}
): RPMState => ({
	id: faker.helpers.arrayElement([
		faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
		undefined
	]),
	preferences: {
		preference_type: faker.helpers.arrayElement(['reference_point', undefined]),
		aspiration_levels: {
			[faker.string.alphanumeric(5)]: faker.number.float({
				min: undefined,
				max: undefined,
				fractionDigits: 2
			})
		}
	},
	scalarization_options: faker.helpers.arrayElement([
		faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					faker.datatype.boolean()
				])
			},
			null
		]),
		undefined
	]),
	solver: faker.helpers.arrayElement([
		faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		undefined
	]),
	solver_options: faker.helpers.arrayElement([
		faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					faker.datatype.boolean()
				])
			},
			null
		]),
		undefined
	]),
	solver_results: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		optimal_variables: {
			[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
				faker.number.int({ min: undefined, max: undefined }),
				faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
					() => ({})
				)
			])
		},
		optimal_objectives: {
			[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
				faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
				Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })
				)
			])
		},
		constraint_values: faker.helpers.arrayElement([
			faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })
						),
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
							() => ({})
						)
					])
				},
				null
			]),
			undefined
		]),
		extra_func_values: faker.helpers.arrayElement([
			faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })
						)
					])
				},
				null
			]),
			undefined
		]),
		scalarization_values: faker.helpers.arrayElement([
			faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })
						)
					])
				},
				null
			]),
			undefined
		]),
		success: faker.datatype.boolean(),
		message: faker.string.alpha({ length: { min: 10, max: 20 } })
	})),
	...overrideResponse
});

export const getSolveSolutionsMethodNimbusSolvePostResponseMock = (
	overrideResponse: Partial<NIMBUSClassificationResponse> = {}
): NIMBUSClassificationResponse => ({
	state_id: faker.helpers.arrayElement([
		faker.number.int({ min: undefined, max: undefined }),
		null
	]),
	previous_preference: {
		preference_type: faker.helpers.arrayElement(['reference_point', undefined]),
		aspiration_levels: {
			[faker.string.alphanumeric(5)]: faker.number.float({
				min: undefined,
				max: undefined,
				fractionDigits: 2
			})
		}
	},
	previous_objectives: {
		[faker.string.alphanumeric(5)]: faker.number.float({
			min: undefined,
			max: undefined,
			fractionDigits: 2
		})
	},
	current_solutions: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	})),
	saved_solutions: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	})),
	all_solutions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => ({
			name: faker.helpers.arrayElement([
				faker.string.alpha({ length: { min: 10, max: 20 } }),
				null
			]),
			solution_index: faker.helpers.arrayElement([
				faker.number.int({ min: undefined, max: undefined }),
				null
			]),
			state_id: faker.number.int({ min: undefined, max: undefined }),
			objective_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				null
			]),
			variable_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						faker.helpers.arrayElement([
							[],
							Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
								() =>
									faker.helpers.arrayElement([
										faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
										faker.number.int({ min: undefined, max: undefined }),
										faker.datatype.boolean()
									])
							),
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean(),
							'List',
							null
						])
					])
				},
				null
			])
		})
	),
	...overrideResponse
});

export const getInitializeMethodNimbusInitializePostResponseMock = (
	overrideResponse: Partial<NIMBUSInitializationResponse> = {}
): NIMBUSInitializationResponse => ({
	state_id: faker.helpers.arrayElement([
		faker.number.int({ min: undefined, max: undefined }),
		null
	]),
	current_solutions: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	})),
	saved_solutions: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	})),
	all_solutions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => ({
			name: faker.helpers.arrayElement([
				faker.string.alpha({ length: { min: 10, max: 20 } }),
				null
			]),
			solution_index: faker.helpers.arrayElement([
				faker.number.int({ min: undefined, max: undefined }),
				null
			]),
			state_id: faker.number.int({ min: undefined, max: undefined }),
			objective_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				null
			]),
			variable_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						faker.helpers.arrayElement([
							[],
							Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
								() =>
									faker.helpers.arrayElement([
										faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
										faker.number.int({ min: undefined, max: undefined }),
										faker.datatype.boolean()
									])
							),
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean(),
							'List',
							null
						])
					])
				},
				null
			])
		})
	),
	...overrideResponse
});

export const getSaveMethodNimbusSavePostResponseMock = (
	overrideResponse: Partial<NIMBUSSaveResponse> = {}
): NIMBUSSaveResponse => ({
	state_id: faker.helpers.arrayElement([
		faker.number.int({ min: undefined, max: undefined }),
		null
	]),
	...overrideResponse
});

export const getSolveNimbusIntermediateMethodNimbusIntermediatePostResponseMock = (
	overrideResponse: Partial<NIMBUSIntermediateSolutionResponse> = {}
): NIMBUSIntermediateSolutionResponse => ({
	state_id: faker.helpers.arrayElement([
		faker.number.int({ min: undefined, max: undefined }),
		null
	]),
	reference_solution_1: {
		[faker.string.alphanumeric(5)]: faker.number.float({
			min: undefined,
			max: undefined,
			fractionDigits: 2
		})
	},
	reference_solution_2: {
		[faker.string.alphanumeric(5)]: faker.number.float({
			min: undefined,
			max: undefined,
			fractionDigits: 2
		})
	},
	current_solutions: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	})),
	saved_solutions: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	})),
	all_solutions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => ({
			name: faker.helpers.arrayElement([
				faker.string.alpha({ length: { min: 10, max: 20 } }),
				null
			]),
			solution_index: faker.helpers.arrayElement([
				faker.number.int({ min: undefined, max: undefined }),
				null
			]),
			state_id: faker.number.int({ min: undefined, max: undefined }),
			objective_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				null
			]),
			variable_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						faker.helpers.arrayElement([
							[],
							Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
								() =>
									faker.helpers.arrayElement([
										faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
										faker.number.int({ min: undefined, max: undefined }),
										faker.datatype.boolean()
									])
							),
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean(),
							'List',
							null
						])
					])
				},
				null
			])
		})
	),
	...overrideResponse
});

export const getGetOrInitializeMethodNimbusGetOrInitializePostResponseMock =
	(): GetOrInitializeMethodNimbusGetOrInitializePost200 =>
		faker.helpers.arrayElement([
			{
				state_id: faker.helpers.arrayElement([
					faker.number.int({ min: undefined, max: undefined }),
					null
				]),
				current_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				})),
				saved_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				})),
				all_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				}))
			},
			{
				state_id: faker.helpers.arrayElement([
					faker.number.int({ min: undefined, max: undefined }),
					null
				]),
				previous_preference: {
					preference_type: faker.helpers.arrayElement(['reference_point', undefined]),
					aspiration_levels: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					}
				},
				previous_objectives: {
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				current_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				})),
				saved_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				})),
				all_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				}))
			},
			{
				state_id: faker.helpers.arrayElement([
					faker.number.int({ min: undefined, max: undefined }),
					null
				]),
				reference_solution_1: {
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				reference_solution_2: {
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				current_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				})),
				saved_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				})),
				all_solutions: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					name: faker.helpers.arrayElement([
						faker.string.alpha({ length: { min: 10, max: 20 } }),
						null
					]),
					solution_index: faker.helpers.arrayElement([
						faker.number.int({ min: undefined, max: undefined }),
						null
					]),
					state_id: faker.number.int({ min: undefined, max: undefined }),
					objective_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						},
						null
					]),
					variable_values: faker.helpers.arrayElement([
						{
							[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean(),
								faker.helpers.arrayElement([
									[],
									Array.from(
										{ length: faker.number.int({ min: 1, max: 10 }) },
										(_, i) => i + 1
									).map(() =>
										faker.helpers.arrayElement([
											faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
											faker.number.int({ min: undefined, max: undefined }),
											faker.datatype.boolean()
										])
									),
									faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
									faker.number.int({ min: undefined, max: undefined }),
									faker.datatype.boolean(),
									'List',
									null
								])
							])
						},
						null
					])
				}))
			}
		]);

export const getSolveIntermediateMethodGenericIntermediatePostResponseMock = (
	overrideResponse: Partial<GenericIntermediateSolutionResponse> = {}
): GenericIntermediateSolutionResponse => ({
	state_id: faker.helpers.arrayElement([
		faker.number.int({ min: undefined, max: undefined }),
		null
	]),
	reference_solution_1: {
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	},
	reference_solution_2: {
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	},
	intermediate_solutions: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
		solution_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			},
			null
		])
	})),
	...overrideResponse
});

export const getCalculateScoreBandsMethodGenericScoreBandsPostResponseMock = (
	overrideResponse: Partial<ScoreBandsResponse> = {}
): ScoreBandsResponse => ({
	groups: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
		faker.number.int({ min: undefined, max: undefined })
	),
	axis_dist: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })
	),
	axis_signs: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
			faker.number.int({ min: undefined, max: undefined })
		),
		null
	]),
	obj_order: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => faker.number.int({ min: undefined, max: undefined })
	),
	...overrideResponse
});

export const getGetUtopiaDataUtopiaPostResponseMock = (
	overrideResponse: Partial<UtopiaResponse> = {}
): UtopiaResponse => ({
	is_utopia: faker.datatype.boolean(),
	map_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
	map_json: {},
	options: {},
	description: faker.string.alpha({ length: { min: 10, max: 20 } }),
	years: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
		faker.string.alpha({ length: { min: 10, max: 20 } })
	),
	...overrideResponse
});

export const getGetLatestResultsGnimbusGetLatestResultsPostResponseMock = (
	overrideResponse: Partial<GNIMBUSResultResponse> = {}
): GNIMBUSResultResponse => ({
	method: faker.string.alpha({ length: { min: 10, max: 20 } }),
	phase: faker.string.alpha({ length: { min: 10, max: 20 } }),
	preferences: faker.helpers.arrayElement([
		{
			method: faker.helpers.arrayElement([
				faker.string.alpha({ length: { min: 10, max: 20 } }),
				undefined
			]),
			set_preferences: {
				[faker.string.alphanumeric(5)]: faker.number.int({ min: undefined, max: undefined })
			}
		},
		{
			method: faker.helpers.arrayElement([
				faker.string.alpha({ length: { min: 10, max: 20 } }),
				undefined
			]),
			phase: faker.helpers.arrayElement([
				faker.string.alpha({ length: { min: 10, max: 20 } }),
				undefined
			]),
			set_preferences: {
				[faker.string.alphanumeric(5)]: {
					preference_type: faker.helpers.arrayElement(['reference_point', undefined]),
					aspiration_levels: {
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					}
				}
			}
		}
	]),
	common_results: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		name: faker.helpers.arrayElement([
			faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
			undefined
		]),
		solution_index: faker.helpers.arrayElement([
			faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
			undefined
		]),
		state: {
			id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			problem_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			session_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			parent_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			state_id: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			])
		},
		objective_values_all: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => ({
			[faker.string.alphanumeric(5)]: faker.number.float({
				min: undefined,
				max: undefined,
				fractionDigits: 2
			})
		})),
		variable_values_all: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => ({
			[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
				faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
				faker.number.int({ min: undefined, max: undefined }),
				faker.datatype.boolean(),
				faker.helpers.arrayElement([
					[],
					Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
						faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					),
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					'List',
					null
				])
			])
		})),
		objective_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		variable_values: faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean()
				])
			},
			null
		]),
		state_id: faker.number.int({ min: undefined, max: undefined }),
		num_solutions: faker.number.int({ min: undefined, max: undefined })
	})),
	user_results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
		() => ({
			name: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			solution_index: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			state: {
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				session_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				parent_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				state_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			},
			objective_values_all: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => ({
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			})),
			variable_values_all: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => ({
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			})),
			objective_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				null
			]),
			variable_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean()
					])
				},
				null
			]),
			state_id: faker.number.int({ min: undefined, max: undefined }),
			num_solutions: faker.number.int({ min: undefined, max: undefined })
		})
	),
	personal_result_index: faker.helpers.arrayElement([
		faker.number.int({ min: undefined, max: undefined }),
		null
	]),
	...overrideResponse
});

export const getFullIterationGnimbusAllIterationsPostResponseMock = (
	overrideResponse: Partial<GNIMBUSAllIterationsResponse> = {}
): GNIMBUSAllIterationsResponse => ({
	all_full_iterations: Array.from(
		{ length: faker.number.int({ min: 1, max: 10 }) },
		(_, i) => i + 1
	).map(() => ({
		phase: faker.string.alpha({ length: { min: 10, max: 20 } }),
		optimization_preferences: faker.helpers.arrayElement([
			{
				method: faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					undefined
				]),
				phase: faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					undefined
				]),
				set_preferences: {
					[faker.string.alphanumeric(5)]: {
						preference_type: faker.helpers.arrayElement(['reference_point', undefined]),
						aspiration_levels: {
							[faker.string.alphanumeric(5)]: faker.number.float({
								min: undefined,
								max: undefined,
								fractionDigits: 2
							})
						}
					}
				}
			},
			null
		]),
		voting_preferences: faker.helpers.arrayElement([
			{
				method: faker.helpers.arrayElement([
					faker.string.alpha({ length: { min: 10, max: 20 } }),
					undefined
				]),
				set_preferences: {
					[faker.string.alphanumeric(5)]: faker.number.int({ min: undefined, max: undefined })
				}
			},
			null
		]),
		starting_result: faker.helpers.arrayElement([
			{
				name: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
					undefined
				]),
				solution_index: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				state: {
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					problem_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					session_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					parent_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					state_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					])
				},
				objective_values_all: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				})),
				variable_values_all: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						faker.helpers.arrayElement([
							[],
							Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
								() =>
									faker.helpers.arrayElement([
										faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
										faker.number.int({ min: undefined, max: undefined }),
										faker.datatype.boolean()
									])
							),
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean(),
							'List',
							null
						])
					])
				})),
				objective_values: faker.helpers.arrayElement([
					{
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					},
					null
				]),
				variable_values: faker.helpers.arrayElement([
					{
						[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					},
					null
				]),
				state_id: faker.number.int({ min: undefined, max: undefined }),
				num_solutions: faker.number.int({ min: undefined, max: undefined })
			},
			null
		]),
		common_results: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => ({
			name: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			solution_index: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			state: {
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				session_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				parent_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				state_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			},
			objective_values_all: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => ({
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			})),
			variable_values_all: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => ({
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			})),
			objective_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				null
			]),
			variable_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean()
					])
				},
				null
			]),
			state_id: faker.number.int({ min: undefined, max: undefined }),
			num_solutions: faker.number.int({ min: undefined, max: undefined })
		})),
		user_results: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => ({
			name: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
				undefined
			]),
			solution_index: faker.helpers.arrayElement([
				faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
				undefined
			]),
			state: {
				id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				problem_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				session_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				parent_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				state_id: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				])
			},
			objective_values_all: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => ({
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			})),
			variable_values_all: Array.from(
				{ length: faker.number.int({ min: 1, max: 10 }) },
				(_, i) => i + 1
			).map(() => ({
				[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
					faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
					faker.number.int({ min: undefined, max: undefined }),
					faker.datatype.boolean(),
					faker.helpers.arrayElement([
						[],
						Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
							faker.helpers.arrayElement([
								faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
								faker.number.int({ min: undefined, max: undefined }),
								faker.datatype.boolean()
							])
						),
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						'List',
						null
					])
				])
			})),
			objective_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				},
				null
			]),
			variable_values: faker.helpers.arrayElement([
				{
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean()
					])
				},
				null
			]),
			state_id: faker.number.int({ min: undefined, max: undefined }),
			num_solutions: faker.number.int({ min: undefined, max: undefined })
		})),
		personal_result_index: faker.helpers.arrayElement([
			faker.number.int({ min: undefined, max: undefined }),
			null
		]),
		final_result: faker.helpers.arrayElement([
			{
				name: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
					undefined
				]),
				solution_index: faker.helpers.arrayElement([
					faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
					undefined
				]),
				state: {
					id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					problem_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					session_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					parent_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					]),
					state_id: faker.helpers.arrayElement([
						faker.helpers.arrayElement([
							faker.number.int({ min: undefined, max: undefined }),
							null
						]),
						undefined
					])
				},
				objective_values_all: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					[faker.string.alphanumeric(5)]: faker.number.float({
						min: undefined,
						max: undefined,
						fractionDigits: 2
					})
				})),
				variable_values_all: Array.from(
					{ length: faker.number.int({ min: 1, max: 10 }) },
					(_, i) => i + 1
				).map(() => ({
					[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
						faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
						faker.number.int({ min: undefined, max: undefined }),
						faker.datatype.boolean(),
						faker.helpers.arrayElement([
							[],
							Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
								() =>
									faker.helpers.arrayElement([
										faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
										faker.number.int({ min: undefined, max: undefined }),
										faker.datatype.boolean()
									])
							),
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean(),
							'List',
							null
						])
					])
				})),
				objective_values: faker.helpers.arrayElement([
					{
						[faker.string.alphanumeric(5)]: faker.number.float({
							min: undefined,
							max: undefined,
							fractionDigits: 2
						})
					},
					null
				]),
				variable_values: faker.helpers.arrayElement([
					{
						[faker.string.alphanumeric(5)]: faker.helpers.arrayElement([
							faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
							faker.number.int({ min: undefined, max: undefined }),
							faker.datatype.boolean()
						])
					},
					null
				]),
				state_id: faker.number.int({ min: undefined, max: undefined }),
				num_solutions: faker.number.int({ min: undefined, max: undefined })
			},
			null
		])
	})),
	...overrideResponse
});

export const getTogglePhaseGnimbusTogglePhasePostResponseMock = (
	overrideResponse: Partial<GNIMBUSSwitchPhaseResponse> = {}
): GNIMBUSSwitchPhaseResponse => ({
	old_phase: faker.string.alpha({ length: { min: 10, max: 20 } }),
	new_phase: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse
});

export const getGetGroupInfoGdmGetGroupInfoPostResponseMock = (
	overrideResponse: Partial<GroupPublic> = {}
): GroupPublic => ({
	id: faker.number.int({ min: undefined, max: undefined }),
	name: faker.string.alpha({ length: { min: 10, max: 20 } }),
	owner_id: faker.number.int({ min: undefined, max: undefined }),
	user_ids: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
		faker.number.int({ min: undefined, max: undefined })
	),
	problem_id: faker.number.int({ min: undefined, max: undefined }),
	...overrideResponse
});

export const getStepMethodEnautilusStepPostResponseMock = (
	overrideResponse: Partial<ENautilusState> = {}
): ENautilusState => ({
	id: faker.helpers.arrayElement([
		faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
		undefined
	]),
	non_dominated_solutions_id: faker.helpers.arrayElement([
		faker.helpers.arrayElement([faker.number.int({ min: undefined, max: undefined }), null]),
		undefined
	]),
	current_iteration: faker.number.int({ min: undefined, max: undefined }),
	iterations_left: faker.number.int({ min: undefined, max: undefined }),
	selected_point: faker.helpers.arrayElement([
		faker.helpers.arrayElement([
			{
				[faker.string.alphanumeric(5)]: faker.number.float({
					min: undefined,
					max: undefined,
					fractionDigits: 2
				})
			},
			null
		]),
		undefined
	]),
	reachable_point_indices: faker.helpers.arrayElement([
		Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
			faker.number.int({ min: undefined, max: undefined })
		),
		undefined
	]),
	number_of_intermediate_points: faker.number.int({ min: undefined, max: undefined }),
	enautilus_results: {
		current_iteration: faker.number.int({ min: undefined, max: undefined }),
		iterations_left: faker.number.int({ min: undefined, max: undefined }),
		intermediate_points: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => ({
			[faker.string.alphanumeric(5)]: faker.number.float({
				min: undefined,
				max: undefined,
				fractionDigits: 2
			})
		})),
		reachable_best_bounds: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => ({
			[faker.string.alphanumeric(5)]: faker.number.float({
				min: undefined,
				max: undefined,
				fractionDigits: 2
			})
		})),
		reachable_worst_bounds: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => ({
			[faker.string.alphanumeric(5)]: faker.number.float({
				min: undefined,
				max: undefined,
				fractionDigits: 2
			})
		})),
		closeness_measures: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() => faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 })),
		reachable_point_indices: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1
		).map(() =>
			Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
				faker.number.int({ min: undefined, max: undefined })
			)
		)
	},
	...overrideResponse
});

export const getGetCurrentUserInfoUserInfoGetMockHandler = (
	overrideResponse?:
		| UserPublic
		| ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserPublic> | UserPublic),
	options?: RequestHandlerOptions
) => {
	return http.get(
		'*/user_info',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetCurrentUserInfoUserInfoGetResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getLoginLoginPostMockHandler = (
	overrideResponse?:
		| Tokens
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Tokens> | Tokens),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/login',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getLoginLoginPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getLogoutLogoutPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/logout',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getRefreshAccessTokenRefreshPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/refresh',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getAddNewDmAddNewDmPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/add_new_dm',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getAddNewAnalystAddNewAnalystPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/add_new_analyst',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getGetProblemsProblemAllGetMockHandler = (
	overrideResponse?:
		| ProblemInfoSmall[]
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0]
		  ) => Promise<ProblemInfoSmall[]> | ProblemInfoSmall[]),
	options?: RequestHandlerOptions
) => {
	return http.get(
		'*/problem/all',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetProblemsProblemAllGetResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getGetProblemsInfoProblemAllInfoGetMockHandler = (
	overrideResponse?:
		| ProblemInfo[]
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0]
		  ) => Promise<ProblemInfo[]> | ProblemInfo[]),
	options?: RequestHandlerOptions
) => {
	return http.get(
		'*/problem/all_info',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetProblemsInfoProblemAllInfoGetResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getGetProblemProblemGetPostMockHandler = (
	overrideResponse?:
		| ProblemInfo
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<ProblemInfo> | ProblemInfo),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/problem/get',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetProblemProblemGetPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getAddProblemProblemAddPostMockHandler = (
	overrideResponse?:
		| ProblemInfo
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<ProblemInfo> | ProblemInfo),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/problem/add',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getAddProblemProblemAddPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getGetMetadataProblemGetMetadataPostMockHandler = (
	overrideResponse?:
		| GetMetadataProblemGetMetadataPost200Item[]
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) =>
				| Promise<GetMetadataProblemGetMetadataPost200Item[]>
				| GetMetadataProblemGetMetadataPost200Item[]),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/problem/get_metadata',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetMetadataProblemGetMetadataPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getSelectSolverProblemAssignSolverPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/problem/assign_solver',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getCreateNewSessionSessionNewPostMockHandler = (
	overrideResponse?:
		| InteractiveSessionBase
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<InteractiveSessionBase> | InteractiveSessionBase),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/session/new',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getCreateNewSessionSessionNewPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getGetSessionSessionGetPostMockHandler = (
	overrideResponse?:
		| InteractiveSessionBase
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<InteractiveSessionBase> | InteractiveSessionBase),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/session/get',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetSessionSessionGetPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getSolveSolutionsMethodRpmSolvePostMockHandler = (
	overrideResponse?:
		| RPMState
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<RPMState> | RPMState),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/rpm/solve',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getSolveSolutionsMethodRpmSolvePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getSolveSolutionsMethodNimbusSolvePostMockHandler = (
	overrideResponse?:
		| NIMBUSClassificationResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<NIMBUSClassificationResponse> | NIMBUSClassificationResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/nimbus/solve',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getSolveSolutionsMethodNimbusSolvePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getInitializeMethodNimbusInitializePostMockHandler = (
	overrideResponse?:
		| NIMBUSInitializationResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<NIMBUSInitializationResponse> | NIMBUSInitializationResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/nimbus/initialize',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getInitializeMethodNimbusInitializePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getSaveMethodNimbusSavePostMockHandler = (
	overrideResponse?:
		| NIMBUSSaveResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<NIMBUSSaveResponse> | NIMBUSSaveResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/nimbus/save',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getSaveMethodNimbusSavePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getSolveNimbusIntermediateMethodNimbusIntermediatePostMockHandler = (
	overrideResponse?:
		| NIMBUSIntermediateSolutionResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<NIMBUSIntermediateSolutionResponse> | NIMBUSIntermediateSolutionResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/nimbus/intermediate',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getSolveNimbusIntermediateMethodNimbusIntermediatePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getGetOrInitializeMethodNimbusGetOrInitializePostMockHandler = (
	overrideResponse?:
		| GetOrInitializeMethodNimbusGetOrInitializePost200
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) =>
				| Promise<GetOrInitializeMethodNimbusGetOrInitializePost200>
				| GetOrInitializeMethodNimbusGetOrInitializePost200),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/nimbus/get-or-initialize',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetOrInitializeMethodNimbusGetOrInitializePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getSolveIntermediateMethodGenericIntermediatePostMockHandler = (
	overrideResponse?:
		| GenericIntermediateSolutionResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<GenericIntermediateSolutionResponse> | GenericIntermediateSolutionResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/generic/intermediate',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getSolveIntermediateMethodGenericIntermediatePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getCalculateScoreBandsMethodGenericScoreBandsPostMockHandler = (
	overrideResponse?:
		| ScoreBandsResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<ScoreBandsResponse> | ScoreBandsResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/generic/score-bands',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getCalculateScoreBandsMethodGenericScoreBandsPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getGetUtopiaDataUtopiaPostMockHandler = (
	overrideResponse?:
		| UtopiaResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<UtopiaResponse> | UtopiaResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/utopia/',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetUtopiaDataUtopiaPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getGnimbusInitializeGnimbusInitializePostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gnimbus/initialize',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getGetLatestResultsGnimbusGetLatestResultsPostMockHandler = (
	overrideResponse?:
		| GNIMBUSResultResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<GNIMBUSResultResponse> | GNIMBUSResultResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gnimbus/get_latest_results',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetLatestResultsGnimbusGetLatestResultsPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getFullIterationGnimbusAllIterationsPostMockHandler = (
	overrideResponse?:
		| GNIMBUSAllIterationsResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<GNIMBUSAllIterationsResponse> | GNIMBUSAllIterationsResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gnimbus/all_iterations',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getFullIterationGnimbusAllIterationsPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getTogglePhaseGnimbusTogglePhasePostMockHandler = (
	overrideResponse?:
		| GNIMBUSSwitchPhaseResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<GNIMBUSSwitchPhaseResponse> | GNIMBUSSwitchPhaseResponse),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gnimbus/toggle_phase',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getTogglePhaseGnimbusTogglePhasePostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getCreateGroupGdmCreateGroupPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gdm/create_group',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getDeleteGroupGdmDeleteGroupPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gdm/delete_group',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getAddToGroupGdmAddToGroupPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gdm/add_to_group',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getRemoveFromGroupGdmRemoveFromGroupPostMockHandler = (
	overrideResponse?:
		| unknown
		| ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gdm/remove_from_group',
		async (info) => {
			await delay(1000);
			if (typeof overrideResponse === 'function') {
				await overrideResponse(info);
			}
			return new HttpResponse(null, { status: 200 });
		},
		options
	);
};

export const getGetGroupInfoGdmGetGroupInfoPostMockHandler = (
	overrideResponse?:
		| GroupPublic
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<GroupPublic> | GroupPublic),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/gdm/get_group_info',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getGetGroupInfoGdmGetGroupInfoPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};

export const getStepMethodEnautilusStepPostMockHandler = (
	overrideResponse?:
		| ENautilusState
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0]
		  ) => Promise<ENautilusState> | ENautilusState),
	options?: RequestHandlerOptions
) => {
	return http.post(
		'*/method/enautilus/step',
		async (info) => {
			await delay(1000);

			return new HttpResponse(
				JSON.stringify(
					overrideResponse !== undefined
						? typeof overrideResponse === 'function'
							? await overrideResponse(info)
							: overrideResponse
						: getStepMethodEnautilusStepPostResponseMock()
				),
				{ status: 200, headers: { 'Content-Type': 'application/json' } }
			);
		},
		options
	);
};
export const getDESDEOFastAPIMock = () => [
	getGetCurrentUserInfoUserInfoGetMockHandler(),
	getLoginLoginPostMockHandler(),
	getLogoutLogoutPostMockHandler(),
	getRefreshAccessTokenRefreshPostMockHandler(),
	getAddNewDmAddNewDmPostMockHandler(),
	getAddNewAnalystAddNewAnalystPostMockHandler(),
	getGetProblemsProblemAllGetMockHandler(),
	getGetProblemsInfoProblemAllInfoGetMockHandler(),
	getGetProblemProblemGetPostMockHandler(),
	getAddProblemProblemAddPostMockHandler(),
	getGetMetadataProblemGetMetadataPostMockHandler(),
	getSelectSolverProblemAssignSolverPostMockHandler(),
	getCreateNewSessionSessionNewPostMockHandler(),
	getGetSessionSessionGetPostMockHandler(),
	getSolveSolutionsMethodRpmSolvePostMockHandler(),
	getSolveSolutionsMethodNimbusSolvePostMockHandler(),
	getInitializeMethodNimbusInitializePostMockHandler(),
	getSaveMethodNimbusSavePostMockHandler(),
	getSolveNimbusIntermediateMethodNimbusIntermediatePostMockHandler(),
	getGetOrInitializeMethodNimbusGetOrInitializePostMockHandler(),
	getSolveIntermediateMethodGenericIntermediatePostMockHandler(),
	getCalculateScoreBandsMethodGenericScoreBandsPostMockHandler(),
	getGetUtopiaDataUtopiaPostMockHandler(),
	getGnimbusInitializeGnimbusInitializePostMockHandler(),
	getGetLatestResultsGnimbusGetLatestResultsPostMockHandler(),
	getFullIterationGnimbusAllIterationsPostMockHandler(),
	getTogglePhaseGnimbusTogglePhasePostMockHandler(),
	getCreateGroupGdmCreateGroupPostMockHandler(),
	getDeleteGroupGdmDeleteGroupPostMockHandler(),
	getAddToGroupGdmAddToGroupPostMockHandler(),
	getRemoveFromGroupGdmRemoveFromGroupPostMockHandler(),
	getGetGroupInfoGdmGetGroupInfoPostMockHandler(),
	getStepMethodEnautilusStepPostMockHandler()
];
