/**
 * +page.server.ts (Problem Definition Form - Server Actions)
 * 
 * @created July 2025
 * 
 * @description
 * Validation and API integration for the problem definition form.
 * Handles form submission, data parsing, validation, and communication with the DESDEO backend.
 * Implements custom validation logic for complex fields and proper error handling.
 * Handles inputs for problem name, description, variables, constants and objectives.
 * 
 * @features
 * - Form validation using SvelteKit Superforms + Zod schemas
 * - Custom validation for required fields (name, symbol) and minimum requirements
 * - JSON string parsing for complex fields (func, surrogates, scenario_keys, tensor bounds/values)
 * - Custom validation errors and user-friendly messages; automatic Zod errors don't work right in many cases
 * - Authentication (refresh token -> access token flow)
 * 
 * @architecture
 * - Uses custom schema that accepts strings for JSON fields, still using some autogenerated zod schemas
 * - Manual parsing converts JSON strings to arrays/objects before API call
 * - Separate custom error fields (objectiveErrors, variableErrors, constantErrors)
 * - Preserves automatic Zod errors for basic type validation
 * - Implements defense-in-depth validation strategy
 * 
 * @validation
 * - Minimum 2 variables and 1 objective required
 * - Required fields: name, symbol for all entities, name and description for problem
 * - JSON parsing with array validation for complex fields
 * - Type coercion and enum validation handled by Zod
 * 
 * @api
 * - POST /problem/add: Creates new optimization problem
 * - Authentication via refresh token -> access token flow
 * - Error handling for different backend response formats
 * 
 * @limitations
 * - Constraints, extra_funcs, scalarization_funcs etc. not implemented in UI
 * - Tensor variable/constant validation could be more robust
 * - Backend error message formatting could be improved
 * 
 * @dependencies
 * - SvelteKit: Framework utilities (redirect, error, setError)
 * - Superforms: Form validation and state management
 * - Zod: Schema validation and type inference
 * - Custom API client: Backend communication
 * 
 * @notes
 * - Returns 200 OK for validation errors (SvelteKit convention)
 * - API response logged for debugging backend communication
 * - Form state preserved on validation errors
 */

import { redirect, error } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';
import { api } from '$lib/api/client';
import { setError, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { schemas } from '$lib/api/zod-schemas';
import { z } from 'zod';

// Custom form-friendly schema that accepts strings for parsing
const formObjectiveSchema = schemas.Objective.extend({
  func: z.union([z.array(z.unknown()), z.string(), z.null()]).optional(),
  surrogates: z.union([z.array(z.string()), z.string(), z.null()]).optional(),
  scenario_keys: z.union([z.array(z.string()), z.string(), z.null()]).optional()
});

const problemSchema = z.object({
  name: z.string().min(1, "Name is required"),
  description: z.string().min(1, "Description is required"),
  variables: z.array(z.union([schemas.Variable, schemas.TensorVariable])),
  objectives: z.array(formObjectiveSchema),
  constants: z.array(z.union([schemas.Constant, schemas.TensorConstant])).default([]),
  // Optional fields with sensible defaults
  constraints: z.array(schemas.Constraint).optional(),
  extra_funcs: z.array(schemas.ExtraFunction).optional(),
  scalarization_funcs: z.array(schemas.ScalarizationFunction).optional(),
  discrete_representation: schemas.DiscreteRepresentation.optional(),
  scenario_keys: z.array(z.string()).optional(),
  simulators: z.array(schemas.Simulator).optional(),
  is_convex: z.boolean().optional(),
  is_linear: z.boolean().optional(),
  is_twice_differentiable: z.boolean().optional()
});

/**
 * Validation helper - parses JSON strings from form inputs
 * Used for complex fields like func, surrogates, scenario_keys, tensor bounds/values
 */
function parseAndValidateJSON(text: string, fieldName: string): { 
    success: boolean; 
    data: any; 
    error?: string 
} {
    try {
        const trimmed = text.trim();
        if (trimmed === '') return { success: true, data: null };
        
        const parsed = JSON.parse(trimmed);
        
        // Additional validation - ensure it's an array for bounds/values
        if (fieldName.includes('bounds') || fieldName.includes('values')) {
            if (!Array.isArray(parsed)) {
                return { 
                    success: false, 
                    data: null, 
                    error: `${fieldName} must be an array (e.g., [[1,2],[3,4]])` 
                };
            }
        }
        
        // Additional validation for objective fields that should be arrays
        if (fieldName === 'func' || fieldName === 'surrogates' || fieldName === 'scenario_keys') {
            if (!Array.isArray(parsed)) {
                return { 
                    success: false, 
                    data: null, 
                    error: `${fieldName} must be an array (e.g., ["item1", "item2"])` 
                };
            }
        }
        
        return { success: true, data: parsed };
    } catch (e) {
        return { 
            success: false, 
            data: null, 
            error: `Invalid JSON format in ${fieldName}. Expected format like ["item1", "item2"] or [[1,2],[3,4]]` 
        };
    }
}

export const load: PageServerLoad = async (event) => {
  const { cookies } = event;
  const refreshToken = cookies.get('refresh_token');
  if (!refreshToken) {
    throw redirect(307, '/home');
  }

  const form = await superValidate(event, zod(problemSchema));
  return { form };
};


export const actions: Actions = {
  create: async ({ request, cookies }) => {
    const form = await superValidate(request, zod(problemSchema));
    
    const name = form.data.name;
    const description = form.data.description;
    
    // Check minimum requirements
    if (!form.data.variables || form.data.variables.length < 2) {
        (form.errors as any).variables = [...((form.errors as any).variables || []), 'At least 2 variables are required'];
        form.valid = false;
    }

    if (!form.data.objectives || form.data.objectives.length < 1) {
        (form.errors as any).objectives = [...((form.errors as any).objectives || []), 'At least 1 objective is required'];
        form.valid = false;
    }
    
    // Parse and validate variables with proper error handling
    const variableErrors: string[] = [];
    const variables = form.data.variables.map((variable, idx) => {
      // Validate required fields
      if (!variable.name || variable.name.trim().length === 0) {
        variableErrors.push(`Variable ${idx + 1}: Name is required`);
      }
      if (!variable.symbol || variable.symbol.trim().length === 0) {
        variableErrors.push(`Variable ${idx + 1}: Symbol is required`);
      }
      // For tensor variables, parse lowerbounds, upperbounds, initial_values if they are strings
      if (Array.isArray(variable.shape)) {
          const result = { ...variable };
          
          // Parse lowerbounds
          if (typeof variable.lowerbounds === 'string') {
              const parseResult = parseAndValidateJSON(variable.lowerbounds, 'lowerbounds');
              if (!parseResult.success) {
                  variableErrors.push(`Variable ${idx + 1}: ${parseResult.error}`);
              } else {
                  result.lowerbounds = parseResult.data;
              }
          }
          
          // Parse upperbounds
          if (typeof variable.upperbounds === 'string') {
              const parseResult = parseAndValidateJSON(variable.upperbounds, 'upperbounds');
              if (!parseResult.success) {
                  variableErrors.push(`Variable ${idx + 1}: ${parseResult.error}`);
              } else {
                  result.upperbounds = parseResult.data;
              }
          }
          
          // Parse initial_values
          if (typeof variable.initial_values === 'string') {
              const parseResult = parseAndValidateJSON(variable.initial_values, 'initial_values');
              if (!parseResult.success) {
                  variableErrors.push(`Variable ${idx + 1}: ${parseResult.error}`);
              } else {
                  result.initial_values = parseResult.data;
              }
          }
          
          return result;
      }
      return variable;
    });
    
    // If there were parsing errors, return the form with errors
    if (variableErrors.length > 0) {
      (form.errors as any).variableErrors = [...((form.errors as any).variableErrors || []), variableErrors.join('; ')];
      form.valid = false;
    }
    // Parse and validate constants with proper error handling
    const constantErrors: string[] = [];
    const constants = form.data.constants?.map((constant, idx) => {
        if (!constant.name || constant.name.trim().length === 0) {
          constantErrors.push(`Constant ${idx + 1}: Name is required`);
        }
        if (!constant.symbol || constant.symbol.trim().length === 0) {
          constantErrors.push(`Constant ${idx + 1}: Symbol is required`);
        }
        // For tensor constants, parse values if it's a string
        if (Array.isArray(constant.shape)) {
            const result = { ...constant };
          
          if (typeof constant.values === 'string') {
              const parseResult = parseAndValidateJSON(constant.values, 'values');
              if (!parseResult.success) {
                  constantErrors.push(`Constant ${idx + 1}: ${parseResult.error}`);
              } else {
                  result.values = parseResult.data;
              }
          }
          
          return result;
      }
      return constant;
    });
    
    // If there were parsing errors, return the form with errors
    if (constantErrors.length > 0) {
      (form.errors as any).constantErrors = [...((form.errors as any).constantErrors || []), constantErrors.join('; ')];
      form.valid = false;
    }
    // Parse and validate objectives with proper error handling
    const objectiveErrors: string[] = [];
    const objectives = form.data.objectives.map((obj, idx) => {
      // Validate required fields
      if (!obj.name || obj.name.trim().length === 0) {
        objectiveErrors.push(`Objective ${idx + 1}: Name is required`);
      }
      if (!obj.symbol || obj.symbol.trim().length === 0) {
        objectiveErrors.push(`Objective ${idx + 1}: Symbol is required`);
      }
      
      const result = {
        ...obj,
        objective_type: obj.objective_type ?? "analytical"
      };
      
      // Parse func if it's a string
      if (typeof obj.func === 'string') {
          const parseResult = parseAndValidateJSON(obj.func, 'func');
          if (!parseResult.success) {
              objectiveErrors.push(`Objective ${idx + 1}: ${parseResult.error}`);
          } else {
              result.func = parseResult.data;
          }
      }
      
      // Parse surrogates if it's a string
      if (typeof obj.surrogates === 'string') {
          const parseResult = parseAndValidateJSON(obj.surrogates, 'surrogates');
          if (!parseResult.success) {
              objectiveErrors.push(`Objective ${idx + 1}: ${parseResult.error}`);
          } else {
              result.surrogates = parseResult.data;
          }
      }
      
      // Parse scenario_keys if it's a string
      if (typeof obj.scenario_keys === 'string') {
          const parseResult = parseAndValidateJSON(obj.scenario_keys, 'scenario_keys');
          if (!parseResult.success) {
              objectiveErrors.push(`Objective ${idx + 1}: ${parseResult.error}`);
          } else {
              result.scenario_keys = parseResult.data;
          }
      }
      
      return result;
    });
    // If there were objective validation errors, return the form with errors
    if (objectiveErrors.length > 0) {
        (form.errors as any).objectiveErrors = [...((form.errors as any).objectiveErrors || []), objectiveErrors.join("; ")];
        form.valid = false;
    }

    if (!form.valid) {
      return { form }; 
    }
    
    // Get refresh token from cookies
    const refreshToken = cookies.get('refresh_token');
    if (!refreshToken) {
      return { form, error: 'Not authenticated' };
    }
    // Get a new access token from backend
    const refreshRes = await fetch(`${import.meta.env.VITE_API_URL}/refresh`, {
      method: 'POST',
      credentials: 'include',
      headers: {
        cookie: `refresh_token=${refreshToken}`
      }
    });
    if (!refreshRes.ok) {
      return { form, error: 'Failed to refresh token' };
    }
    const { access_token } = await refreshRes.json();

    // Transform data to match API schema and make the API call
    try {
      const apiBody: any = {
        name,
        description,
        variables,
        objectives
      };

      // Only include constants if there are any
      if (constants && constants.length > 0) {
        apiBody.constants = constants;
      }
      
      const res: any = await api.POST('/problem/add', {
        body: apiBody,
        headers: {
          Authorization: `Bearer ${access_token}`,
          'Content-Type': 'application/json'
        }
      });
      
      // Log API response for debugging backend communication
      console.log("API Response:", JSON.stringify(res));
      
      if (res.error) {
          let errorMsg = 'Internal server error';
          // Handle different error formats from backend
          if (typeof res.error.detail === 'string') {
              errorMsg = res.error.detail;
          } else if (Array.isArray(res.error.detail) && res.error.detail.length > 0) {
              // Validation errors (array of validation error objects)
              errorMsg = res.error.detail.map((e: any) => e.msg || JSON.stringify(e)).join('; ');
          } else if (res.error.message) {
              errorMsg = res.error.message;
          }
          
          throw error(500, { message: errorMsg });
      }
      return { form, result: res.data };
     } catch (e) {
        // Type guard for SvelteKit errors
        if (e && typeof e === 'object' && 'status' in e && 'body' in e) {
          // This is a SvelteKit error we threw - let it bubble up
          throw e;
        }
        // This is a network/connection error - use setError to preserve form data
        return setError(form, 'Network error: Failed to connect to server');
      }
    }
  };
